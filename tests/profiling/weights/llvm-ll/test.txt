Args: lli -enable-online-profile -debug thresh1.ll 
Subtarget features: SSELevel 8, 3DNowLevel 0, 64bit 1
CGP: Found      local addrmode: [Base:%retval]
CGP: Found      local addrmode: [Base:%i]
CGP: Found      local addrmode: [Base:%i]
CGP: Found      local addrmode: [Base:%i]
CGP: Found      local addrmode: [Base:%i]
CGP: Found      local addrmode: [Base:%i]
Computing probabilities for for.inc
set edge for.inc -> 0 successor weight to 124
Computing probabilities for for.body
set edge for.body -> 0 successor weight to 124
Computing probabilities for for.end
Computing probabilities for for.cond
set edge for.cond -> 0 successor weight to 124
set edge for.cond -> 1 successor weight to 4
Computing probabilities for entry



=== main
Initial selection DAG: BB#0 'main:entry'
SelectionDAG has 8 nodes:
  0x2e7f3b0: i32 = Constant<0>

  0x2e7f5b0: i64 = Constant<0>

  0x2e7f6b0: i64 = undef

      0x2e5c478: ch = EntryToken

      0x2e7f3b0: <multiple use>
      0x2e7f4b0: i64 = FrameIndex<0>

      0x2e7f6b0: <multiple use>
    0x2e7f7b0: ch = store 0x2e5c478, 0x2e7f3b0, 0x2e7f4b0, 0x2e7f6b0<ST4[%retval]> [ORD=3]

    0x2e7f3b0: <multiple use>
    0x2e7f8b0: i64 = FrameIndex<1>

    0x2e7f6b0: <multiple use>
  0x2e7f9b0: ch = store 0x2e7f7b0, 0x2e7f3b0, 0x2e7f8b0, 0x2e7f6b0<ST4[%i]> [ORD=4]


Optimized lowered selection DAG: BB#0 'main:entry'
SelectionDAG has 7 nodes:
  0x2e7f3b0: i32 = Constant<0>

  0x2e7f6b0: i64 = undef

      0x2e5c478: ch = EntryToken

      0x2e7f3b0: <multiple use>
      0x2e7f4b0: i64 = FrameIndex<0>

      0x2e7f6b0: <multiple use>
    0x2e7f7b0: ch = store 0x2e5c478, 0x2e7f3b0, 0x2e7f4b0, 0x2e7f6b0<ST4[%retval]> [ORD=3]

    0x2e7f3b0: <multiple use>
    0x2e7f8b0: i64 = FrameIndex<1>

    0x2e7f6b0: <multiple use>
  0x2e7f9b0: ch = store 0x2e7f7b0, 0x2e7f3b0, 0x2e7f8b0, 0x2e7f6b0<ST4[%i]> [ORD=4]


Legally typed node: 0x2e7f8b0: i64 = FrameIndex<1> [ID=0]

Legally typed node: 0x2e7f6b0: i64 = undef [ID=0]

Legally typed node: 0x2e7f4b0: i64 = FrameIndex<0> [ID=0]

Legally typed node: 0x2e7f3b0: i32 = Constant<0> [ID=0]

Legally typed node: 0x2e5c478: ch = EntryToken [ID=0]

Legally typed node: 0x2e7f7b0: ch = store 0x2e5c478, 0x2e7f3b0, 0x2e7f4b0, 0x2e7f6b0<ST4[%retval]> [ORD=3] [ID=0]

Legally typed node: 0x2e7f9b0: ch = store 0x2e7f7b0, 0x2e7f3b0, 0x2e7f8b0, 0x2e7f6b0<ST4[%i]> [ORD=4] [ID=0]

Legally typed node: 0x7fff29e7be60: ch = handlenode 0x2e7f9b0 [ID=0]

Type-legalized selection DAG: BB#0 'main:entry'
SelectionDAG has 7 nodes:
  0x2e7f3b0: i32 = Constant<0> [ID=-3]

  0x2e7f6b0: i64 = undef [ID=-3]

      0x2e5c478: ch = EntryToken [ID=-3]

      0x2e7f3b0: <multiple use>
      0x2e7f4b0: i64 = FrameIndex<0> [ID=-3]

      0x2e7f6b0: <multiple use>
    0x2e7f7b0: ch = store 0x2e5c478, 0x2e7f3b0, 0x2e7f4b0, 0x2e7f6b0<ST4[%retval]> [ORD=3] [ID=-3]

    0x2e7f3b0: <multiple use>
    0x2e7f8b0: i64 = FrameIndex<1> [ID=-3]

    0x2e7f6b0: <multiple use>
  0x2e7f9b0: ch = store 0x2e7f7b0, 0x2e7f3b0, 0x2e7f8b0, 0x2e7f6b0<ST4[%i]> [ORD=4] [ID=-3]


Legalized selection DAG: BB#0 'main:entry'
SelectionDAG has 7 nodes:
  0x2e7f3b0: i32 = Constant<0> [ID=1]

  0x2e7f6b0: i64 = undef [ID=3]

      0x2e5c478: ch = EntryToken [ID=0]

      0x2e7f3b0: <multiple use>
      0x2e7f4b0: i64 = FrameIndex<0> [ID=2]

      0x2e7f6b0: <multiple use>
    0x2e7f7b0: ch = store 0x2e5c478, 0x2e7f3b0, 0x2e7f4b0, 0x2e7f6b0<ST4[%retval]> [ORD=3] [ID=5]

    0x2e7f3b0: <multiple use>
    0x2e7f8b0: i64 = FrameIndex<1> [ID=4]

    0x2e7f6b0: <multiple use>
  0x2e7f9b0: ch = store 0x2e7f7b0, 0x2e7f3b0, 0x2e7f8b0, 0x2e7f6b0<ST4[%i]> [ORD=4] [ID=6]


Optimized legalized selection DAG: BB#0 'main:entry'
SelectionDAG has 7 nodes:
  0x2e7f3b0: i32 = Constant<0> [ID=1]

  0x2e7f6b0: i64 = undef [ID=3]

      0x2e5c478: ch = EntryToken [ID=0]

      0x2e7f3b0: <multiple use>
      0x2e7f4b0: i64 = FrameIndex<0> [ID=2]

      0x2e7f6b0: <multiple use>
    0x2e7f7b0: ch = store 0x2e5c478, 0x2e7f3b0, 0x2e7f4b0, 0x2e7f6b0<ST4[%retval]> [ORD=3] [ID=5]

    0x2e7f3b0: <multiple use>
    0x2e7f8b0: i64 = FrameIndex<1> [ID=4]

    0x2e7f6b0: <multiple use>
  0x2e7f9b0: ch = store 0x2e7f7b0, 0x2e7f3b0, 0x2e7f8b0, 0x2e7f6b0<ST4[%i]> [ORD=4] [ID=6]


===== Instruction selection begins: BB#0 'entry'
Selecting: 0x2e7f9b0: ch = store 0x2e7f7b0, 0x2e7f3b0, 0x2e7f8b0, 0x2e7f6b0<ST4[%i]> [ORD=4] [ID=6]

ISEL: Starting pattern match on root node: 0x2e7f9b0: ch = store 0x2e7f7b0, 0x2e7f3b0, 0x2e7f8b0, 0x2e7f6b0<ST4[%i]> [ORD=4] [ID=6]

  Skipped scope entry (due to false predicate) at index 13, continuing at 58
  Skipped scope entry (due to false predicate) at index 59, continuing at 104
  Skipped scope entry (due to false predicate) at index 105, continuing at 188
  Skipped scope entry (due to false predicate) at index 189, continuing at 212
  Skipped scope entry (due to false predicate) at index 213, continuing at 236
  Skipped scope entry (due to false predicate) at index 237, continuing at 260
  Match failed at index 264
  Continuing at 284
  Match failed at index 285
  Continuing at 308
  Continuing at 309
  Match failed at index 313
  Continuing at 10708
  Match failed at index 10713
  Continuing at 11131
  Match failed at index 11135
  Continuing at 11509
  TypeSwitch[i32] from 11516 to 11599
MatchAddress: X86ISelAddressMode 0x7fff29e7b9b0
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
  Morphed node: 0x2e7f9b0: ch = MOV32mi 0x2e7fab0, 0x2e7fbb0, 0x2e7f5b0, 0x2e7fcb0, 0x2e7fdb0, 0x2e7fcb0, 0x2e7f7b0<Mem:ST4[%i]> [ORD=4]

ISEL: Match complete!
=> 0x2e7f9b0: ch = MOV32mi 0x2e7fab0, 0x2e7fbb0, 0x2e7f5b0, 0x2e7fcb0, 0x2e7fdb0, 0x2e7fcb0, 0x2e7f7b0<Mem:ST4[%i]> [ORD=4]

Selecting: 0x2e7f7b0: ch = store 0x2e5c478, 0x2e7f3b0, 0x2e7f4b0, 0x2e7f6b0<ST4[%retval]> [ORD=3] [ID=5]

ISEL: Starting pattern match on root node: 0x2e7f7b0: ch = store 0x2e5c478, 0x2e7f3b0, 0x2e7f4b0, 0x2e7f6b0<ST4[%retval]> [ORD=3] [ID=5]

  Initial Opcode index to 5
  Skipped scope entry (due to false predicate) at index 13, continuing at 58
  Skipped scope entry (due to false predicate) at index 59, continuing at 104
  Skipped scope entry (due to false predicate) at index 105, continuing at 188
  Skipped scope entry (due to false predicate) at index 189, continuing at 212
  Skipped scope entry (due to false predicate) at index 213, continuing at 236
  Skipped scope entry (due to false predicate) at index 237, continuing at 260
  Match failed at index 264
  Continuing at 284
  Match failed at index 285
  Continuing at 308
  Continuing at 309
  Match failed at index 313
  Continuing at 10708
  Match failed at index 10713
  Continuing at 11131
  Match failed at index 11135
  Continuing at 11509
  TypeSwitch[i32] from 11516 to 11599
MatchAddress: X86ISelAddressMode 0x7fff29e7b9b0
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
  Morphed node: 0x2e7f7b0: ch = MOV32mi 0x2e7f8b0, 0x2e7fbb0, 0x2e7f5b0, 0x2e7fcb0, 0x2e7fdb0, 0x2e7fcb0, 0x2e5c478<Mem:ST4[%retval]> [ORD=3]

ISEL: Match complete!
=> 0x2e7f7b0: ch = MOV32mi 0x2e7f8b0, 0x2e7fbb0, 0x2e7f5b0, 0x2e7fcb0, 0x2e7fdb0, 0x2e7fcb0, 0x2e5c478<Mem:ST4[%retval]> [ORD=3]

Selecting: 0x2e5c478: ch = EntryToken [ID=0]

=> 0x2e5c478: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: BB#0 'main:entry'
SelectionDAG has 9 nodes:
  0x2e7f5b0: i64 = Register %noreg

  0x2e7fbb0: i8 = TargetConstant<1>

  0x2e7fcb0: i32 = TargetConstant<0>

  0x2e7fdb0: i32 = Register %noreg

    0x2e7fab0: i64 = TargetFrameIndex<1>

    0x2e7fbb0: <multiple use>
    0x2e7f5b0: <multiple use>
    0x2e7fcb0: <multiple use>
    0x2e7fdb0: <multiple use>
    0x2e7fcb0: <multiple use>
      0x2e7f8b0: i64 = TargetFrameIndex<0>

      0x2e7fbb0: <multiple use>
      0x2e7f5b0: <multiple use>
      0x2e7fcb0: <multiple use>
      0x2e7fdb0: <multiple use>
      0x2e7fcb0: <multiple use>
      0x2e5c478: ch = EntryToken

    0x2e7f7b0: ch = MOV32mi 0x2e7f8b0, 0x2e7fbb0, 0x2e7f5b0, 0x2e7fcb0, 0x2e7fdb0, 0x2e7fcb0, 0x2e5c478<Mem:ST4[%retval]> [ORD=3]

  0x2e7f9b0: ch = MOV32mi 0x2e7fab0, 0x2e7fbb0, 0x2e7f5b0, 0x2e7fcb0, 0x2e7fdb0, 0x2e7fcb0, 0x2e7f7b0<Mem:ST4[%i]> [ORD=4]


********** List Scheduling BB#0 'entry' **********
SU(0): 0x2e7f9b0: ch = MOV32mi 0x2e7fab0, 0x2e7fbb0, 0x2e7f5b0, 0x2e7fcb0, 0x2e7fdb0, 0x2e7fcb0, 0x2e7f7b0<Mem:ST4[%i]> [ORD=4] [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
   ch  SU(1): Latency=1

SU(1): 0x2e7f7b0: ch = MOV32mi 0x2e7f8b0, 0x2e7fbb0, 0x2e7f5b0, 0x2e7fcb0, 0x2e7fdb0, 0x2e7fcb0, 0x2e5c478<Mem:ST4[%retval]> [ORD=3] [ID=1]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(0): Latency=1


Examining Available:
Height 0: SU(0): 0x2e7f9b0: ch = MOV32mi 0x2e7fab0, 0x2e7fbb0, 0x2e7f5b0, 0x2e7fcb0, 0x2e7fdb0, 0x2e7fcb0, 0x2e7f7b0<Mem:ST4[%i]> [ORD=4] [ID=0]


*** Scheduling [0]: SU(0): 0x2e7f9b0: ch = MOV32mi 0x2e7fab0, 0x2e7fbb0, 0x2e7f5b0, 0x2e7fcb0, 0x2e7fdb0, 0x2e7fcb0, 0x2e7f7b0<Mem:ST4[%i]> [ORD=4] [ID=0]


Examining Available:
Height 1: SU(1): 0x2e7f7b0: ch = MOV32mi 0x2e7f8b0, 0x2e7fbb0, 0x2e7f5b0, 0x2e7fcb0, 0x2e7fdb0, 0x2e7fcb0, 0x2e5c478<Mem:ST4[%retval]> [ORD=3] [ID=1]


*** Scheduling [1]: SU(1): 0x2e7f7b0: ch = MOV32mi 0x2e7f8b0, 0x2e7fbb0, 0x2e7f5b0, 0x2e7fcb0, 0x2e7fdb0, 0x2e7fcb0, 0x2e5c478<Mem:ST4[%retval]> [ORD=3] [ID=1]

*** Final schedule ***
SU(1): 0x2e7f7b0: ch = MOV32mi 0x2e7f8b0, 0x2e7fbb0, 0x2e7f5b0, 0x2e7fcb0, 0x2e7fdb0, 0x2e7fcb0, 0x2e5c478<Mem:ST4[%retval]> [ORD=3] [ID=1]

SU(0): 0x2e7f9b0: ch = MOV32mi 0x2e7fab0, 0x2e7fbb0, 0x2e7f5b0, 0x2e7fcb0, 0x2e7fdb0, 0x2e7fcb0, 0x2e7f7b0<Mem:ST4[%i]> [ORD=4] [ID=0]


Total amount of phi nodes to update: 0
Initial selection DAG: BB#1 'main:for.cond'
SelectionDAG has 14 nodes:
  0x2e5c478: ch = EntryToken

  0x2e7fdb0: i64 = Constant<0>

      0x2e5c478: <multiple use>
            0x2e5c478: <multiple use>
            0x2e7f8b0: i64 = FrameIndex<1>

            0x2e7fcb0: i64 = undef

          0x2e7fbb0: i32,ch = load 0x2e5c478, 0x2e7f8b0, 0x2e7fcb0<LD4[%i]> [ORD=6]

          0x2e7fab0: i32 = Constant<11>

          0x2e7f5b0: ch = setlt

        0x2e7f9b0: i1 = setcc 0x2e7fbb0, 0x2e7fab0, 0x2e7f5b0 [ORD=7]

        0x2e7f7b0: i1 = Constant<-1>

      0x2e7f3b0: i1 = xor 0x2e7f9b0, 0x2e7f7b0 [ORD=8]

      0x2e7f4b0: ch = BasicBlock<for.end 0x2e79c20>

    0x2e7f6b0: ch = brcond 0x2e5c478, 0x2e7f3b0, 0x2e7f4b0 [ORD=8]

    0x2e7feb0: ch = BasicBlock<for.body 0x2e79ac0>

  0x2e7ffb0: ch = br 0x2e7f6b0, 0x2e7feb0 [ORD=8]



Replacing.3 0x2e7f3b0: i1 = xor 0x2e7f9b0, 0x2e7f7b0 [ORD=8]

With: 0x2e801b0: i1 = setcc 0x2e7fbb0, 0x2e7fab0, 0x2e800b0 [ORD=8]


Replacing.3 0x2e801b0: i1 = setcc 0x2e7fbb0, 0x2e7fab0, 0x2e800b0 [ORD=8]

With: 0x2e7f7b0: i1 = setcc 0x2e7fbb0, 0x2e7f5b0, 0x2e7f9b0 [ORD=8]

Optimized lowered selection DAG: BB#1 'main:for.cond'
SelectionDAG has 11 nodes:
  0x2e5c478: ch = EntryToken

      0x2e5c478: <multiple use>
          0x2e5c478: <multiple use>
          0x2e7f8b0: i64 = FrameIndex<1>

          0x2e7fcb0: i64 = undef

        0x2e7fbb0: i32,ch = load 0x2e5c478, 0x2e7f8b0, 0x2e7fcb0<LD4[%i]> [ORD=6]

        0x2e7f5b0: i32 = Constant<10>

        0x2e7f9b0: ch = setgt

      0x2e7f7b0: i1 = setcc 0x2e7fbb0, 0x2e7f5b0, 0x2e7f9b0 [ORD=8]

      0x2e7f4b0: ch = BasicBlock<for.end 0x2e79c20>

    0x2e7f6b0: ch = brcond 0x2e5c478, 0x2e7f7b0, 0x2e7f4b0 [ORD=8]

    0x2e7feb0: ch = BasicBlock<for.body 0x2e79ac0>

  0x2e7ffb0: ch = br 0x2e7f6b0, 0x2e7feb0 [ORD=8]


Legally typed node: 0x2e7f9b0: ch = setgt [ID=0]

Legally typed node: 0x2e7f5b0: i32 = Constant<10> [ID=0]

Legally typed node: 0x2e7feb0: ch = BasicBlock<for.body 0x2e79ac0> [ID=0]

Legally typed node: 0x2e7f4b0: ch = BasicBlock<for.end 0x2e79c20> [ID=0]

Legally typed node: 0x2e7fcb0: i64 = undef [ID=0]

Legally typed node: 0x2e7f8b0: i64 = FrameIndex<1> [ID=0]

Legally typed node: 0x2e5c478: ch = EntryToken [ID=0]

Legally typed node: 0x2e7fbb0: i32,ch = load 0x2e5c478, 0x2e7f8b0, 0x2e7fcb0<LD4[%i]> [ORD=6] [ID=0]

Promote integer result: 0x2e7f7b0: i1 = setcc 0x2e7fbb0, 0x2e7f5b0, 0x2e7f9b0 [ORD=8] [ID=0]

Promote integer operand: 0x2e7f6b0: ch = brcond 0x2e5c478, 0x2e7f7b0, 0x2e7f4b0 [ORD=8] [ID=0]

Promote integer operand: 0x2e7fab0: i8 = zero_extend 0x2e7f7b0 [ORD=8] [ID=0]

Legally typed node: 0x2e800b0: i8 = Constant<1> [ID=0]

Legally typed node: 0x2e7fdb0: i8 = setcc 0x2e7fbb0, 0x2e7f5b0, 0x2e7f9b0 [ORD=8] [ID=0]

Legally typed node: 0x2e801b0: i8 = and 0x2e7fdb0, 0x2e800b0 [ORD=8] [ID=0]

Legally typed node: 0x2e7f6b0: ch = brcond 0x2e5c478, 0x2e801b0, 0x2e7f4b0 [ORD=8] [ID=0]

Legally typed node: 0x2e7ffb0: ch = br 0x2e7f6b0, 0x2e7feb0 [ORD=8] [ID=0]

Legally typed node: 0x7fff29e7be60: ch = handlenode 0x2e7ffb0 [ID=0]

Type-legalized selection DAG: BB#1 'main:for.cond'
SelectionDAG has 13 nodes:
  0x2e5c478: ch = EntryToken [ID=-3]

      0x2e5c478: <multiple use>
            0x2e5c478: <multiple use>
            0x2e7f8b0: i64 = FrameIndex<1> [ID=-3]

            0x2e7fcb0: i64 = undef [ID=-3]

          0x2e7fbb0: i32,ch = load 0x2e5c478, 0x2e7f8b0, 0x2e7fcb0<LD4[%i]> [ORD=6] [ID=-3]

          0x2e7f5b0: i32 = Constant<10> [ID=-3]

          0x2e7f9b0: ch = setgt [ID=-3]

        0x2e7fdb0: i8 = setcc 0x2e7fbb0, 0x2e7f5b0, 0x2e7f9b0 [ORD=8] [ID=-3]

        0x2e800b0: i8 = Constant<1> [ID=-3]

      0x2e801b0: i8 = and 0x2e7fdb0, 0x2e800b0 [ORD=8] [ID=-3]

      0x2e7f4b0: ch = BasicBlock<for.end 0x2e79c20> [ID=-3]

    0x2e7f6b0: ch = brcond 0x2e5c478, 0x2e801b0, 0x2e7f4b0 [ORD=8] [ID=-3]

    0x2e7feb0: ch = BasicBlock<for.body 0x2e79ac0> [ID=-3]

  0x2e7ffb0: ch = br 0x2e7f6b0, 0x2e7feb0 [ORD=8] [ID=-3]



Replacing.2 0x2e801b0: i8 = and 0x2e7fdb0, 0x2e800b0 [ORD=8] [ID=-3]

With: 0x2e7fdb0: i8 = setcc 0x2e7fbb0, 0x2e7f5b0, 0x2e7f9b0 [ORD=8] [ID=-3]

Optimized type-legalized selection DAG: BB#1 'main:for.cond'
SelectionDAG has 11 nodes:
  0x2e5c478: ch = EntryToken [ID=-3]

      0x2e5c478: <multiple use>
          0x2e5c478: <multiple use>
          0x2e7f8b0: i64 = FrameIndex<1> [ID=-3]

          0x2e7fcb0: i64 = undef [ID=-3]

        0x2e7fbb0: i32,ch = load 0x2e5c478, 0x2e7f8b0, 0x2e7fcb0<LD4[%i]> [ORD=6] [ID=-3]

        0x2e7f5b0: i32 = Constant<10> [ID=-3]

        0x2e7f9b0: ch = setgt [ID=-3]

      0x2e7fdb0: i8 = setcc 0x2e7fbb0, 0x2e7f5b0, 0x2e7f9b0 [ORD=8] [ID=-3]

      0x2e7f4b0: ch = BasicBlock<for.end 0x2e79c20> [ID=-3]

    0x2e7f6b0: ch = brcond 0x2e5c478, 0x2e7fdb0, 0x2e7f4b0 [ORD=8] [ID=-3]

    0x2e7feb0: ch = BasicBlock<for.body 0x2e79ac0> [ID=-3]

  0x2e7ffb0: ch = br 0x2e7f6b0, 0x2e7feb0 [ORD=8] [ID=-3]


Legalized selection DAG: BB#1 'main:for.cond'
SelectionDAG has 11 nodes:
  0x2e5c478: ch = EntryToken [ID=0]

      0x2e5c478: <multiple use>
      0x2e7f4b0: ch = BasicBlock<for.end 0x2e79c20> [ID=3]

      0x2e801b0: i8 = Constant<5>

          0x2e5c478: <multiple use>
          0x2e7f8b0: i64 = FrameIndex<1> [ID=1]

          0x2e7fcb0: i64 = undef [ID=2]

        0x2e7fbb0: i32,ch = load 0x2e5c478, 0x2e7f8b0, 0x2e7fcb0<LD4[%i]> [ORD=6] [ID=7]

        0x2e7f5b0: i32 = Constant<10> [ID=5]

      0x2e800b0: i32,i32 = X86ISD::SUB 0x2e7fbb0, 0x2e7f5b0 [ORD=6]

    0x2e7fab0: ch = X86ISD::BRCOND 0x2e5c478, 0x2e7f4b0, 0x2e801b0, 0x2e800b0:1 [ORD=8]

    0x2e7feb0: ch = BasicBlock<for.body 0x2e79ac0> [ID=4]

  0x2e7ffb0: ch = br 0x2e7fab0, 0x2e7feb0 [ORD=8] [ID=10]


Optimized legalized selection DAG: BB#1 'main:for.cond'
SelectionDAG has 11 nodes:
  0x2e5c478: ch = EntryToken [ID=0]

      0x2e5c478: <multiple use>
      0x2e7f4b0: ch = BasicBlock<for.end 0x2e79c20> [ID=3]

      0x2e801b0: i8 = Constant<5>

          0x2e5c478: <multiple use>
          0x2e7f8b0: i64 = FrameIndex<1> [ID=1]

          0x2e7fcb0: i64 = undef [ID=2]

        0x2e7fbb0: i32,ch = load 0x2e5c478, 0x2e7f8b0, 0x2e7fcb0<LD4[%i]> [ORD=6] [ID=7]

        0x2e7f5b0: i32 = Constant<10> [ID=5]

      0x2e800b0: i32,i32 = X86ISD::SUB 0x2e7fbb0, 0x2e7f5b0 [ORD=6]

    0x2e7fab0: ch = X86ISD::BRCOND 0x2e5c478, 0x2e7f4b0, 0x2e801b0, 0x2e800b0:1 [ORD=8]

    0x2e7feb0: ch = BasicBlock<for.body 0x2e79ac0> [ID=4]

  0x2e7ffb0: ch = br 0x2e7fab0, 0x2e7feb0 [ORD=8] [ID=10]


===== Instruction selection begins: BB#1 'for.cond'
Selecting: 0x2e7ffb0: ch = br 0x2e7fab0, 0x2e7feb0 [ORD=8] [ID=10]

ISEL: Starting pattern match on root node: 0x2e7ffb0: ch = br 0x2e7fab0, 0x2e7feb0 [ORD=8] [ID=10]

  Initial Opcode index to 95705
  Morphed node: 0x2e7ffb0: ch = JMP_4 0x2e7feb0, 0x2e7fab0 [ORD=8]

ISEL: Match complete!
=> 0x2e7ffb0: ch = JMP_4 0x2e7feb0, 0x2e7fab0 [ORD=8]

Selecting: 0x2e7fab0: ch = X86ISD::BRCOND 0x2e5c478, 0x2e7f4b0, 0x2e801b0, 0x2e800b0:1 [ORD=8] [ID=9]

ISEL: Starting pattern match on root node: 0x2e7fab0: ch = X86ISD::BRCOND 0x2e5c478, 0x2e7f4b0, 0x2e801b0, 0x2e800b0:1 [ORD=8] [ID=9]

  Initial Opcode index to 93272
  Skipped scope entry (due to false predicate) at index 93284, continuing at 93299
  Skipped scope entry (due to false predicate) at index 93300, continuing at 93315
  Skipped scope entry (due to false predicate) at index 93316, continuing at 93331
  Skipped scope entry (due to false predicate) at index 93332, continuing at 93347
  Skipped scope entry (due to false predicate) at index 93348, continuing at 93363
  Skipped scope entry (due to false predicate) at index 93364, continuing at 93379
  Skipped scope entry (due to false predicate) at index 93380, continuing at 93395
  Skipped scope entry (due to false predicate) at index 93396, continuing at 93411
  Skipped scope entry (due to false predicate) at index 93412, continuing at 93427
  Skipped scope entry (due to false predicate) at index 93428, continuing at 93443
  Skipped scope entry (due to false predicate) at index 93444, continuing at 93459
  Skipped scope entry (due to false predicate) at index 93460, continuing at 93475
  Skipped scope entry (due to false predicate) at index 93476, continuing at 93491
  Skipped scope entry (due to false predicate) at index 93492, continuing at 93507
  Skipped scope entry (due to false predicate) at index 93508, continuing at 93523
  Morphed node: 0x2e7fab0: ch = JG_4 0x2e7f4b0, 0x2e7f9b0, 0x2e7f9b0:1 [ORD=8]

ISEL: Match complete!
=> 0x2e7fab0: ch = JG_4 0x2e7f4b0, 0x2e7f9b0, 0x2e7f9b0:1 [ORD=8]

Selecting: 0x2e800b0: i32,i32 = X86ISD::SUB 0x2e7fbb0, 0x2e7f5b0 [ORD=6] [ID=8]

ISEL: Starting pattern match on root node: 0x2e800b0: i32,i32 = X86ISD::SUB 0x2e7fbb0, 0x2e7f5b0 [ORD=6] [ID=8]

  Initial Opcode index to 68720
  Match failed at index 68725
  Continuing at 68832
  Match failed at index 68835
  Continuing at 68885
  Match failed at index 68901
  Continuing at 68915
  Morphed node: 0x2e800b0: i32,i32 = SUB32ri8 0x2e7fbb0, 0x2e801b0 [ORD=6]

ISEL: Match complete!
=> 0x2e800b0: i32,i32 = SUB32ri8 0x2e7fbb0, 0x2e801b0 [ORD=6]

Selecting: 0x2e7fbb0: i32,ch = load 0x2e5c478, 0x2e7f8b0, 0x2e7fcb0<LD4[%i]> [ORD=6] [ID=7]

ISEL: Starting pattern match on root node: 0x2e7fbb0: i32,ch = load 0x2e5c478, 0x2e7f8b0, 0x2e7fcb0<LD4[%i]> [ORD=6] [ID=7]

  Initial Opcode index to 83164
  Match failed at index 83173
  Continuing at 83191
  Match failed at index 83194
  Continuing at 83212
MatchAddress: X86ISelAddressMode 0x7fff29e7b9b0
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
  Morphed node: 0x2e7fbb0: i32,ch = MOV32rm 0x2e7fdb0, 0x2e7f6b0, 0x2e7f5b0, 0x2e7f3b0, 0x2e83b40, 0x2e5c478<Mem:LD4[%i]> [ORD=6]

ISEL: Match complete!
=> 0x2e7fbb0: i32,ch = MOV32rm 0x2e7fdb0, 0x2e7f6b0, 0x2e7f5b0, 0x2e7f3b0, 0x2e83b40, 0x2e5c478<Mem:LD4[%i]> [ORD=6]

Selecting: 0x2e7feb0: ch = BasicBlock<for.body 0x2e79ac0> [ID=4]

=> 0x2e7feb0: ch = BasicBlock<for.body 0x2e79ac0>

Selecting: 0x2e7f4b0: ch = BasicBlock<for.end 0x2e79c20> [ID=3]

=> 0x2e7f4b0: ch = BasicBlock<for.end 0x2e79c20>

Selecting: 0x2e5c478: ch = EntryToken [ID=0]

=> 0x2e5c478: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: BB#1 'main:for.cond'
SelectionDAG has 15 nodes:
  0x2e5c478: ch = EntryToken

    0x2e5c478: <multiple use>
    0x2e7f7b0: i32 = Register %EFLAGS

        0x2e7fdb0: i64 = TargetFrameIndex<1>

        0x2e7f6b0: i8 = TargetConstant<1>

        0x2e7f5b0: i64 = Register %noreg

        0x2e7f3b0: i32 = TargetConstant<0>

        0x2e83b40: i32 = Register %noreg

        0x2e5c478: <multiple use>
      0x2e7fbb0: i32,ch = MOV32rm 0x2e7fdb0, 0x2e7f6b0, 0x2e7f5b0, 0x2e7f3b0, 0x2e83b40, 0x2e5c478<Mem:LD4[%i]> [ORD=6]

      0x2e801b0: i32 = TargetConstant<10>

    0x2e800b0: i32,i32 = SUB32ri8 0x2e7fbb0, 0x2e801b0 [ORD=6]

  0x2e7f9b0: ch,glue = CopyToReg 0x2e5c478, 0x2e7f7b0, 0x2e800b0:1 [ORD=8]

    0x2e7feb0: ch = BasicBlock<for.body 0x2e79ac0>

      0x2e7f4b0: ch = BasicBlock<for.end 0x2e79c20>

      0x2e7f9b0: <multiple use>
      0x2e7f9b0: <multiple use>
    0x2e7fab0: ch = JG_4 0x2e7f4b0, 0x2e7f9b0, 0x2e7f9b0:1 [ORD=8]

  0x2e7ffb0: ch = JMP_4 0x2e7feb0, 0x2e7fab0 [ORD=8]


********** List Scheduling BB#1 'for.cond' **********
SU(0): 0x2e7ffb0: ch = JMP_4 0x2e7feb0, 0x2e7fab0 [ORD=8] [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
   ch  SU(1): Latency=1

SU(1): 0x2e7fab0: ch = JG_4 0x2e7f4b0, 0x2e7f9b0, 0x2e7f9b0:1 [ORD=8] [ID=1]

    0x2e7f9b0: ch,glue = CopyToReg 0x2e5c478, 0x2e7f7b0, 0x2e800b0:1 [ORD=8] [ID=1]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
   val SU(2): Latency=1 Reg=%EFLAGS
  Successors:
   ch  SU(0): Latency=1

SU(2): 0x2e800b0: i32,i32 = SUB32ri8 0x2e7fbb0, 0x2e801b0 [ORD=6] [ID=2]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
   val SU(3): Latency=1
  Successors:
   val SU(1): Latency=1 Reg=%EFLAGS

SU(3): 0x2e7fbb0: i32,ch = MOV32rm 0x2e7fdb0, 0x2e7f6b0, 0x2e7f5b0, 0x2e7f3b0, 0x2e83b40, 0x2e5c478<Mem:LD4[%i]> [ORD=6] [ID=3]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
   val SU(2): Latency=1


Examining Available:
Height 0: SU(0): 0x2e7ffb0: ch = JMP_4 0x2e7feb0, 0x2e7fab0 [ORD=8] [ID=0]


*** Scheduling [0]: SU(0): 0x2e7ffb0: ch = JMP_4 0x2e7feb0, 0x2e7fab0 [ORD=8] [ID=0]


Examining Available:
Height 1: SU(1): 0x2e7fab0: ch = JG_4 0x2e7f4b0, 0x2e7f9b0, 0x2e7f9b0:1 [ORD=8] [ID=1]

    0x2e7f9b0: ch,glue = CopyToReg 0x2e5c478, 0x2e7f7b0, 0x2e800b0:1 [ORD=8] [ID=1]


*** Scheduling [1]: SU(1): 0x2e7fab0: ch = JG_4 0x2e7f4b0, 0x2e7f9b0, 0x2e7f9b0:1 [ORD=8] [ID=1]

    0x2e7f9b0: ch,glue = CopyToReg 0x2e5c478, 0x2e7f7b0, 0x2e800b0:1 [ORD=8] [ID=1]


Examining Available:
Height 2: SU(2): 0x2e800b0: i32,i32 = SUB32ri8 0x2e7fbb0, 0x2e801b0 [ORD=6] [ID=2]


*** Scheduling [2]: SU(2): 0x2e800b0: i32,i32 = SUB32ri8 0x2e7fbb0, 0x2e801b0 [ORD=6] [ID=2]


Examining Available:
Height 3: SU(3): 0x2e7fbb0: i32,ch = MOV32rm 0x2e7fdb0, 0x2e7f6b0, 0x2e7f5b0, 0x2e7f3b0, 0x2e83b40, 0x2e5c478<Mem:LD4[%i]> [ORD=6] [ID=3]


*** Scheduling [3]: SU(3): 0x2e7fbb0: i32,ch = MOV32rm 0x2e7fdb0, 0x2e7f6b0, 0x2e7f5b0, 0x2e7f3b0, 0x2e83b40, 0x2e5c478<Mem:LD4[%i]> [ORD=6] [ID=3]

*** Final schedule ***
SU(3): 0x2e7fbb0: i32,ch = MOV32rm 0x2e7fdb0, 0x2e7f6b0, 0x2e7f5b0, 0x2e7f3b0, 0x2e83b40, 0x2e5c478<Mem:LD4[%i]> [ORD=6] [ID=3]

SU(2): 0x2e800b0: i32,i32 = SUB32ri8 0x2e7fbb0, 0x2e801b0 [ORD=6] [ID=2]

SU(1): 0x2e7fab0: ch = JG_4 0x2e7f4b0, 0x2e7f9b0, 0x2e7f9b0:1 [ORD=8] [ID=1]

    0x2e7f9b0: ch,glue = CopyToReg 0x2e5c478, 0x2e7f7b0, 0x2e800b0:1 [ORD=8] [ID=1]

SU(0): 0x2e7ffb0: ch = JMP_4 0x2e7feb0, 0x2e7fab0 [ORD=8] [ID=0]


Total amount of phi nodes to update: 0
Initial selection DAG: BB#4 'main:for.end'
SelectionDAG has 6 nodes:
  0x2e7f6b0: i32 = Register %EAX

    0x2e5c478: ch = EntryToken

    0x2e7f6b0: <multiple use>
    0x2e83b40: i32 = Constant<0>

  0x2e7fdb0: ch,glue = CopyToReg 0x2e5c478, 0x2e7f6b0, 0x2e83b40 [ORD=9]

    0x2e7fdb0: <multiple use>
    0x2e7f3b0: i16 = TargetConstant<0>

    0x2e7f6b0: <multiple use>
    0x2e7fdb0: <multiple use>
  0x2e7f5b0: ch = X86ISD::RET_FLAG 0x2e7fdb0, 0x2e7f3b0, 0x2e7f6b0, 0x2e7fdb0:1 [ORD=9]


Optimized lowered selection DAG: BB#4 'main:for.end'
SelectionDAG has 6 nodes:
  0x2e7f6b0: i32 = Register %EAX

    0x2e5c478: ch = EntryToken

    0x2e7f6b0: <multiple use>
    0x2e83b40: i32 = Constant<0>

  0x2e7fdb0: ch,glue = CopyToReg 0x2e5c478, 0x2e7f6b0, 0x2e83b40 [ORD=9]

    0x2e7fdb0: <multiple use>
    0x2e7f3b0: i16 = TargetConstant<0>

    0x2e7f6b0: <multiple use>
    0x2e7fdb0: <multiple use>
  0x2e7f5b0: ch = X86ISD::RET_FLAG 0x2e7fdb0, 0x2e7f3b0, 0x2e7f6b0, 0x2e7fdb0:1 [ORD=9]


Legally typed node: 0x2e7f6b0: i32 = Register %EAX [ID=0]

Legally typed node: 0x2e7f3b0: i16 = TargetConstant<0> [ID=0]

Legally typed node: 0x2e83b40: i32 = Constant<0> [ID=0]

Legally typed node: 0x2e5c478: ch = EntryToken [ID=0]

Legally typed node: 0x2e7fdb0: ch,glue = CopyToReg 0x2e5c478, 0x2e7f6b0, 0x2e83b40 [ORD=9] [ID=0]

Legally typed node: 0x2e7f5b0: ch = X86ISD::RET_FLAG 0x2e7fdb0, 0x2e7f3b0, 0x2e7f6b0, 0x2e7fdb0:1 [ORD=9] [ID=0]

Legally typed node: 0x7fff29e7be60: ch = handlenode 0x2e7f5b0 [ID=0]

Type-legalized selection DAG: BB#4 'main:for.end'
SelectionDAG has 6 nodes:
  0x2e7f6b0: i32 = Register %EAX [ID=-3]

    0x2e5c478: ch = EntryToken [ID=-3]

    0x2e7f6b0: <multiple use>
    0x2e83b40: i32 = Constant<0> [ID=-3]

  0x2e7fdb0: ch,glue = CopyToReg 0x2e5c478, 0x2e7f6b0, 0x2e83b40 [ORD=9] [ID=-3]

    0x2e7fdb0: <multiple use>
    0x2e7f3b0: i16 = TargetConstant<0> [ID=-3]

    0x2e7f6b0: <multiple use>
    0x2e7fdb0: <multiple use>
  0x2e7f5b0: ch = X86ISD::RET_FLAG 0x2e7fdb0, 0x2e7f3b0, 0x2e7f6b0, 0x2e7fdb0:1 [ORD=9] [ID=-3]


Legalized selection DAG: BB#4 'main:for.end'
SelectionDAG has 6 nodes:
  0x2e7f6b0: i32 = Register %EAX [ID=3]

    0x2e5c478: ch = EntryToken [ID=0]

    0x2e7f6b0: <multiple use>
    0x2e83b40: i32 = Constant<0> [ID=1]

  0x2e7fdb0: ch,glue = CopyToReg 0x2e5c478, 0x2e7f6b0, 0x2e83b40 [ORD=9] [ID=4]

    0x2e7fdb0: <multiple use>
    0x2e7f3b0: i16 = TargetConstant<0> [ID=2]

    0x2e7f6b0: <multiple use>
    0x2e7fdb0: <multiple use>
  0x2e7f5b0: ch = X86ISD::RET_FLAG 0x2e7fdb0, 0x2e7f3b0, 0x2e7f6b0, 0x2e7fdb0:1 [ORD=9] [ID=5]


Optimized legalized selection DAG: BB#4 'main:for.end'
SelectionDAG has 6 nodes:
  0x2e7f6b0: i32 = Register %EAX [ID=3]

    0x2e5c478: ch = EntryToken [ID=0]

    0x2e7f6b0: <multiple use>
    0x2e83b40: i32 = Constant<0> [ID=1]

  0x2e7fdb0: ch,glue = CopyToReg 0x2e5c478, 0x2e7f6b0, 0x2e83b40 [ORD=9] [ID=4]

    0x2e7fdb0: <multiple use>
    0x2e7f3b0: i16 = TargetConstant<0> [ID=2]

    0x2e7f6b0: <multiple use>
    0x2e7fdb0: <multiple use>
  0x2e7f5b0: ch = X86ISD::RET_FLAG 0x2e7fdb0, 0x2e7f3b0, 0x2e7f6b0, 0x2e7fdb0:1 [ORD=9] [ID=5]


===== Instruction selection begins: BB#4 'for.end'
Selecting: 0x2e7f5b0: ch = X86ISD::RET_FLAG 0x2e7fdb0, 0x2e7f3b0, 0x2e7f6b0, 0x2e7fdb0:1 [ORD=9] [ID=5]

ISEL: Starting pattern match on root node: 0x2e7f5b0: ch = X86ISD::RET_FLAG 0x2e7fdb0, 0x2e7f3b0, 0x2e7f6b0, 0x2e7fdb0:1 [ORD=9] [ID=5]

  Initial Opcode index to 93235
  Morphed node: 0x2e7f5b0: ch = RET 0x2e7f6b0, 0x2e7fdb0, 0x2e7fdb0:1 [ORD=9]

ISEL: Match complete!
=> 0x2e7f5b0: ch = RET 0x2e7f6b0, 0x2e7fdb0, 0x2e7fdb0:1 [ORD=9]

Selecting: 0x2e7fdb0: ch,glue = CopyToReg 0x2e5c478, 0x2e7f6b0, 0x2e83b40 [ORD=9] [ID=4]

=> 0x2e7fdb0: ch,glue = CopyToReg 0x2e5c478, 0x2e7f6b0, 0x2e83b40 [ORD=9]

Selecting: 0x2e7f6b0: i32 = Register %EAX [ID=3]

=> 0x2e7f6b0: i32 = Register %EAX

Selecting: 0x2e83b40: i32 = Constant<0> [ID=1]

ISEL: Starting pattern match on root node: 0x2e83b40: i32 = Constant<0> [ID=1]

  Initial Opcode index to 82786
  Match failed at index 82790
  Continuing at 82816
  Match failed at index 82818
  Continuing at 82847
  TypeSwitch[i32] from 82850 to 82853
  Morphed node: 0x2e83b40: i32,i32 = MOV32r0

ISEL: Match complete!
=> 0x2e83b40: i32,i32 = MOV32r0

Selecting: 0x2e5c478: ch = EntryToken [ID=0]

=> 0x2e5c478: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: BB#4 'main:for.end'
SelectionDAG has 5 nodes:
  0x2e7f6b0: i32 = Register %EAX

    0x2e5c478: ch = EntryToken

    0x2e7f6b0: <multiple use>
    0x2e83b40: i32,i32 = MOV32r0

  0x2e7fdb0: ch,glue = CopyToReg 0x2e5c478, 0x2e7f6b0, 0x2e83b40 [ORD=9]

    0x2e7f6b0: <multiple use>
    0x2e7fdb0: <multiple use>
    0x2e7fdb0: <multiple use>
  0x2e7f5b0: ch = RET 0x2e7f6b0, 0x2e7fdb0, 0x2e7fdb0:1 [ORD=9]


********** List Scheduling BB#4 'for.end' **********
SU(0): 0x2e7f5b0: ch = RET 0x2e7f6b0, 0x2e7fdb0, 0x2e7fdb0:1 [ORD=9] [ID=0]

    0x2e7fdb0: ch,glue = CopyToReg 0x2e5c478, 0x2e7f6b0, 0x2e83b40 [ORD=9] [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
   val SU(1): Latency=1

SU(1): 0x2e83b40: i32,i32 = MOV32r0 [ID=1]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   val SU(0): Latency=1


Examining Available:
Height 0: SU(0): 0x2e7f5b0: ch = RET 0x2e7f6b0, 0x2e7fdb0, 0x2e7fdb0:1 [ORD=9] [ID=0]

    0x2e7fdb0: ch,glue = CopyToReg 0x2e5c478, 0x2e7f6b0, 0x2e83b40 [ORD=9] [ID=0]


*** Scheduling [0]: SU(0): 0x2e7f5b0: ch = RET 0x2e7f6b0, 0x2e7fdb0, 0x2e7fdb0:1 [ORD=9] [ID=0]

    0x2e7fdb0: ch,glue = CopyToReg 0x2e5c478, 0x2e7f6b0, 0x2e83b40 [ORD=9] [ID=0]


Examining Available:
Height 1: SU(1): 0x2e83b40: i32,i32 = MOV32r0 [ID=1]


*** Scheduling [1]: SU(1): 0x2e83b40: i32,i32 = MOV32r0 [ID=1]

*** Final schedule ***
SU(1): 0x2e83b40: i32,i32 = MOV32r0 [ID=1]

SU(0): 0x2e7f5b0: ch = RET 0x2e7f6b0, 0x2e7fdb0, 0x2e7fdb0:1 [ORD=9] [ID=0]

    0x2e7fdb0: ch,glue = CopyToReg 0x2e5c478, 0x2e7f6b0, 0x2e83b40 [ORD=9] [ID=0]


Total amount of phi nodes to update: 0
Initial selection DAG: BB#2 'main:for.body'
SelectionDAG has 13 nodes:
  0x2e7fdb0: i64 = Constant<0>

    0x2e5c478: ch = EntryToken

    0x2e7f5b0: i64 = FrameIndex<1>

    0x2e7f6b0: i64 = undef

  0x2e83b40: i32,ch = load 0x2e5c478, 0x2e7f5b0, 0x2e7f6b0<LD4[%i]> [ORD=10]

  0x2e801b0: i64 = TargetConstant<0>

  0x2e7f7b0: i32 = Register %EDI

      0x2e83b40: <multiple use>
      0x2e801b0: <multiple use>
    0x2e7f9b0: ch,glue = callseq_start 0x2e83b40:1, 0x2e801b0 [ORD=11]

    0x2e7f7b0: <multiple use>
    0x2e83b40: <multiple use>
  0x2e7ffb0: ch,glue = CopyToReg 0x2e7f9b0, 0x2e7f7b0, 0x2e83b40 [ORD=11]

    0x2e7ffb0: <multiple use>
    0x2e7f3b0: i64 = GlobalAddress<void (i32)* @func> 0 [ORD=11]

    0x2e7f7b0: <multiple use>
    0x2e7fab0: Untyped = RegisterMask

    0x2e7ffb0: <multiple use>
  0x2e800b0: ch,glue = X86ISD::CALL 0x2e7ffb0, 0x2e7f3b0, 0x2e7f7b0, 0x2e7fab0, 0x2e7ffb0:1 [ORD=11]

    0x2e800b0: <multiple use>
    0x2e801b0: <multiple use>
    0x2e801b0: <multiple use>
    0x2e800b0: <multiple use>
  0x2e7fbb0: ch,glue = callseq_end 0x2e800b0, 0x2e801b0, 0x2e801b0, 0x2e800b0:1 [ORD=11]


Optimized lowered selection DAG: BB#2 'main:for.body'
SelectionDAG has 12 nodes:
    0x2e5c478: ch = EntryToken

    0x2e7f5b0: i64 = FrameIndex<1>

    0x2e7f6b0: i64 = undef

  0x2e83b40: i32,ch = load 0x2e5c478, 0x2e7f5b0, 0x2e7f6b0<LD4[%i]> [ORD=10]

  0x2e801b0: i64 = TargetConstant<0>

  0x2e7f7b0: i32 = Register %EDI

      0x2e83b40: <multiple use>
      0x2e801b0: <multiple use>
    0x2e7f9b0: ch,glue = callseq_start 0x2e83b40:1, 0x2e801b0 [ORD=11]

    0x2e7f7b0: <multiple use>
    0x2e83b40: <multiple use>
  0x2e7ffb0: ch,glue = CopyToReg 0x2e7f9b0, 0x2e7f7b0, 0x2e83b40 [ORD=11]

    0x2e7ffb0: <multiple use>
    0x2e7f3b0: i64 = GlobalAddress<void (i32)* @func> 0 [ORD=11]

    0x2e7f7b0: <multiple use>
    0x2e7fab0: Untyped = RegisterMask

    0x2e7ffb0: <multiple use>
  0x2e800b0: ch,glue = X86ISD::CALL 0x2e7ffb0, 0x2e7f3b0, 0x2e7f7b0, 0x2e7fab0, 0x2e7ffb0:1 [ORD=11]

    0x2e800b0: <multiple use>
    0x2e801b0: <multiple use>
    0x2e801b0: <multiple use>
    0x2e800b0: <multiple use>
  0x2e7fbb0: ch,glue = callseq_end 0x2e800b0, 0x2e801b0, 0x2e801b0, 0x2e800b0:1 [ORD=11]


Legally typed node: 0x2e7fab0: Untyped = RegisterMask [ID=0]

Legally typed node: 0x2e7f7b0: i32 = Register %EDI [ID=0]

Legally typed node: 0x2e801b0: i64 = TargetConstant<0> [ID=0]

Legally typed node: 0x2e7f3b0: i64 = GlobalAddress<void (i32)* @func> 0 [ORD=11] [ID=0]

Legally typed node: 0x2e7f6b0: i64 = undef [ID=0]

Legally typed node: 0x2e7f5b0: i64 = FrameIndex<1> [ID=0]

Legally typed node: 0x2e5c478: ch = EntryToken [ID=0]

Legally typed node: 0x2e83b40: i32,ch = load 0x2e5c478, 0x2e7f5b0, 0x2e7f6b0<LD4[%i]> [ORD=10] [ID=0]

Legally typed node: 0x2e7f9b0: ch,glue = callseq_start 0x2e83b40:1, 0x2e801b0 [ORD=11] [ID=0]

Legally typed node: 0x2e7ffb0: ch,glue = CopyToReg 0x2e7f9b0, 0x2e7f7b0, 0x2e83b40 [ORD=11] [ID=0]

Legally typed node: 0x2e800b0: ch,glue = X86ISD::CALL 0x2e7ffb0, 0x2e7f3b0, 0x2e7f7b0, 0x2e7fab0, 0x2e7ffb0:1 [ORD=11] [ID=0]

Legally typed node: 0x2e7fbb0: ch,glue = callseq_end 0x2e800b0, 0x2e801b0, 0x2e801b0, 0x2e800b0:1 [ORD=11] [ID=0]

Legally typed node: 0x7fff29e7be60: ch = handlenode 0x2e7fbb0 [ID=0]

Type-legalized selection DAG: BB#2 'main:for.body'
SelectionDAG has 12 nodes:
    0x2e5c478: ch = EntryToken [ID=-3]

    0x2e7f5b0: i64 = FrameIndex<1> [ID=-3]

    0x2e7f6b0: i64 = undef [ID=-3]

  0x2e83b40: i32,ch = load 0x2e5c478, 0x2e7f5b0, 0x2e7f6b0<LD4[%i]> [ORD=10] [ID=-3]

  0x2e801b0: i64 = TargetConstant<0> [ID=-3]

  0x2e7f7b0: i32 = Register %EDI [ID=-3]

      0x2e83b40: <multiple use>
      0x2e801b0: <multiple use>
    0x2e7f9b0: ch,glue = callseq_start 0x2e83b40:1, 0x2e801b0 [ORD=11] [ID=-3]

    0x2e7f7b0: <multiple use>
    0x2e83b40: <multiple use>
  0x2e7ffb0: ch,glue = CopyToReg 0x2e7f9b0, 0x2e7f7b0, 0x2e83b40 [ORD=11] [ID=-3]

    0x2e7ffb0: <multiple use>
    0x2e7f3b0: i64 = GlobalAddress<void (i32)* @func> 0 [ORD=11] [ID=-3]

    0x2e7f7b0: <multiple use>
    0x2e7fab0: Untyped = RegisterMask [ID=-3]

    0x2e7ffb0: <multiple use>
  0x2e800b0: ch,glue = X86ISD::CALL 0x2e7ffb0, 0x2e7f3b0, 0x2e7f7b0, 0x2e7fab0, 0x2e7ffb0:1 [ORD=11] [ID=-3]

    0x2e800b0: <multiple use>
    0x2e801b0: <multiple use>
    0x2e801b0: <multiple use>
    0x2e800b0: <multiple use>
  0x2e7fbb0: ch,glue = callseq_end 0x2e800b0, 0x2e801b0, 0x2e801b0, 0x2e800b0:1 [ORD=11] [ID=-3]


Legalized selection DAG: BB#2 'main:for.body'
SelectionDAG has 13 nodes:
  0x2e801b0: i64 = TargetConstant<0> [ID=4]

  0x2e7f7b0: i32 = Register %EDI [ID=5]

    0x2e5c478: ch = EntryToken [ID=0]

    0x2e7f5b0: i64 = FrameIndex<1> [ID=1]

    0x2e7f6b0: i64 = undef [ID=2]

  0x2e83b40: i32,ch = load 0x2e5c478, 0x2e7f5b0, 0x2e7f6b0<LD4[%i]> [ORD=10] [ID=7]

      0x2e83b40: <multiple use>
      0x2e801b0: <multiple use>
    0x2e7f9b0: ch,glue = callseq_start 0x2e83b40:1, 0x2e801b0 [ORD=11] [ID=8]

    0x2e7f7b0: <multiple use>
    0x2e83b40: <multiple use>
  0x2e7ffb0: ch,glue = CopyToReg 0x2e7f9b0, 0x2e7f7b0, 0x2e83b40 [ORD=11] [ID=9]

    0x2e7ffb0: <multiple use>
      0x2e7fdb0: i64 = TargetGlobalAddress<void (i32)* @func> 0 [ORD=11]

    0x2e7feb0: i64 = X86ISD::Wrapper 0x2e7fdb0 [ORD=11]

    0x2e7f7b0: <multiple use>
    0x2e7fab0: Untyped = RegisterMask [ID=6]

    0x2e7ffb0: <multiple use>
  0x2e800b0: ch,glue = X86ISD::CALL 0x2e7ffb0, 0x2e7feb0, 0x2e7f7b0, 0x2e7fab0, 0x2e7ffb0:1 [ORD=11] [ID=10]

    0x2e800b0: <multiple use>
    0x2e801b0: <multiple use>
    0x2e801b0: <multiple use>
    0x2e800b0: <multiple use>
  0x2e7fbb0: ch,glue = callseq_end 0x2e800b0, 0x2e801b0, 0x2e801b0, 0x2e800b0:1 [ORD=11] [ID=11]


Optimized legalized selection DAG: BB#2 'main:for.body'
SelectionDAG has 13 nodes:
  0x2e801b0: i64 = TargetConstant<0> [ID=4]

  0x2e7f7b0: i32 = Register %EDI [ID=5]

    0x2e5c478: ch = EntryToken [ID=0]

    0x2e7f5b0: i64 = FrameIndex<1> [ID=1]

    0x2e7f6b0: i64 = undef [ID=2]

  0x2e83b40: i32,ch = load 0x2e5c478, 0x2e7f5b0, 0x2e7f6b0<LD4[%i]> [ORD=10] [ID=7]

      0x2e83b40: <multiple use>
      0x2e801b0: <multiple use>
    0x2e7f9b0: ch,glue = callseq_start 0x2e83b40:1, 0x2e801b0 [ORD=11] [ID=8]

    0x2e7f7b0: <multiple use>
    0x2e83b40: <multiple use>
  0x2e7ffb0: ch,glue = CopyToReg 0x2e7f9b0, 0x2e7f7b0, 0x2e83b40 [ORD=11] [ID=9]

    0x2e7ffb0: <multiple use>
      0x2e7fdb0: i64 = TargetGlobalAddress<void (i32)* @func> 0 [ORD=11]

    0x2e7feb0: i64 = X86ISD::Wrapper 0x2e7fdb0 [ORD=11]

    0x2e7f7b0: <multiple use>
    0x2e7fab0: Untyped = RegisterMask [ID=6]

    0x2e7ffb0: <multiple use>
  0x2e800b0: ch,glue = X86ISD::CALL 0x2e7ffb0, 0x2e7feb0, 0x2e7f7b0, 0x2e7fab0, 0x2e7ffb0:1 [ORD=11] [ID=10]

    0x2e800b0: <multiple use>
    0x2e801b0: <multiple use>
    0x2e801b0: <multiple use>
    0x2e800b0: <multiple use>
  0x2e7fbb0: ch,glue = callseq_end 0x2e800b0, 0x2e801b0, 0x2e801b0, 0x2e800b0:1 [ORD=11] [ID=11]


===== Instruction selection begins: BB#2 'for.body'
Selecting: 0x2e7fbb0: ch,glue = callseq_end 0x2e800b0, 0x2e801b0, 0x2e801b0, 0x2e800b0:1 [ORD=11] [ID=12]

ISEL: Starting pattern match on root node: 0x2e7fbb0: ch,glue = callseq_end 0x2e800b0, 0x2e801b0, 0x2e801b0, 0x2e800b0:1 [ORD=11] [ID=12]

  Initial Opcode index to 92907
  Skipped scope entry (due to false predicate) at index 92925, continuing at 92937
  Morphed node: 0x2e7fbb0: i64,ch,glue = ADJCALLSTACKUP64 0x2e801b0, 0x2e801b0, 0x2e800b0, 0x2e800b0:1 [ORD=11]

ISEL: Match complete!
=> 0x2e7fbb0: i64,ch,glue = ADJCALLSTACKUP64 0x2e801b0, 0x2e801b0, 0x2e800b0, 0x2e800b0:1 [ORD=11]

Selecting: 0x2e800b0: ch,glue = X86ISD::CALL 0x2e7ffb0, 0x2e7feb0, 0x2e7f7b0, 0x2e7fab0, 0x2e7ffb0:1 [ORD=11] [ID=11]

ISEL: Starting pattern match on root node: 0x2e800b0: ch,glue = X86ISD::CALL 0x2e7ffb0, 0x2e7feb0, 0x2e7f7b0, 0x2e7fab0, 0x2e7ffb0:1 [ORD=11] [ID=11]

  Initial Opcode index to 69884
  Match failed at index 69890
  Continuing at 69951
  Match failed at index 69957
  Continuing at 70031
  Match failed at index 70032
  Continuing at 70044
  Morphed node: 0x2e800b0: ch,glue = CALL64r 0x2e7feb0, 0x2e7f7b0, 0x2e7fab0, 0x2e7ffb0, 0x2e7ffb0:1 [ORD=11]

ISEL: Match complete!
=> 0x2e800b0: ch,glue = CALL64r 0x2e7feb0, 0x2e7f7b0, 0x2e7fab0, 0x2e7ffb0, 0x2e7ffb0:1 [ORD=11]

Selecting: 0x2e7ffb0: ch,glue = CopyToReg 0x2e7f9b0, 0x2e7f7b0, 0x2e83b40 [ORD=11] [ID=10]

=> 0x2e7ffb0: ch,glue = CopyToReg 0x2e7f9b0, 0x2e7f7b0, 0x2e83b40 [ORD=11]

Selecting: 0x2e7f9b0: ch,glue = callseq_start 0x2e83b40:1, 0x2e801b0 [ORD=11] [ID=9]

ISEL: Starting pattern match on root node: 0x2e7f9b0: ch,glue = callseq_start 0x2e83b40:1, 0x2e801b0 [ORD=11] [ID=9]

  Initial Opcode index to 95380
  Skipped scope entry (due to false predicate) at index 95390, continuing at 95401
  Morphed node: 0x2e7f9b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e801b0, 0x2e83b40:1 [ORD=11]

ISEL: Match complete!
=> 0x2e7f9b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e801b0, 0x2e83b40:1 [ORD=11]

Selecting: 0x2e7feb0: i64 = X86ISD::Wrapper 0x2e7fdb0 [ORD=11] [ID=8]

ISEL: Starting pattern match on root node: 0x2e7feb0: i64 = X86ISD::Wrapper 0x2e7fdb0 [ORD=11] [ID=8]

  Initial Opcode index to 94787
  Match failed at index 94792
  Continuing at 94819
  OpcodeSwitch from 94824 to 94938
  TypeSwitch[i64] from 94939 to 94952
  Morphed node: 0x2e7feb0: i64 = MOV64ri 0x2e7fdb0 [ORD=11]

ISEL: Match complete!
=> 0x2e7feb0: i64 = MOV64ri 0x2e7fdb0 [ORD=11]

Selecting: 0x2e83b40: i32,ch = load 0x2e5c478, 0x2e7f5b0, 0x2e7f6b0<LD4[%i]> [ORD=10] [ID=7]

ISEL: Starting pattern match on root node: 0x2e83b40: i32,ch = load 0x2e5c478, 0x2e7f5b0, 0x2e7f6b0<LD4[%i]> [ORD=10] [ID=7]

  Initial Opcode index to 83164
  Match failed at index 83173
  Continuing at 83191
  Match failed at index 83194
  Continuing at 83212
MatchAddress: X86ISelAddressMode 0x7fff29e7b9b0
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
  Morphed node: 0x2e83b40: i32,ch = MOV32rm 0x2e7f4b0, 0x2e7f8b0, 0x2e7f3b0, 0x2e7fcb0, 0x2e83c40, 0x2e5c478<Mem:LD4[%i]> [ORD=10]

ISEL: Match complete!
=> 0x2e83b40: i32,ch = MOV32rm 0x2e7f4b0, 0x2e7f8b0, 0x2e7f3b0, 0x2e7fcb0, 0x2e83c40, 0x2e5c478<Mem:LD4[%i]> [ORD=10]

Selecting: 0x2e7fdb0: i64 = TargetGlobalAddress<void (i32)* @func> 0 [ORD=11] [ID=6]

=> 0x2e7fdb0: i64 = TargetGlobalAddress<void (i32)* @func> 0 [ORD=11]

Selecting: 0x2e7fab0: Untyped = RegisterMask [ID=5]

=> 0x2e7fab0: Untyped = RegisterMask

Selecting: 0x2e7f7b0: i32 = Register %EDI [ID=4]

=> 0x2e7f7b0: i32 = Register %EDI

Selecting: 0x2e801b0: i64 = TargetConstant<0> [ID=3]

=> 0x2e801b0: i64 = TargetConstant<0>

Selecting: 0x2e5c478: ch = EntryToken [ID=0]

=> 0x2e5c478: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: BB#2 'main:for.body'
SelectionDAG has 16 nodes:
  0x2e801b0: i64 = TargetConstant<0>

  0x2e7f7b0: i32 = Register %EDI

    0x2e7f4b0: i64 = TargetFrameIndex<1>

    0x2e7f8b0: i8 = TargetConstant<1>

    0x2e7f3b0: i64 = Register %noreg

    0x2e7fcb0: i32 = TargetConstant<0>

    0x2e83c40: i32 = Register %noreg

    0x2e5c478: ch = EntryToken

  0x2e83b40: i32,ch = MOV32rm 0x2e7f4b0, 0x2e7f8b0, 0x2e7f3b0, 0x2e7fcb0, 0x2e83c40, 0x2e5c478<Mem:LD4[%i]> [ORD=10]

      0x2e801b0: <multiple use>
      0x2e83b40: <multiple use>
    0x2e7f9b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e801b0, 0x2e83b40:1 [ORD=11]

    0x2e7f7b0: <multiple use>
    0x2e83b40: <multiple use>
  0x2e7ffb0: ch,glue = CopyToReg 0x2e7f9b0:1, 0x2e7f7b0, 0x2e83b40 [ORD=11]

      0x2e7fdb0: i64 = TargetGlobalAddress<void (i32)* @func> 0 [ORD=11]

    0x2e7feb0: i64 = MOV64ri 0x2e7fdb0 [ORD=11]

    0x2e7f7b0: <multiple use>
    0x2e7fab0: Untyped = RegisterMask

    0x2e7ffb0: <multiple use>
    0x2e7ffb0: <multiple use>
  0x2e800b0: ch,glue = CALL64r 0x2e7feb0, 0x2e7f7b0, 0x2e7fab0, 0x2e7ffb0, 0x2e7ffb0:1 [ORD=11]

    0x2e801b0: <multiple use>
    0x2e801b0: <multiple use>
    0x2e800b0: <multiple use>
    0x2e800b0: <multiple use>
  0x2e7fbb0: i64,ch,glue = ADJCALLSTACKUP64 0x2e801b0, 0x2e801b0, 0x2e800b0, 0x2e800b0:1 [ORD=11]


********** List Scheduling BB#2 'for.body' **********
SU(0): 0x2e7fbb0: i64,ch,glue = ADJCALLSTACKUP64 0x2e801b0, 0x2e801b0, 0x2e800b0, 0x2e800b0:1 [ORD=11] [ID=0]

    0x2e7ffb0: ch,glue = CopyToReg 0x2e7f9b0:1, 0x2e7f7b0, 0x2e83b40 [ORD=11] [ID=0]

    0x2e800b0: ch,glue = CALL64r 0x2e7feb0, 0x2e7f7b0, 0x2e7fab0, 0x2e7ffb0, 0x2e7ffb0:1 [ORD=11] [ID=0]

  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 0
  Predecessors:
   val SU(3): Latency=1
   ch  SU(2): Latency=1
   val SU(1): Latency=1

SU(1): 0x2e83b40: i32,ch = MOV32rm 0x2e7f4b0, 0x2e7f8b0, 0x2e7f3b0, 0x2e7fcb0, 0x2e83c40, 0x2e5c478<Mem:LD4[%i]> [ORD=10] [ID=1]

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
   val SU(0): Latency=1
   ch  SU(2): Latency=1

SU(2): 0x2e7f9b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e801b0, 0x2e83b40:1 [ORD=11] [ID=2]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
   ch  SU(1): Latency=1
  Successors:
   ch  SU(0): Latency=1

SU(3): 0x2e7feb0: i64 = MOV64ri 0x2e7fdb0 [ORD=11] [ID=3]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   val SU(0): Latency=1


Examining Available:
Height 0: SU(0): 0x2e7fbb0: i64,ch,glue = ADJCALLSTACKUP64 0x2e801b0, 0x2e801b0, 0x2e800b0, 0x2e800b0:1 [ORD=11] [ID=0]

    0x2e7ffb0: ch,glue = CopyToReg 0x2e7f9b0:1, 0x2e7f7b0, 0x2e83b40 [ORD=11] [ID=0]

    0x2e800b0: ch,glue = CALL64r 0x2e7feb0, 0x2e7f7b0, 0x2e7fab0, 0x2e7ffb0, 0x2e7ffb0:1 [ORD=11] [ID=0]


*** Scheduling [0]: SU(0): 0x2e7fbb0: i64,ch,glue = ADJCALLSTACKUP64 0x2e801b0, 0x2e801b0, 0x2e800b0, 0x2e800b0:1 [ORD=11] [ID=0]

    0x2e7ffb0: ch,glue = CopyToReg 0x2e7f9b0:1, 0x2e7f7b0, 0x2e83b40 [ORD=11] [ID=0]

    0x2e800b0: ch,glue = CALL64r 0x2e7feb0, 0x2e7f7b0, 0x2e7fab0, 0x2e7ffb0, 0x2e7ffb0:1 [ORD=11] [ID=0]


Examining Available:
Height 1: SU(3): 0x2e7feb0: i64 = MOV64ri 0x2e7fdb0 [ORD=11] [ID=3]

Height 1: SU(2): 0x2e7f9b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e801b0, 0x2e83b40:1 [ORD=11] [ID=2]


*** Scheduling [1]: SU(3): 0x2e7feb0: i64 = MOV64ri 0x2e7fdb0 [ORD=11] [ID=3]


Examining Available:
Height 1: SU(2): 0x2e7f9b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e801b0, 0x2e83b40:1 [ORD=11] [ID=2]


*** Scheduling [2]: SU(2): 0x2e7f9b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e801b0, 0x2e83b40:1 [ORD=11] [ID=2]


Examining Available:
Height 3: SU(1): 0x2e83b40: i32,ch = MOV32rm 0x2e7f4b0, 0x2e7f8b0, 0x2e7f3b0, 0x2e7fcb0, 0x2e83c40, 0x2e5c478<Mem:LD4[%i]> [ORD=10] [ID=1]


*** Scheduling [3]: SU(1): 0x2e83b40: i32,ch = MOV32rm 0x2e7f4b0, 0x2e7f8b0, 0x2e7f3b0, 0x2e7fcb0, 0x2e83c40, 0x2e5c478<Mem:LD4[%i]> [ORD=10] [ID=1]

*** Final schedule ***
SU(1): 0x2e83b40: i32,ch = MOV32rm 0x2e7f4b0, 0x2e7f8b0, 0x2e7f3b0, 0x2e7fcb0, 0x2e83c40, 0x2e5c478<Mem:LD4[%i]> [ORD=10] [ID=1]

SU(2): 0x2e7f9b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e801b0, 0x2e83b40:1 [ORD=11] [ID=2]

SU(3): 0x2e7feb0: i64 = MOV64ri 0x2e7fdb0 [ORD=11] [ID=3]

SU(0): 0x2e7fbb0: i64,ch,glue = ADJCALLSTACKUP64 0x2e801b0, 0x2e801b0, 0x2e800b0, 0x2e800b0:1 [ORD=11] [ID=0]

    0x2e7ffb0: ch,glue = CopyToReg 0x2e7f9b0:1, 0x2e7f7b0, 0x2e83b40 [ORD=11] [ID=0]

    0x2e800b0: ch,glue = CALL64r 0x2e7feb0, 0x2e7f7b0, 0x2e7fab0, 0x2e7ffb0, 0x2e7ffb0:1 [ORD=11] [ID=0]


Total amount of phi nodes to update: 0
Initial selection DAG: BB#3 'main:for.inc'
SelectionDAG has 10 nodes:
  0x2e83c40: i64 = FrameIndex<1>

  0x2e7fcb0: i64 = Constant<0>

  0x2e7f8b0: i64 = undef

    0x2e5c478: ch = EntryToken

    0x2e83c40: <multiple use>
    0x2e7f8b0: <multiple use>
  0x2e7f4b0: i32,ch = load 0x2e5c478, 0x2e83c40, 0x2e7f8b0<LD4[%i]> [ORD=13]

      0x2e7f4b0: <multiple use>
        0x2e7f4b0: <multiple use>
        0x2e7f3b0: i32 = Constant<1>

      0x2e7fbb0: i32 = add 0x2e7f4b0, 0x2e7f3b0 [ORD=14]

      0x2e83c40: <multiple use>
      0x2e7f8b0: <multiple use>
    0x2e800b0: ch = store 0x2e7f4b0:1, 0x2e7fbb0, 0x2e83c40, 0x2e7f8b0<ST4[%i]> [ORD=15]

    0x2e7ffb0: ch = BasicBlock<for.cond 0x2e79a10>

  0x2e7f9b0: ch = br 0x2e800b0, 0x2e7ffb0 [ORD=16]


Optimized lowered selection DAG: BB#3 'main:for.inc'
SelectionDAG has 9 nodes:
  0x2e83c40: i64 = FrameIndex<1>

  0x2e7f8b0: i64 = undef

    0x2e5c478: ch = EntryToken

    0x2e83c40: <multiple use>
    0x2e7f8b0: <multiple use>
  0x2e7f4b0: i32,ch = load 0x2e5c478, 0x2e83c40, 0x2e7f8b0<LD4[%i]> [ORD=13]

      0x2e7f4b0: <multiple use>
        0x2e7f4b0: <multiple use>
        0x2e7f3b0: i32 = Constant<1>

      0x2e7fbb0: i32 = add 0x2e7f4b0, 0x2e7f3b0 [ORD=14]

      0x2e83c40: <multiple use>
      0x2e7f8b0: <multiple use>
    0x2e800b0: ch = store 0x2e7f4b0:1, 0x2e7fbb0, 0x2e83c40, 0x2e7f8b0<ST4[%i]> [ORD=15]

    0x2e7ffb0: ch = BasicBlock<for.cond 0x2e79a10>

  0x2e7f9b0: ch = br 0x2e800b0, 0x2e7ffb0 [ORD=16]


Legally typed node: 0x2e7ffb0: ch = BasicBlock<for.cond 0x2e79a10> [ID=0]

Legally typed node: 0x2e7f3b0: i32 = Constant<1> [ID=0]

Legally typed node: 0x2e7f8b0: i64 = undef [ID=0]

Legally typed node: 0x2e83c40: i64 = FrameIndex<1> [ID=0]

Legally typed node: 0x2e5c478: ch = EntryToken [ID=0]

Legally typed node: 0x2e7f4b0: i32,ch = load 0x2e5c478, 0x2e83c40, 0x2e7f8b0<LD4[%i]> [ORD=13] [ID=0]

Legally typed node: 0x2e7fbb0: i32 = add 0x2e7f4b0, 0x2e7f3b0 [ORD=14] [ID=0]

Legally typed node: 0x2e800b0: ch = store 0x2e7f4b0:1, 0x2e7fbb0, 0x2e83c40, 0x2e7f8b0<ST4[%i]> [ORD=15] [ID=0]

Legally typed node: 0x2e7f9b0: ch = br 0x2e800b0, 0x2e7ffb0 [ORD=16] [ID=0]

Legally typed node: 0x7fff29e7be60: ch = handlenode 0x2e7f9b0 [ID=0]

Type-legalized selection DAG: BB#3 'main:for.inc'
SelectionDAG has 9 nodes:
  0x2e83c40: i64 = FrameIndex<1> [ID=-3]

  0x2e7f8b0: i64 = undef [ID=-3]

    0x2e5c478: ch = EntryToken [ID=-3]

    0x2e83c40: <multiple use>
    0x2e7f8b0: <multiple use>
  0x2e7f4b0: i32,ch = load 0x2e5c478, 0x2e83c40, 0x2e7f8b0<LD4[%i]> [ORD=13] [ID=-3]

      0x2e7f4b0: <multiple use>
        0x2e7f4b0: <multiple use>
        0x2e7f3b0: i32 = Constant<1> [ID=-3]

      0x2e7fbb0: i32 = add 0x2e7f4b0, 0x2e7f3b0 [ORD=14] [ID=-3]

      0x2e83c40: <multiple use>
      0x2e7f8b0: <multiple use>
    0x2e800b0: ch = store 0x2e7f4b0:1, 0x2e7fbb0, 0x2e83c40, 0x2e7f8b0<ST4[%i]> [ORD=15] [ID=-3]

    0x2e7ffb0: ch = BasicBlock<for.cond 0x2e79a10> [ID=-3]

  0x2e7f9b0: ch = br 0x2e800b0, 0x2e7ffb0 [ORD=16] [ID=-3]


Legalized selection DAG: BB#3 'main:for.inc'
SelectionDAG has 9 nodes:
  0x2e83c40: i64 = FrameIndex<1> [ID=1]

  0x2e7f8b0: i64 = undef [ID=2]

    0x2e5c478: ch = EntryToken [ID=0]

    0x2e83c40: <multiple use>
    0x2e7f8b0: <multiple use>
  0x2e7f4b0: i32,ch = load 0x2e5c478, 0x2e83c40, 0x2e7f8b0<LD4[%i]> [ORD=13] [ID=5]

      0x2e7f4b0: <multiple use>
        0x2e7f4b0: <multiple use>
        0x2e7f3b0: i32 = Constant<1> [ID=3]

      0x2e7fbb0: i32 = add 0x2e7f4b0, 0x2e7f3b0 [ORD=14] [ID=6]

      0x2e83c40: <multiple use>
      0x2e7f8b0: <multiple use>
    0x2e800b0: ch = store 0x2e7f4b0:1, 0x2e7fbb0, 0x2e83c40, 0x2e7f8b0<ST4[%i]> [ORD=15] [ID=7]

    0x2e7ffb0: ch = BasicBlock<for.cond 0x2e79a10> [ID=4]

  0x2e7f9b0: ch = br 0x2e800b0, 0x2e7ffb0 [ORD=16] [ID=8]


Optimized legalized selection DAG: BB#3 'main:for.inc'
SelectionDAG has 9 nodes:
  0x2e83c40: i64 = FrameIndex<1> [ID=1]

  0x2e7f8b0: i64 = undef [ID=2]

    0x2e5c478: ch = EntryToken [ID=0]

    0x2e83c40: <multiple use>
    0x2e7f8b0: <multiple use>
  0x2e7f4b0: i32,ch = load 0x2e5c478, 0x2e83c40, 0x2e7f8b0<LD4[%i]> [ORD=13] [ID=5]

      0x2e7f4b0: <multiple use>
        0x2e7f4b0: <multiple use>
        0x2e7f3b0: i32 = Constant<1> [ID=3]

      0x2e7fbb0: i32 = add 0x2e7f4b0, 0x2e7f3b0 [ORD=14] [ID=6]

      0x2e83c40: <multiple use>
      0x2e7f8b0: <multiple use>
    0x2e800b0: ch = store 0x2e7f4b0:1, 0x2e7fbb0, 0x2e83c40, 0x2e7f8b0<ST4[%i]> [ORD=15] [ID=7]

    0x2e7ffb0: ch = BasicBlock<for.cond 0x2e79a10> [ID=4]

  0x2e7f9b0: ch = br 0x2e800b0, 0x2e7ffb0 [ORD=16] [ID=8]


===== Instruction selection begins: BB#3 'for.inc'
Selecting: 0x2e7f9b0: ch = br 0x2e800b0, 0x2e7ffb0 [ORD=16] [ID=8]

ISEL: Starting pattern match on root node: 0x2e7f9b0: ch = br 0x2e800b0, 0x2e7ffb0 [ORD=16] [ID=8]

  Initial Opcode index to 95705
  Morphed node: 0x2e7f9b0: ch = JMP_4 0x2e7ffb0, 0x2e800b0 [ORD=16]

ISEL: Match complete!
=> 0x2e7f9b0: ch = JMP_4 0x2e7ffb0, 0x2e800b0 [ORD=16]

Selecting: 0x2e800b0: ch = store 0x2e7f4b0:1, 0x2e7fbb0, 0x2e83c40, 0x2e7f8b0<ST4[%i]> [ORD=15] [ID=7]

ISEL: Starting pattern match on root node: 0x2e800b0: ch = store 0x2e7f4b0:1, 0x2e7fbb0, 0x2e83c40, 0x2e7f8b0<ST4[%i]> [ORD=15] [ID=7]

  Initial Opcode index to 5
  Skipped scope entry (due to false predicate) at index 13, continuing at 58
  Skipped scope entry (due to false predicate) at index 59, continuing at 104
  Skipped scope entry (due to false predicate) at index 105, continuing at 188
  Skipped scope entry (due to false predicate) at index 189, continuing at 212
  Skipped scope entry (due to false predicate) at index 213, continuing at 236
  Skipped scope entry (due to false predicate) at index 237, continuing at 260
  Match failed at index 264
  Continuing at 284
  Match failed at index 285
  Continuing at 308
  Continuing at 309
  OpcodeSwitch from 313 to 3657
  Match failed at index 3681
  Continuing at 3709
  Match failed at index 3718
  Continuing at 3748
  Match failed at index 3766
  Continuing at 3787
  Match failed at index 3796
  Continuing at 3824
  Match failed at index 3833
  Continuing at 3863
MatchAddress: X86ISelAddressMode 0x7fff29e7b9b0
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
  Morphed node: 0x2e800b0: i32,ch = INC64_32m 0x2e7feb0, 0x2e83b40, 0x2e7fcb0, 0x2e7fdb0, 0x2e7fab0, 0x2e5c478<Mem:ST4[%i] LD4[%i]> [ORD=15]

ISEL: Match complete!
=> 0x2e800b0: i32,ch = INC64_32m 0x2e7feb0, 0x2e83b40, 0x2e7fcb0, 0x2e7fdb0, 0x2e7fab0, 0x2e5c478<Mem:ST4[%i] LD4[%i]> [ORD=15]

Selecting: 0x2e7ffb0: ch = BasicBlock<for.cond 0x2e79a10> [ID=4]

=> 0x2e7ffb0: ch = BasicBlock<for.cond 0x2e79a10>

Selecting: 0x2e5c478: ch = EntryToken [ID=0]

=> 0x2e5c478: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: BB#3 'main:for.inc'
SelectionDAG has 9 nodes:
    0x2e7ffb0: ch = BasicBlock<for.cond 0x2e79a10>

      0x2e7feb0: i64 = TargetFrameIndex<1>

      0x2e83b40: i8 = TargetConstant<1>

      0x2e7fcb0: i64 = Register %noreg

      0x2e7fdb0: i32 = TargetConstant<0>

      0x2e7fab0: i32 = Register %noreg

      0x2e5c478: ch = EntryToken

    0x2e800b0: i32,ch = INC64_32m 0x2e7feb0, 0x2e83b40, 0x2e7fcb0, 0x2e7fdb0, 0x2e7fab0, 0x2e5c478<Mem:ST4[%i] LD4[%i]> [ORD=15]

  0x2e7f9b0: ch = JMP_4 0x2e7ffb0, 0x2e800b0:1 [ORD=16]


********** List Scheduling BB#3 'for.inc' **********
SU(0): 0x2e7f9b0: ch = JMP_4 0x2e7ffb0, 0x2e800b0:1 [ORD=16] [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
   ch  SU(1): Latency=1

SU(1): 0x2e800b0: i32,ch = INC64_32m 0x2e7feb0, 0x2e83b40, 0x2e7fcb0, 0x2e7fdb0, 0x2e7fab0, 0x2e5c478<Mem:ST4[%i] LD4[%i]> [ORD=15] [ID=1]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(0): Latency=1


Examining Available:
Height 0: SU(0): 0x2e7f9b0: ch = JMP_4 0x2e7ffb0, 0x2e800b0:1 [ORD=16] [ID=0]


*** Scheduling [0]: SU(0): 0x2e7f9b0: ch = JMP_4 0x2e7ffb0, 0x2e800b0:1 [ORD=16] [ID=0]


Examining Available:
Height 1: SU(1): 0x2e800b0: i32,ch = INC64_32m 0x2e7feb0, 0x2e83b40, 0x2e7fcb0, 0x2e7fdb0, 0x2e7fab0, 0x2e5c478<Mem:ST4[%i] LD4[%i]> [ORD=15] [ID=1]


*** Scheduling [1]: SU(1): 0x2e800b0: i32,ch = INC64_32m 0x2e7feb0, 0x2e83b40, 0x2e7fcb0, 0x2e7fdb0, 0x2e7fab0, 0x2e5c478<Mem:ST4[%i] LD4[%i]> [ORD=15] [ID=1]

*** Final schedule ***
SU(1): 0x2e800b0: i32,ch = INC64_32m 0x2e7feb0, 0x2e83b40, 0x2e7fcb0, 0x2e7fdb0, 0x2e7fab0, 0x2e5c478<Mem:ST4[%i] LD4[%i]> [ORD=15] [ID=1]

SU(0): 0x2e7f9b0: ch = JMP_4 0x2e7ffb0, 0x2e800b0:1 [ORD=16] [ID=0]


Total amount of phi nodes to update: 0

*** Tail-duplicating BB#3

Merging into block: BB#2: derived from LLVM BB %for.body
    Predecessors according to CFG: BB#1
	%vreg3<def> = MOV32rm <fi#1>, 1, %noreg, 0, %noreg; mem:LD4[%i] GR32:%vreg3
	ADJCALLSTACKDOWN64 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	%vreg4<def> = MOV64ri <ga:@func>; GR64:%vreg4
	%EDI<def> = COPY %vreg3; GR32:%vreg3
	CALL64r %vreg4<kill>, <regmask>, %RSP<imp-use>, %EDI<imp-use>, %RSP<imp-def>; GR64:%vreg4
	ADJCALLSTACKUP64 0, 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
    Successors according to CFG: BB#3
From MBB: BB#3: derived from LLVM BB %for.inc
    Predecessors according to CFG: BB#2
	INC64_32m <fi#1>, 1, %noreg, 0, %noreg, %EFLAGS<imp-def,dead>; mem:ST4[%i] LD4[%i]
	JMP_4 <BB#1>
    Successors according to CFG: BB#1

Removing MBB: BB#3: derived from LLVM BB %for.inc
# Machine code for function main: SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]

0B	BB#0: derived from LLVM BB %entry
16B		MOV32mi <fi#0>, 1, %noreg, 0, %noreg, 0; mem:ST4[%retval]
32B		MOV32mi <fi#1>, 1, %noreg, 0, %noreg, 0; mem:ST4[%i]
	    Successors according to CFG: BB#1

48B	BB#1: derived from LLVM BB %for.cond
	    Predecessors according to CFG: BB#0 BB#2
64B		%vreg0<def> = MOV32rm <fi#1>, 1, %noreg, 0, %noreg; mem:LD4[%i] GR32:%vreg0
80B		%vreg1<def,tied1> = SUB32ri8 %vreg0<tied0>, 10, %EFLAGS<imp-def>; GR32:%vreg1,%vreg0
96B		JG_4 <BB#4>, %EFLAGS<imp-use>
112B		JMP_4 <BB#2>
	    Successors according to CFG: BB#2(124) BB#4(4)

128B	BB#2: derived from LLVM BB %for.body
	    Predecessors according to CFG: BB#1
144B		%vreg3<def> = MOV32rm <fi#1>, 1, %noreg, 0, %noreg; mem:LD4[%i] GR32:%vreg3
160B		ADJCALLSTACKDOWN64 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
176B		%vreg4<def> = MOV64ri <ga:@func>; GR64:%vreg4
192B		%EDI<def> = COPY %vreg3; GR32:%vreg3
208B		CALL64r %vreg4<kill>, <regmask>, %RSP<imp-use>, %EDI<imp-use>, %RSP<imp-def>; GR64:%vreg4
224B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
240B		INC64_32m <fi#1>, 1, %noreg, 0, %noreg, %EFLAGS<imp-def,dead>; mem:ST4[%i] LD4[%i]
256B		JMP_4 <BB#1>
	    Successors according to CFG: BB#1

272B	BB#4: derived from LLVM BB %for.end
	    Predecessors according to CFG: BB#1
288B		%vreg2<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg2
304B		%EAX<def> = COPY %vreg2; GR32:%vreg2
320B		RET %EAX

# End machine code for function main.

********** Stack Coloring **********
********** Function: main
Found 0 markers and 2 slots
Slot structure:
Slot #0 - 4 bytes.
Slot #1 - 4 bytes.
Total Stack size: 8 bytes

Will not try to merge slots.
Removed 0 markers.
******** Pre-regalloc Machine LICM: main ********
Entering: for.cond
Entering: for.body
Hoisting %vreg4<def> = MOV64ri <ga:@func>; GR64:%vreg4
 to MachineBasicBlock entry from MachineBasicBlock for.body
Exiting: for.body
Entering: entry
Entering: for.cond
Entering: for.end
Exiting: for.end
Entering: for.body
Exiting: for.body
Exiting: for.cond
Exiting: entry
******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: main
Replacing: CMP32ri8 %vreg0, 10, %EFLAGS<imp-def>; GR32:%vreg0
     With: CMP32mi8 <fi#1>, 1, %noreg, 0, %noreg, 10, %EFLAGS<imp-def>; mem:LD4[%i]
********** PROCESS IMPLICIT DEFS **********
********** Function: main
********** REWRITING TWO-ADDR INSTRS **********
********** Function: main
# Machine code for function main: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]

0B	BB#0: derived from LLVM BB %entry
16B		MOV32mi <fi#0>, 1, %noreg, 0, %noreg, 0; mem:ST4[%retval]
32B		MOV32mi <fi#1>, 1, %noreg, 0, %noreg, 0; mem:ST4[%i]
48B		%vreg4<def> = MOV64ri <ga:@func>; GR64:%vreg4
	    Successors according to CFG: BB#1

64B	BB#1: derived from LLVM BB %for.cond
	    Predecessors according to CFG: BB#0 BB#2
80B		CMP32mi8 <fi#1>, 1, %noreg, 0, %noreg, 10, %EFLAGS<imp-def>; mem:LD4[%i]
96B		JG_4 <BB#3>, %EFLAGS<imp-use,kill>
112B		JMP_4 <BB#2>
	    Successors according to CFG: BB#2(124) BB#3(4)

128B	BB#2: derived from LLVM BB %for.body
	    Predecessors according to CFG: BB#1
144B		%vreg3<def> = MOV32rm <fi#1>, 1, %noreg, 0, %noreg; mem:LD4[%i] GR32:%vreg3
160B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
176B		%EDI<def> = COPY %vreg3<kill>; GR32:%vreg3
192B		CALL64r %vreg4, <regmask>, %RSP<imp-use>, %EDI<imp-use,kill>, %RSP<imp-def>; GR64:%vreg4
208B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
224B		INC64_32m <fi#1>, 1, %noreg, 0, %noreg, %EFLAGS<imp-def,dead>; mem:ST4[%i] LD4[%i]
240B		JMP_4 <BB#1>
	    Successors according to CFG: BB#1

256B	BB#3: derived from LLVM BB %for.end
	    Predecessors according to CFG: BB#1
272B		%vreg2<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg2
288B		%EAX<def> = COPY %vreg2<kill>; GR32:%vreg2
304B		RET %EAX<kill>

# End machine code for function main.

Computing live-in reg-units in ABI blocks.
Created 0 new intervals.
********** INTERVALS **********
%vreg2 [272r,288r:0)  0@272r
%vreg3 [144r,176r:0)  0@144r
%vreg4 [48r,256B:0)  0@48r
RegMasks: 192r
********** MACHINEINSTRS **********
# Machine code for function main: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]

0B	BB#0: derived from LLVM BB %entry
16B		MOV32mi <fi#0>, 1, %noreg, 0, %noreg, 0; mem:ST4[%retval]
32B		MOV32mi <fi#1>, 1, %noreg, 0, %noreg, 0; mem:ST4[%i]
48B		%vreg4<def> = MOV64ri <ga:@func>; GR64:%vreg4
	    Successors according to CFG: BB#1

64B	BB#1: derived from LLVM BB %for.cond
	    Predecessors according to CFG: BB#0 BB#2
80B		CMP32mi8 <fi#1>, 1, %noreg, 0, %noreg, 10, %EFLAGS<imp-def>; mem:LD4[%i]
96B		JG_4 <BB#3>, %EFLAGS<imp-use,kill>
112B		JMP_4 <BB#2>
	    Successors according to CFG: BB#2(124) BB#3(4)

128B	BB#2: derived from LLVM BB %for.body
	    Predecessors according to CFG: BB#1
144B		%vreg3<def> = MOV32rm <fi#1>, 1, %noreg, 0, %noreg; mem:LD4[%i] GR32:%vreg3
160B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
176B		%EDI<def> = COPY %vreg3; GR32:%vreg3
192B		CALL64r %vreg4, <regmask>, %RSP<imp-use>, %EDI<imp-use,kill>, %RSP<imp-def>; GR64:%vreg4
208B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
224B		INC64_32m <fi#1>, 1, %noreg, 0, %noreg, %EFLAGS<imp-def,dead>; mem:ST4[%i] LD4[%i]
240B		JMP_4 <BB#1>
	    Successors according to CFG: BB#1

256B	BB#3: derived from LLVM BB %for.end
	    Predecessors according to CFG: BB#1
272B		%vreg2<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg2
288B		%EAX<def> = COPY %vreg2; GR32:%vreg2
304B		RET %EAX<kill>

# End machine code for function main.

********** SIMPLE REGISTER COALESCING **********
********** Function: main
********** JOINING INTERVALS ***********
for.cond:
for.body:
176B	%EDI<def> = COPY %vreg3; GR32:%vreg3
	Considering merging %vreg3 with %EDI
	Can only merge into reserved registers.
entry:
for.end:
288B	%EAX<def> = COPY %vreg2; GR32:%vreg2
	Considering merging %vreg2 with %EAX
	Can only merge into reserved registers.
Remat: %EAX<def> = MOV32r0 %EFLAGS<imp-def,dead>
Shrink: %vreg2 [272r,288r:0)  0@272r
All defs dead: 272r	%vreg2<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg2
Shrunk: %vreg2 [272r,272d:0)  0@272r
Deleting dead def 272r	%vreg2<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg2
Trying to inflate 0 regs.
********** INTERVALS **********
%vreg3 [144r,176r:0)  0@144r
%vreg4 [48r,256B:0)  0@48r
RegMasks: 192r
********** MACHINEINSTRS **********
# Machine code for function main: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]

0B	BB#0: derived from LLVM BB %entry
16B		MOV32mi <fi#0>, 1, %noreg, 0, %noreg, 0; mem:ST4[%retval]
32B		MOV32mi <fi#1>, 1, %noreg, 0, %noreg, 0; mem:ST4[%i]
48B		%vreg4<def> = MOV64ri <ga:@func>; GR64:%vreg4
	    Successors according to CFG: BB#1

64B	BB#1: derived from LLVM BB %for.cond
	    Predecessors according to CFG: BB#0 BB#2
80B		CMP32mi8 <fi#1>, 1, %noreg, 0, %noreg, 10, %EFLAGS<imp-def>; mem:LD4[%i]
96B		JG_4 <BB#3>, %EFLAGS<imp-use,kill>
112B		JMP_4 <BB#2>
	    Successors according to CFG: BB#2(124) BB#3(4)

128B	BB#2: derived from LLVM BB %for.body
	    Predecessors according to CFG: BB#1
144B		%vreg3<def> = MOV32rm <fi#1>, 1, %noreg, 0, %noreg; mem:LD4[%i] GR32:%vreg3
160B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
176B		%EDI<def> = COPY %vreg3; GR32:%vreg3
192B		CALL64r %vreg4, <regmask>, %RSP<imp-use>, %EDI<imp-use,kill>, %RSP<imp-def>; GR64:%vreg4
208B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
224B		INC64_32m <fi#1>, 1, %noreg, 0, %noreg, %EFLAGS<imp-def,dead>; mem:ST4[%i] LD4[%i]
240B		JMP_4 <BB#1>
	    Successors according to CFG: BB#1

256B	BB#3: derived from LLVM BB %for.end
	    Predecessors according to CFG: BB#1
288B		%EAX<def> = MOV32r0 %EFLAGS<imp-def,dead>
304B		RET %EAX<kill>

# End machine code for function main.

Before MISsched:
# Machine code for function main: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]

BB#0: derived from LLVM BB %entry
	MOV32mi <fi#0>, 1, %noreg, 0, %noreg, 0; mem:ST4[%retval]
	MOV32mi <fi#1>, 1, %noreg, 0, %noreg, 0; mem:ST4[%i]
	%vreg4<def> = MOV64ri <ga:@func>; GR64:%vreg4
    Successors according to CFG: BB#1

BB#1: derived from LLVM BB %for.cond
    Predecessors according to CFG: BB#0 BB#2
	CMP32mi8 <fi#1>, 1, %noreg, 0, %noreg, 10, %EFLAGS<imp-def>; mem:LD4[%i]
	JG_4 <BB#3>, %EFLAGS<imp-use,kill>
	JMP_4 <BB#2>
    Successors according to CFG: BB#2(124) BB#3(4)

BB#2: derived from LLVM BB %for.body
    Predecessors according to CFG: BB#1
	%vreg3<def> = MOV32rm <fi#1>, 1, %noreg, 0, %noreg; mem:LD4[%i] GR32:%vreg3
	ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	%EDI<def> = COPY %vreg3; GR32:%vreg3
	CALL64r %vreg4, <regmask>, %RSP<imp-use>, %EDI<imp-use,kill>, %RSP<imp-def>; GR64:%vreg4
	ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	INC64_32m <fi#1>, 1, %noreg, 0, %noreg, %EFLAGS<imp-def,dead>; mem:ST4[%i] LD4[%i]
	JMP_4 <BB#1>
    Successors according to CFG: BB#1

BB#3: derived from LLVM BB %for.end
    Predecessors according to CFG: BB#1
	%EAX<def> = MOV32r0 %EFLAGS<imp-def,dead>
	RET %EAX<kill>

# End machine code for function main.

AllocationOrder(GR32) = [ %EAX %ECX %EDX %ESI %EDI %R8D %R9D %R10D %R11D %EBX %R14D %R15D %R12D %R13D ]
********** MI Scheduling **********
main:BB#0 entry
  From: MOV32mi <fi#0>, 1, %noreg, 0, %noreg, 0; mem:ST4[%retval]
    To: End RegionInstrs: 3 Remaining: 0
Disabled scoreboard hazard recognizer
Disabled scoreboard hazard recognizer
SU(0):   MOV32mi <fi#0>, 1, %noreg, 0, %noreg, 0; mem:ST4[%retval]
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
   ch  SU(4294967295) *: Latency=0

SU(1):   MOV32mi <fi#1>, 1, %noreg, 0, %noreg, 0; mem:ST4[%i]
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
   ch  SU(4294967295) *: Latency=0

SU(2):   %vreg4<def> = MOV64ri <ga:@func>; GR64:%vreg4
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0

Critical Path: 0
BotQ.A: 2 1 0 
  SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %vreg4<def> = MOV64ri <ga:@func>; GR64:%vreg4
  Ready @0c
  SBPort015 +1x4u
  *** Critical resource SBPort015: 0c
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 0c
  - Latency limited.
BotQ.A: 0 1 
  SU(0) ORDER                              
  SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) MOV32mi <fi#1>, 1, %noreg, 0, %noreg, 0; mem:ST4[%i]
  Ready @0c
  SBPort4 +1x12u
  *** Critical resource SBPort4: 1c
  SBPort23 +1x6u
  SBPortAny +2x2u
BotQ.A @0c
  Retired: 2
  Executed: 1c
  Critical: 1c, 1 SBPort4
  ExpectedLatency: 0c
  - Latency limited.
Scheduling SU(0) MOV32mi <fi#0>, 1, %noreg, 0, %noreg, 0; mem:ST4[%retval]
  Ready @0c
  SBPort4 +1x12u
  SBPort23 +1x6u
  SBPortAny +2x2u
BotQ.A @0c
  Retired: 3
  Executed: 2c
  Critical: 2c, 2 SBPort4
  ExpectedLatency: 0c
  - Resource limited.
*** Final schedule for BB#0 ***
SU(0):   MOV32mi <fi#0>, 1, %noreg, 0, %noreg, 0; mem:ST4[%retval]
SU(1):   MOV32mi <fi#1>, 1, %noreg, 0, %noreg, 0; mem:ST4[%i]
SU(2):   %vreg4<def> = MOV64ri <ga:@func>; GR64:%vreg4

********** INTERVALS **********
%vreg3 [144r,176r:0)  0@144r
%vreg4 [48r,256B:0)  0@48r
RegMasks: 192r
********** MACHINEINSTRS **********
# Machine code for function main: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]

0B	BB#0: derived from LLVM BB %entry
16B		MOV32mi <fi#0>, 1, %noreg, 0, %noreg, 0; mem:ST4[%retval]
32B		MOV32mi <fi#1>, 1, %noreg, 0, %noreg, 0; mem:ST4[%i]
48B		%vreg4<def> = MOV64ri <ga:@func>; GR64:%vreg4
	    Successors according to CFG: BB#1

64B	BB#1: derived from LLVM BB %for.cond
	    Predecessors according to CFG: BB#0 BB#2
80B		CMP32mi8 <fi#1>, 1, %noreg, 0, %noreg, 10, %EFLAGS<imp-def>; mem:LD4[%i]
96B		JG_4 <BB#3>, %EFLAGS<imp-use,kill>
112B		JMP_4 <BB#2>
	    Successors according to CFG: BB#2(124) BB#3(4)

128B	BB#2: derived from LLVM BB %for.body
	    Predecessors according to CFG: BB#1
144B		%vreg3<def> = MOV32rm <fi#1>, 1, %noreg, 0, %noreg; mem:LD4[%i] GR32:%vreg3
160B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
176B		%EDI<def> = COPY %vreg3; GR32:%vreg3
192B		CALL64r %vreg4, <regmask>, %RSP<imp-use>, %EDI<imp-use,kill>, %RSP<imp-def>; GR64:%vreg4
208B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
224B		INC64_32m <fi#1>, 1, %noreg, 0, %noreg, %EFLAGS<imp-def,dead>; mem:ST4[%i] LD4[%i]
240B		JMP_4 <BB#1>
	    Successors according to CFG: BB#1

256B	BB#3: derived from LLVM BB %for.end
	    Predecessors according to CFG: BB#1
288B		%EAX<def> = MOV32r0 %EFLAGS<imp-def,dead>
304B		RET %EAX<kill>

# End machine code for function main.

RPO[BB#0 derived from LLVM BB entry] = 1
RPO[BB#1 derived from LLVM BB for.cond] = 2
RPO[BB#3 derived from LLVM BB for.end] = 3
RPO[BB#2 derived from LLVM BB for.body] = 4
POT: BB#2 derived from LLVM BB for.body
POT: BB#3 derived from LLVM BB for.end
POT: BB#1 derived from LLVM BB for.cond
doLoop(BB#1 derived from LLVM BB for.cond, BB#2 derived from LLVM BB for.body)
doBlock(BB#1 derived from LLVM BB for.cond)
Frequency(BB#1 derived from LLVM BB for.cond) = 0.0
Frequency(BB#1 derived from LLVM BB for.cond) = 1.0
doBlock(BB#3 derived from LLVM BB for.end)
Frequency(BB#3 derived from LLVM BB for.end) = 0.0
Frequency(BB#3 derived from LLVM BB for.end) = 0.03125
doBlock(BB#2 derived from LLVM BB for.body)
Frequency(BB#2 derived from LLVM BB for.body) = 0.0
Frequency(BB#2 derived from LLVM BB for.body) = 0.96875
LoopExitProb[BB#1 derived from LLVM BB for.cond] = 512 / 16384 = 3.125% from 1 - 0.96875 / 1.0.
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#2 derived from LLVM BB for.body)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0.0
Frequency(BB#0 derived from LLVM BB entry) = 1.0
doBlock(BB#1 derived from LLVM BB for.cond)
Frequency(BB#1 derived from LLVM BB for.cond) = 0.0
Frequency(BB#1 derived from LLVM BB for.cond) += 1.0 --> 1.0
Loop header scaled to 32.0.
doBlock(BB#3 derived from LLVM BB for.end)
Frequency(BB#3 derived from LLVM BB for.end) = 0.0
Frequency(BB#3 derived from LLVM BB for.end) = 1.0
doBlock(BB#2 derived from LLVM BB for.body)
Frequency(BB#2 derived from LLVM BB for.body) = 0.0
Frequency(BB#2 derived from LLVM BB for.body) = 31.0
LoopExitProb[BB#0 derived from LLVM BB entry] = 16383 / 16384 = 99.9939% from 1 - 0.0 / 1.0.
********** COMPUTING LIVE DEBUG VARIABLES: main **********
********** DEBUG VARIABLES **********
********** GREEDY REGISTER ALLOCATION **********
********** Function: main
********** Compute Spill Weights **********
********** Function: main
********** INTERVALS **********
%vreg3 [144r,176r:0)  0@144r
%vreg4 [48r,256B:0)  0@48r
RegMasks: 192r
********** MACHINEINSTRS **********
# Machine code for function main: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]

0B	BB#0: derived from LLVM BB %entry
16B		MOV32mi <fi#0>, 1, %noreg, 0, %noreg, 0; mem:ST4[%retval]
32B		MOV32mi <fi#1>, 1, %noreg, 0, %noreg, 0; mem:ST4[%i]
48B		%vreg4<def> = MOV64ri <ga:@func>; GR64:%vreg4
	    Successors according to CFG: BB#1

64B	BB#1: derived from LLVM BB %for.cond
	    Predecessors according to CFG: BB#0 BB#2
80B		CMP32mi8 <fi#1>, 1, %noreg, 0, %noreg, 10, %EFLAGS<imp-def>; mem:LD4[%i]
96B		JG_4 <BB#3>, %EFLAGS<imp-use,kill>
112B		JMP_4 <BB#2>
	    Successors according to CFG: BB#2(124) BB#3(4)

128B	BB#2: derived from LLVM BB %for.body
	    Predecessors according to CFG: BB#1
144B		%vreg3<def> = MOV32rm <fi#1>, 1, %noreg, 0, %noreg; mem:LD4[%i] GR32:%vreg3
160B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
176B		%EDI<def> = COPY %vreg3; GR32:%vreg3
192B		CALL64r %vreg4, <regmask>, %RSP<imp-use>, %EDI<imp-use,kill>, %RSP<imp-def>; GR64:%vreg4
208B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
224B		INC64_32m <fi#1>, 1, %noreg, 0, %noreg, %EFLAGS<imp-def,dead>; mem:ST4[%i] LD4[%i]
240B		JMP_4 <BB#1>
	    Successors according to CFG: BB#1

256B	BB#3: derived from LLVM BB %for.end
	    Predecessors according to CFG: BB#1
288B		%EAX<def> = MOV32r0 %EFLAGS<imp-def,dead>
304B		RET %EAX<kill>

# End machine code for function main.


selectOrSplit GR32:%vreg3 [144r,176r:0)  0@144r
AllocationOrder(GR32) = [ %EAX %ECX %EDX %ESI %EDI %R8D %R9D %R10D %R11D %EBX %R14D %R15D %R12D %R13D ]
hints: %EDI
assigning %vreg3 to %EDI: DIL

selectOrSplit GR64:%vreg4 [48r,256B:0)  0@48r
AllocationOrder(GR64) = [ %RAX %RCX %RDX %RSI %RDI %R8 %R9 %R10 %R11 %RBX %R14 %R15 %R12 %R13 ]
assigning %vreg4 to %RBX: BH BL
********** REWRITE VIRTUAL REGISTERS **********
********** Function: main
********** REGISTER MAP **********
[%vreg3 -> %EDI] GR32
[%vreg4 -> %RBX] GR64

0B	BB#0: derived from LLVM BB %entry
16B		MOV32mi <fi#0>, 1, %noreg, 0, %noreg, 0; mem:ST4[%retval]
32B		MOV32mi <fi#1>, 1, %noreg, 0, %noreg, 0; mem:ST4[%i]
48B		%vreg4<def> = MOV64ri <ga:@func>; GR64:%vreg4
	    Successors according to CFG: BB#1
> MOV32mi <fi#0>, 1, %noreg, 0, %noreg, 0; mem:ST4[%retval]
> MOV32mi <fi#1>, 1, %noreg, 0, %noreg, 0; mem:ST4[%i]
> %RBX<def> = MOV64ri <ga:@func>
64B	BB#1: derived from LLVM BB %for.cond
	    Live Ins: %RBX
	    Predecessors according to CFG: BB#0 BB#2
80B		CMP32mi8 <fi#1>, 1, %noreg, 0, %noreg, 10, %EFLAGS<imp-def>; mem:LD4[%i]
96B		JG_4 <BB#3>, %EFLAGS<imp-use,kill>
112B		JMP_4 <BB#2>
	    Successors according to CFG: BB#2(124) BB#3(4)
> CMP32mi8 <fi#1>, 1, %noreg, 0, %noreg, 10, %EFLAGS<imp-def>; mem:LD4[%i]
> JG_4 <BB#3>, %EFLAGS<imp-use,kill>
> JMP_4 <BB#2>
128B	BB#2: derived from LLVM BB %for.body
	    Live Ins: %RBX
	    Predecessors according to CFG: BB#1
144B		%vreg3<def> = MOV32rm <fi#1>, 1, %noreg, 0, %noreg; mem:LD4[%i] GR32:%vreg3
160B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
176B		%EDI<def> = COPY %vreg3<kill>; GR32:%vreg3
192B		CALL64r %vreg4, <regmask>, %RSP<imp-use>, %EDI<imp-use>, %RSP<imp-def>; GR64:%vreg4
208B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
224B		INC64_32m <fi#1>, 1, %noreg, 0, %noreg, %EFLAGS<imp-def,dead>; mem:ST4[%i] LD4[%i]
240B		JMP_4 <BB#1>
	    Successors according to CFG: BB#1
> %EDI<def> = MOV32rm <fi#1>, 1, %noreg, 0, %noreg; mem:LD4[%i]
> ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> %EDI<def> = COPY %EDI<kill>
Deleting identity copy.
> CALL64r %RBX, <regmask>, %RSP<imp-use>, %EDI<imp-use>, %RSP<imp-def>
> ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> INC64_32m <fi#1>, 1, %noreg, 0, %noreg, %EFLAGS<imp-def,dead>; mem:ST4[%i] LD4[%i]
> JMP_4 <BB#1>
256B	BB#3: derived from LLVM BB %for.end
	    Predecessors according to CFG: BB#1
288B		%EAX<def> = MOV32r0 %EFLAGS<imp-def,dead>
304B		RET %EAX<kill>
> %EAX<def> = MOV32r0 %EFLAGS<imp-def,dead>
> RET %EAX<kill>
********** EMITTING LIVE DEBUG VARIABLES **********
********** Stack Slot Coloring **********
********** Function: main
******** Post-regalloc Machine LICM: main ********

Setting up live-ins for BB#0 derived from entry.
Block has no FP live-ins.
Setting up live-outs for BB#0 derived from entry.
Stack contents:
No live-outs.

Setting up live-ins for BB#1 derived from for.cond.
Block has no FP live-ins.
Setting up live-outs for BB#1 derived from for.cond.
Stack contents:
No live-outs.

Setting up live-ins for BB#2 derived from for.body.
Block has no FP live-ins.
Setting up live-outs for BB#2 derived from for.body.
Stack contents:
No live-outs.

Setting up live-ins for BB#3 derived from for.end.
Block has no FP live-ins.

FPInst:	RET %EAX<kill>
Stack contents:
Inserted instructions:
	RET %EAX<kill>
Stack contents:
alloc FI(0) at SP[-28]
alloc FI(1) at SP[-32]

TryTailMergeBlocks: BB#0, BB#2
  with successor BB#1
  which has fall-through from BB#0
Looking for common tails of at least 3 instructions
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: main
RPO[BB#0 derived from LLVM BB entry] = 1
RPO[BB#1 derived from LLVM BB for.cond] = 2
RPO[BB#3 derived from LLVM BB for.end] = 3
RPO[BB#2 derived from LLVM BB for.body] = 4
POT: BB#2 derived from LLVM BB for.body
POT: BB#3 derived from LLVM BB for.end
POT: BB#1 derived from LLVM BB for.cond
doLoop(BB#1 derived from LLVM BB for.cond, BB#2 derived from LLVM BB for.body)
doBlock(BB#1 derived from LLVM BB for.cond)
Frequency(BB#1 derived from LLVM BB for.cond) = 0.0
Frequency(BB#1 derived from LLVM BB for.cond) = 1.0
doBlock(BB#3 derived from LLVM BB for.end)
Frequency(BB#3 derived from LLVM BB for.end) = 0.0
Frequency(BB#3 derived from LLVM BB for.end) = 0.03125
doBlock(BB#2 derived from LLVM BB for.body)
Frequency(BB#2 derived from LLVM BB for.body) = 0.0
Frequency(BB#2 derived from LLVM BB for.body) = 0.96875
LoopExitProb[BB#1 derived from LLVM BB for.cond] = 512 / 16384 = 3.125% from 1 - 0.96875 / 1.0.
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#2 derived from LLVM BB for.body)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0.0
Frequency(BB#0 derived from LLVM BB entry) = 1.0
doBlock(BB#1 derived from LLVM BB for.cond)
Frequency(BB#1 derived from LLVM BB for.cond) = 0.0
Frequency(BB#1 derived from LLVM BB for.cond) += 1.0 --> 1.0
Loop header scaled to 32.0.
doBlock(BB#3 derived from LLVM BB for.end)
Frequency(BB#3 derived from LLVM BB for.end) = 0.0
Frequency(BB#3 derived from LLVM BB for.end) = 1.0
doBlock(BB#2 derived from LLVM BB for.body)
Frequency(BB#2 derived from LLVM BB for.body) = 0.0
Frequency(BB#2 derived from LLVM BB for.body) = 31.0
LoopExitProb[BB#0 derived from LLVM BB entry] = 16383 / 16384 = 99.9939% from 1 - 0.0 / 1.0.
Finding best loop top for: BB#1 (derived from LLVM BB 'for.cond')
    header pred: BB#2 (derived from LLVM BB 'for.body'), 1 successors, 31.0 freq
    final top: BB#2 (derived from LLVM BB 'for.body')
Attempting merge from: BB#2 (derived from LLVM BB 'for.body')
    BB#1 (derived from LLVM BB 'for.cond') -> 16 / 16 = 100% (prob)
Merging from BB#2 to BB#1
Attempting merge from: BB#1 (derived from LLVM BB 'for.cond')
    BB#2 (derived from LLVM BB 'for.body') -> Already merged!
Finished forming chain for header block BB#2
          ... BB#2 (derived from LLVM BB 'for.body')
          ... BB#1 (derived from LLVM BB 'for.cond')
Attempting merge from: BB#0 (derived from LLVM BB 'entry')
    BB#1 (derived from LLVM BB 'for.cond') -> Mid chain!
    BB#2 (derived from LLVM BB 'for.body') -> 31.0 (freq)
Merging from BB#0 to BB#2
Attempting merge from: BB#1 (derived from LLVM BB 'for.cond')
    BB#2 (derived from LLVM BB 'for.body') -> Already merged!
    BB#3 (derived from LLVM BB 'for.end') -> 4 / 128 = 3.125% (prob)
Merging from BB#1 to BB#3
Attempting merge from: BB#3 (derived from LLVM BB 'for.end')
Finished forming chain for header block BB#0
Placing chain BB#0 (derived from LLVM BB 'entry')
          ... BB#2 (derived from LLVM BB 'for.body')
          ... BB#1 (derived from LLVM BB 'for.cond')
          ... BB#3 (derived from LLVM BB 'for.end')
********** FIX EXECUTION DEPENDENCIES: VR128 **********
BB#0: entry
BB#1: incomplete
BB#3: all preds known
BB#2: all preds known
BB#1: all preds known
JITTing function 'main'
JIT: Starting CodeGen of Function main
JIT: Emitting BB0 at [0x7f7e4367b010]
PUSH64r %RBP<kill>, %RSP<imp-def>, %RSP<imp-use>; flags: FrameSetup
PROLOG_LABEL <MCSym=.Ltmp0>
%RBP<def> = MOV64rr %RSP; flags: FrameSetup
PROLOG_LABEL <MCSym=.Ltmp1>
PUSH64r %RBX<kill>, %RSP<imp-def>, %RSP<imp-use>; flags: FrameSetup
PUSH64r %RAX<undef>, %RSP<imp-def>, %RSP<imp-use>; flags: FrameSetup
PROLOG_LABEL <MCSym=.Ltmp2>
MOV32mi %RBP, 1, %noreg, -12, %noreg, 0; mem:ST4[%retval]
MOV32mi %RBP, 1, %noreg, -16, %noreg, 0; mem:ST4[%i]
%RBX<def> = MOV64ri <ga:@func>
JMP_4 <BB#1>
RawFrm CurOp 1
isMBB 1
isGlobal 0
isSymbol 0
isImm 0
JIT: Emitting BB2 at [0x7f7e4367b033]
%EDI<def> = MOV32rm %RBP, 1, %noreg, -16, %noreg; mem:LD4[%i]
CALL64r %RBX, <regmask>, %RSP<imp-use>, %EDI<imp-use>, %RSP<imp-def>
INC64_32m %RBP, 1, %noreg, -16, %noreg, %EFLAGS<imp-def,dead>; mem:ST4[%i] LD4[%i]
JIT: Emitting BB1 at [0x7f7e4367b03b]
CMP32mi8 %RBP, 1, %noreg, -16, %noreg, 10, %EFLAGS<imp-def>; mem:LD4[%i]
JLE_4 <BB#2>, %EFLAGS<imp-use>
RawFrm CurOp 1
isMBB 1
isGlobal 0
isSymbol 0
isImm 0
JIT: Emitting BB3 at [0x7f7e4367b045]
%EAX<def> = MOV32r0 %EFLAGS<imp-def,dead>
%RSP<def,tied1> = ADD64ri8 %RSP<tied0>, 8, %EFLAGS<imp-def,dead>
%RBX<def> = POP64r %RSP<imp-def>, %RSP<imp-use>
%RBP<def> = POP64r %RSP<imp-def>, %RSP<imp-use>
RET %EAX<kill>
JIT: Lazy stub emitted at [0x7f7e43c31010] for function 'func'
JIT: Finished CodeGen of [0x7f7e4367b010] Function: main: 62 bytes of text, 3 relocations
JIT: Binary code:
JIT: 0: 2291377285 691998083 000244 240691990 
JIT: 16: 0000 161618772 12712667195 823300 
JIT: 32: 139000 211255240125 13124069255 1510240125 
JIT: 48: 255255238142 7219249255 918196131 19593
 runFunction main
[JITProfiling] Inserted Callback to func
JIT: Lazily resolving function 'func' In stub ptr = 0x7f7e43c3101c actual ptr = 0x7f7e43c31010
CGP: Found      local addrmode: [Base:%i.addr]
CGP: Found      local addrmode: [Base:%i.addr]
Computing probabilities for entry



=== func
Initial selection DAG: BB#0 'func:entry'
SelectionDAG has 37 nodes:
  0x2e5c478: ch = EntryToken

  0x2e7f9b0: i64 = TargetConstant<0>

  0x2e7ffb0: i64 = Register %RDI

      0x2e5c478: <multiple use>
      0x2e7f9b0: <multiple use>
    0x2e800b0: ch,glue = callseq_start 0x2e5c478, 0x2e7f9b0 [ORD=20]

    0x2e7ffb0: <multiple use>
    0x2e7feb0: i64 = Constant<48717472>

  0x2e83c40: ch,glue = CopyToReg 0x2e800b0, 0x2e7ffb0, 0x2e7feb0 [ORD=20]

  0x2e7f8b0: i64 = Register %RSI

    0x2e83c40: <multiple use>
    0x2e7f8b0: <multiple use>
    0x2e7fcb0: i64 = Constant<48397984>

    0x2e83c40: <multiple use>
  0x2e7f4b0: ch,glue = CopyToReg 0x2e83c40, 0x2e7f8b0, 0x2e7fcb0, 0x2e83c40:1 [ORD=20]

  0x2e7f3b0: Untyped = RegisterMask

    0x2e7f4b0: <multiple use>
    0x2e83b40: i64 = Constant<8971440>

    0x2e7ffb0: <multiple use>
    0x2e7f8b0: <multiple use>
    0x2e7f3b0: <multiple use>
    0x2e7f4b0: <multiple use>
  0x2e7fbb0: ch,glue = X86ISD::CALL 0x2e7f4b0, 0x2e83b40, 0x2e7ffb0, 0x2e7f8b0, 0x2e7f3b0, 0x2e7f4b0:1 [ORD=20]

    0x2e7fbb0: <multiple use>
    0x2e7f9b0: <multiple use>
    0x2e7f9b0: <multiple use>
    0x2e7fbb0: <multiple use>
  0x2e7f7b0: ch,glue = callseq_end 0x2e7fbb0, 0x2e7f9b0, 0x2e7f9b0, 0x2e7fbb0:1 [ORD=20]

  0x2e7f6b0: i64 = FrameIndex<0>

  0x2e83d40: i64 = Constant<0>

  0x2e83e40: i64 = undef

        0x2e7f7b0: <multiple use>
        0x2e801b0: i64 = Register %RAX

        0x2e7f7b0: <multiple use>
      0x2e7f5b0: i64,ch,glue = CopyFromReg 0x2e7f7b0, 0x2e801b0, 0x2e7f7b0:1 [ORD=20]

        0x2e5c478: <multiple use>
        0x2e7fab0: i32 = Register %vreg0

      0x2e7fdb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=16]

      0x2e7f6b0: <multiple use>
      0x2e83e40: <multiple use>
    0x2e83f40: ch = store 0x2e7f5b0:1, 0x2e7fdb0, 0x2e7f6b0, 0x2e83e40<ST4[%i.addr]> [ORD=22]

    0x2e7f6b0: <multiple use>
    0x2e83e40: <multiple use>
  0x2e84040: i32,ch = load 0x2e83f40, 0x2e7f6b0, 0x2e83e40<LD4[%i.addr]> [ORD=23]

      0x2e84040: <multiple use>
      0x2e7f9b0: <multiple use>
    0x2e84340: ch,glue = callseq_start 0x2e84040:1, 0x2e7f9b0 [ORD=24]

    0x2e7ffb0: <multiple use>
    0x2e84240: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=24]

  0x2e84540: ch,glue = CopyToReg 0x2e84340, 0x2e7ffb0, 0x2e84240 [ORD=24]

  0x2e84640: i32 = Register %ESI

    0x2e84540: <multiple use>
    0x2e84640: <multiple use>
    0x2e84040: <multiple use>
    0x2e84540: <multiple use>
  0x2e84740: ch,glue = CopyToReg 0x2e84540, 0x2e84640, 0x2e84040, 0x2e84540:1 [ORD=24]

  0x2e84840: i8 = Register %AL

    0x2e84740: <multiple use>
    0x2e84840: <multiple use>
    0x2e84440: i8 = Constant<0>

    0x2e84740: <multiple use>
  0x2e84940: ch,glue = CopyToReg 0x2e84740, 0x2e84840, 0x2e84440, 0x2e84740:1 [ORD=24]

    0x2e84940: <multiple use>
    0x2e84140: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=24]

    0x2e7ffb0: <multiple use>
    0x2e84640: <multiple use>
    0x2e84840: <multiple use>
    0x2e7f3b0: <multiple use>
    0x2e84940: <multiple use>
  0x2ea9680: ch,glue = X86ISD::CALL 0x2e84940, 0x2e84140, 0x2e7ffb0, 0x2e84640, 0x2e84840, 0x2e7f3b0, 0x2e84940:1 [ORD=24]

    0x2ea9680: <multiple use>
    0x2e7f9b0: <multiple use>
    0x2e7f9b0: <multiple use>
    0x2ea9680: <multiple use>
  0x2ea9780: ch,glue = callseq_end 0x2ea9680, 0x2e7f9b0, 0x2e7f9b0, 0x2ea9680:1 [ORD=24]

      0x2ea9780: <multiple use>
      0x2ea9880: i32 = Register %EAX

      0x2ea9780: <multiple use>
    0x2ea9980: i32,ch,glue = CopyFromReg 0x2ea9780, 0x2ea9880, 0x2ea9780:1 [ORD=24]

    0x2ea9a80: i16 = TargetConstant<0>

  0x2ea9b80: ch = X86ISD::RET_FLAG 0x2ea9980:1, 0x2ea9a80 [ORD=25]



Replacing.1 0x2e84040: i32,ch = load 0x2e83f40, 0x2e7f6b0, 0x2e83e40<LD4[%i.addr]> [ORD=23]

With: 0x2e7fdb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=16]
 and 1 other values
Optimized lowered selection DAG: BB#0 'func:entry'
SelectionDAG has 35 nodes:
  0x2e5c478: ch = EntryToken

    0x2e5c478: <multiple use>
    0x2e7fab0: i32 = Register %vreg0

  0x2e7fdb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=16]

  0x2e7f9b0: i64 = TargetConstant<0>

  0x2e7ffb0: i64 = Register %RDI

      0x2e5c478: <multiple use>
      0x2e7f9b0: <multiple use>
    0x2e800b0: ch,glue = callseq_start 0x2e5c478, 0x2e7f9b0 [ORD=20]

    0x2e7ffb0: <multiple use>
    0x2e7feb0: i64 = Constant<48717472>

  0x2e83c40: ch,glue = CopyToReg 0x2e800b0, 0x2e7ffb0, 0x2e7feb0 [ORD=20]

  0x2e7f8b0: i64 = Register %RSI

    0x2e83c40: <multiple use>
    0x2e7f8b0: <multiple use>
    0x2e7fcb0: i64 = Constant<48397984>

    0x2e83c40: <multiple use>
  0x2e7f4b0: ch,glue = CopyToReg 0x2e83c40, 0x2e7f8b0, 0x2e7fcb0, 0x2e83c40:1 [ORD=20]

  0x2e7f3b0: Untyped = RegisterMask

    0x2e7f4b0: <multiple use>
    0x2e83b40: i64 = Constant<8971440>

    0x2e7ffb0: <multiple use>
    0x2e7f8b0: <multiple use>
    0x2e7f3b0: <multiple use>
    0x2e7f4b0: <multiple use>
  0x2e7fbb0: ch,glue = X86ISD::CALL 0x2e7f4b0, 0x2e83b40, 0x2e7ffb0, 0x2e7f8b0, 0x2e7f3b0, 0x2e7f4b0:1 [ORD=20]

    0x2e7fbb0: <multiple use>
    0x2e7f9b0: <multiple use>
    0x2e7f9b0: <multiple use>
    0x2e7fbb0: <multiple use>
  0x2e7f7b0: ch,glue = callseq_end 0x2e7fbb0, 0x2e7f9b0, 0x2e7f9b0, 0x2e7fbb0:1 [ORD=20]

          0x2e7f7b0: <multiple use>
          0x2e801b0: i64 = Register %RAX

          0x2e7f7b0: <multiple use>
        0x2e7f5b0: i64,ch,glue = CopyFromReg 0x2e7f7b0, 0x2e801b0, 0x2e7f7b0:1 [ORD=20]

        0x2e7fdb0: <multiple use>
        0x2e7f6b0: i64 = FrameIndex<0>

        0x2e83e40: i64 = undef

      0x2e83f40: ch = store 0x2e7f5b0:1, 0x2e7fdb0, 0x2e7f6b0, 0x2e83e40<ST4[%i.addr]> [ORD=22]

      0x2e7f9b0: <multiple use>
    0x2e84340: ch,glue = callseq_start 0x2e83f40, 0x2e7f9b0 [ORD=24]

    0x2e7ffb0: <multiple use>
    0x2e84240: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=24]

  0x2e84540: ch,glue = CopyToReg 0x2e84340, 0x2e7ffb0, 0x2e84240 [ORD=24]

  0x2e84640: i32 = Register %ESI

    0x2e84540: <multiple use>
    0x2e84640: <multiple use>
    0x2e7fdb0: <multiple use>
    0x2e84540: <multiple use>
  0x2e84740: ch,glue = CopyToReg 0x2e84540, 0x2e84640, 0x2e7fdb0, 0x2e84540:1 [ORD=24]

  0x2e84840: i8 = Register %AL

    0x2e84740: <multiple use>
    0x2e84840: <multiple use>
    0x2e84440: i8 = Constant<0>

    0x2e84740: <multiple use>
  0x2e84940: ch,glue = CopyToReg 0x2e84740, 0x2e84840, 0x2e84440, 0x2e84740:1 [ORD=24]

    0x2e84940: <multiple use>
    0x2e84140: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=24]

    0x2e7ffb0: <multiple use>
    0x2e84640: <multiple use>
    0x2e84840: <multiple use>
    0x2e7f3b0: <multiple use>
    0x2e84940: <multiple use>
  0x2ea9680: ch,glue = X86ISD::CALL 0x2e84940, 0x2e84140, 0x2e7ffb0, 0x2e84640, 0x2e84840, 0x2e7f3b0, 0x2e84940:1 [ORD=24]

    0x2ea9680: <multiple use>
    0x2e7f9b0: <multiple use>
    0x2e7f9b0: <multiple use>
    0x2ea9680: <multiple use>
  0x2ea9780: ch,glue = callseq_end 0x2ea9680, 0x2e7f9b0, 0x2e7f9b0, 0x2ea9680:1 [ORD=24]

      0x2ea9780: <multiple use>
      0x2ea9880: i32 = Register %EAX

      0x2ea9780: <multiple use>
    0x2ea9980: i32,ch,glue = CopyFromReg 0x2ea9780, 0x2ea9880, 0x2ea9780:1 [ORD=24]

    0x2ea9a80: i16 = TargetConstant<0>

  0x2ea9b80: ch = X86ISD::RET_FLAG 0x2ea9980:1, 0x2ea9a80 [ORD=25]


Legally typed node: 0x2ea9a80: i16 = TargetConstant<0> [ID=0]

Legally typed node: 0x2ea9880: i32 = Register %EAX [ID=0]

Legally typed node: 0x2e84840: i8 = Register %AL [ID=0]

Legally typed node: 0x2e84640: i32 = Register %ESI [ID=0]

Legally typed node: 0x2e84440: i8 = Constant<0> [ID=0]

Legally typed node: 0x2e84240: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=24] [ID=0]

Legally typed node: 0x2e84140: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=24] [ID=0]

Legally typed node: 0x2e83e40: i64 = undef [ID=0]

Legally typed node: 0x2e7f6b0: i64 = FrameIndex<0> [ID=0]

Legally typed node: 0x2e801b0: i64 = Register %RAX [ID=0]

Legally typed node: 0x2e7f3b0: Untyped = RegisterMask [ID=0]

Legally typed node: 0x2e7f8b0: i64 = Register %RSI [ID=0]

Legally typed node: 0x2e7ffb0: i64 = Register %RDI [ID=0]

Legally typed node: 0x2e7f9b0: i64 = TargetConstant<0> [ID=0]

Legally typed node: 0x2e7fcb0: i64 = Constant<48397984> [ID=0]

Legally typed node: 0x2e7feb0: i64 = Constant<48717472> [ID=0]

Legally typed node: 0x2e83b40: i64 = Constant<8971440> [ID=0]

Legally typed node: 0x2e7fab0: i32 = Register %vreg0 [ID=0]

Legally typed node: 0x2e5c478: ch = EntryToken [ID=0]

Legally typed node: 0x2e7fdb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=16] [ID=0]

Legally typed node: 0x2e800b0: ch,glue = callseq_start 0x2e5c478, 0x2e7f9b0 [ORD=20] [ID=0]

Legally typed node: 0x2e83c40: ch,glue = CopyToReg 0x2e800b0, 0x2e7ffb0, 0x2e7feb0 [ORD=20] [ID=0]

Legally typed node: 0x2e7f4b0: ch,glue = CopyToReg 0x2e83c40, 0x2e7f8b0, 0x2e7fcb0, 0x2e83c40:1 [ORD=20] [ID=0]

Legally typed node: 0x2e7fbb0: ch,glue = X86ISD::CALL 0x2e7f4b0, 0x2e83b40, 0x2e7ffb0, 0x2e7f8b0, 0x2e7f3b0, 0x2e7f4b0:1 [ORD=20] [ID=0]

Legally typed node: 0x2e7f7b0: ch,glue = callseq_end 0x2e7fbb0, 0x2e7f9b0, 0x2e7f9b0, 0x2e7fbb0:1 [ORD=20] [ID=0]

Legally typed node: 0x2e7f5b0: i64,ch,glue = CopyFromReg 0x2e7f7b0, 0x2e801b0, 0x2e7f7b0:1 [ORD=20] [ID=0]

Legally typed node: 0x2e83f40: ch = store 0x2e7f5b0:1, 0x2e7fdb0, 0x2e7f6b0, 0x2e83e40<ST4[%i.addr]> [ORD=22] [ID=0]

Legally typed node: 0x2e84340: ch,glue = callseq_start 0x2e83f40, 0x2e7f9b0 [ORD=24] [ID=0]

Legally typed node: 0x2e84540: ch,glue = CopyToReg 0x2e84340, 0x2e7ffb0, 0x2e84240 [ORD=24] [ID=0]

Legally typed node: 0x2e84740: ch,glue = CopyToReg 0x2e84540, 0x2e84640, 0x2e7fdb0, 0x2e84540:1 [ORD=24] [ID=0]

Legally typed node: 0x2e84940: ch,glue = CopyToReg 0x2e84740, 0x2e84840, 0x2e84440, 0x2e84740:1 [ORD=24] [ID=0]

Legally typed node: 0x2ea9680: ch,glue = X86ISD::CALL 0x2e84940, 0x2e84140, 0x2e7ffb0, 0x2e84640, 0x2e84840, 0x2e7f3b0, 0x2e84940:1 [ORD=24] [ID=0]

Legally typed node: 0x2ea9780: ch,glue = callseq_end 0x2ea9680, 0x2e7f9b0, 0x2e7f9b0, 0x2ea9680:1 [ORD=24] [ID=0]

Legally typed node: 0x2ea9980: i32,ch,glue = CopyFromReg 0x2ea9780, 0x2ea9880, 0x2ea9780:1 [ORD=24] [ID=0]

Legally typed node: 0x2ea9b80: ch = X86ISD::RET_FLAG 0x2ea9980:1, 0x2ea9a80 [ORD=25] [ID=0]

Legally typed node: 0x7fff29e7b8a0: ch = handlenode 0x2ea9b80 [ID=0]

Type-legalized selection DAG: BB#0 'func:entry'
SelectionDAG has 35 nodes:
  0x2e5c478: ch = EntryToken [ID=-3]

    0x2e5c478: <multiple use>
    0x2e7fab0: i32 = Register %vreg0 [ID=-3]

  0x2e7fdb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=16] [ID=-3]

  0x2e7f9b0: i64 = TargetConstant<0> [ID=-3]

  0x2e7ffb0: i64 = Register %RDI [ID=-3]

      0x2e5c478: <multiple use>
      0x2e7f9b0: <multiple use>
    0x2e800b0: ch,glue = callseq_start 0x2e5c478, 0x2e7f9b0 [ORD=20] [ID=-3]

    0x2e7ffb0: <multiple use>
    0x2e7feb0: i64 = Constant<48717472> [ID=-3]

  0x2e83c40: ch,glue = CopyToReg 0x2e800b0, 0x2e7ffb0, 0x2e7feb0 [ORD=20] [ID=-3]

  0x2e7f8b0: i64 = Register %RSI [ID=-3]

    0x2e83c40: <multiple use>
    0x2e7f8b0: <multiple use>
    0x2e7fcb0: i64 = Constant<48397984> [ID=-3]

    0x2e83c40: <multiple use>
  0x2e7f4b0: ch,glue = CopyToReg 0x2e83c40, 0x2e7f8b0, 0x2e7fcb0, 0x2e83c40:1 [ORD=20] [ID=-3]

  0x2e7f3b0: Untyped = RegisterMask [ID=-3]

    0x2e7f4b0: <multiple use>
    0x2e83b40: i64 = Constant<8971440> [ID=-3]

    0x2e7ffb0: <multiple use>
    0x2e7f8b0: <multiple use>
    0x2e7f3b0: <multiple use>
    0x2e7f4b0: <multiple use>
  0x2e7fbb0: ch,glue = X86ISD::CALL 0x2e7f4b0, 0x2e83b40, 0x2e7ffb0, 0x2e7f8b0, 0x2e7f3b0, 0x2e7f4b0:1 [ORD=20] [ID=-3]

    0x2e7fbb0: <multiple use>
    0x2e7f9b0: <multiple use>
    0x2e7f9b0: <multiple use>
    0x2e7fbb0: <multiple use>
  0x2e7f7b0: ch,glue = callseq_end 0x2e7fbb0, 0x2e7f9b0, 0x2e7f9b0, 0x2e7fbb0:1 [ORD=20] [ID=-3]

          0x2e7f7b0: <multiple use>
          0x2e801b0: i64 = Register %RAX [ID=-3]

          0x2e7f7b0: <multiple use>
        0x2e7f5b0: i64,ch,glue = CopyFromReg 0x2e7f7b0, 0x2e801b0, 0x2e7f7b0:1 [ORD=20] [ID=-3]

        0x2e7fdb0: <multiple use>
        0x2e7f6b0: i64 = FrameIndex<0> [ID=-3]

        0x2e83e40: i64 = undef [ID=-3]

      0x2e83f40: ch = store 0x2e7f5b0:1, 0x2e7fdb0, 0x2e7f6b0, 0x2e83e40<ST4[%i.addr]> [ORD=22] [ID=-3]

      0x2e7f9b0: <multiple use>
    0x2e84340: ch,glue = callseq_start 0x2e83f40, 0x2e7f9b0 [ORD=24] [ID=-3]

    0x2e7ffb0: <multiple use>
    0x2e84240: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=24] [ID=-3]

  0x2e84540: ch,glue = CopyToReg 0x2e84340, 0x2e7ffb0, 0x2e84240 [ORD=24] [ID=-3]

  0x2e84640: i32 = Register %ESI [ID=-3]

    0x2e84540: <multiple use>
    0x2e84640: <multiple use>
    0x2e7fdb0: <multiple use>
    0x2e84540: <multiple use>
  0x2e84740: ch,glue = CopyToReg 0x2e84540, 0x2e84640, 0x2e7fdb0, 0x2e84540:1 [ORD=24] [ID=-3]

  0x2e84840: i8 = Register %AL [ID=-3]

    0x2e84740: <multiple use>
    0x2e84840: <multiple use>
    0x2e84440: i8 = Constant<0> [ID=-3]

    0x2e84740: <multiple use>
  0x2e84940: ch,glue = CopyToReg 0x2e84740, 0x2e84840, 0x2e84440, 0x2e84740:1 [ORD=24] [ID=-3]

    0x2e84940: <multiple use>
    0x2e84140: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=24] [ID=-3]

    0x2e7ffb0: <multiple use>
    0x2e84640: <multiple use>
    0x2e84840: <multiple use>
    0x2e7f3b0: <multiple use>
    0x2e84940: <multiple use>
  0x2ea9680: ch,glue = X86ISD::CALL 0x2e84940, 0x2e84140, 0x2e7ffb0, 0x2e84640, 0x2e84840, 0x2e7f3b0, 0x2e84940:1 [ORD=24] [ID=-3]

    0x2ea9680: <multiple use>
    0x2e7f9b0: <multiple use>
    0x2e7f9b0: <multiple use>
    0x2ea9680: <multiple use>
  0x2ea9780: ch,glue = callseq_end 0x2ea9680, 0x2e7f9b0, 0x2e7f9b0, 0x2ea9680:1 [ORD=24] [ID=-3]

      0x2ea9780: <multiple use>
      0x2ea9880: i32 = Register %EAX [ID=-3]

      0x2ea9780: <multiple use>
    0x2ea9980: i32,ch,glue = CopyFromReg 0x2ea9780, 0x2ea9880, 0x2ea9780:1 [ORD=24] [ID=-3]

    0x2ea9a80: i16 = TargetConstant<0> [ID=-3]

  0x2ea9b80: ch = X86ISD::RET_FLAG 0x2ea9980:1, 0x2ea9a80 [ORD=25] [ID=-3]


Legalized selection DAG: BB#0 'func:entry'
SelectionDAG has 37 nodes:
  0x2e5c478: ch = EntryToken [ID=0]

  0x2e7f9b0: i64 = TargetConstant<0> [ID=5]

  0x2e7ffb0: i64 = Register %RDI [ID=6]

  0x2e7f8b0: i64 = Register %RSI [ID=7]

  0x2e7f3b0: Untyped = RegisterMask [ID=8]

  0x2e84640: i32 = Register %ESI [ID=15]

  0x2e84840: i8 = Register %AL [ID=16]

    0x2e5c478: <multiple use>
    0x2e7fab0: i32 = Register %vreg0 [ID=1]

  0x2e7fdb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=16] [ID=19]

      0x2e5c478: <multiple use>
      0x2e7f9b0: <multiple use>
    0x2e800b0: ch,glue = callseq_start 0x2e5c478, 0x2e7f9b0 [ORD=20] [ID=20]

    0x2e7ffb0: <multiple use>
    0x2e7feb0: i64 = Constant<48717472> [ID=3]

  0x2e83c40: ch,glue = CopyToReg 0x2e800b0, 0x2e7ffb0, 0x2e7feb0 [ORD=20] [ID=21]

    0x2e83c40: <multiple use>
    0x2e7f8b0: <multiple use>
    0x2e7fcb0: i64 = Constant<48397984> [ID=4]

    0x2e83c40: <multiple use>
  0x2e7f4b0: ch,glue = CopyToReg 0x2e83c40, 0x2e7f8b0, 0x2e7fcb0, 0x2e83c40:1 [ORD=20] [ID=22]

    0x2e7f4b0: <multiple use>
    0x2e83b40: i64 = Constant<8971440> [ID=2]

    0x2e7ffb0: <multiple use>
    0x2e7f8b0: <multiple use>
    0x2e7f3b0: <multiple use>
    0x2e7f4b0: <multiple use>
  0x2e7fbb0: ch,glue = X86ISD::CALL 0x2e7f4b0, 0x2e83b40, 0x2e7ffb0, 0x2e7f8b0, 0x2e7f3b0, 0x2e7f4b0:1 [ORD=20] [ID=23]

    0x2e7fbb0: <multiple use>
    0x2e7f9b0: <multiple use>
    0x2e7f9b0: <multiple use>
    0x2e7fbb0: <multiple use>
  0x2e7f7b0: ch,glue = callseq_end 0x2e7fbb0, 0x2e7f9b0, 0x2e7f9b0, 0x2e7fbb0:1 [ORD=20] [ID=24]

          0x2e7f7b0: <multiple use>
          0x2e801b0: i64 = Register %RAX [ID=9]

          0x2e7f7b0: <multiple use>
        0x2e7f5b0: i64,ch,glue = CopyFromReg 0x2e7f7b0, 0x2e801b0, 0x2e7f7b0:1 [ORD=20] [ID=25]

        0x2e7fdb0: <multiple use>
        0x2e7f6b0: i64 = FrameIndex<0> [ID=10]

        0x2e83e40: i64 = undef [ID=11]

      0x2e83f40: ch = store 0x2e7f5b0:1, 0x2e7fdb0, 0x2e7f6b0, 0x2e83e40<ST4[%i.addr]> [ORD=22] [ID=26]

      0x2e7f9b0: <multiple use>
    0x2e84340: ch,glue = callseq_start 0x2e83f40, 0x2e7f9b0 [ORD=24] [ID=27]

    0x2e7ffb0: <multiple use>
      0x2e83d40: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=24]

    0x2e84040: i64 = X86ISD::Wrapper 0x2e83d40 [ORD=24]

  0x2e84540: ch,glue = CopyToReg 0x2e84340, 0x2e7ffb0, 0x2e84040 [ORD=24] [ID=28]

    0x2e84540: <multiple use>
    0x2e84640: <multiple use>
    0x2e7fdb0: <multiple use>
    0x2e84540: <multiple use>
  0x2e84740: ch,glue = CopyToReg 0x2e84540, 0x2e84640, 0x2e7fdb0, 0x2e84540:1 [ORD=24] [ID=29]

    0x2e84740: <multiple use>
    0x2e84840: <multiple use>
    0x2e84440: i8 = Constant<0> [ID=14]

    0x2e84740: <multiple use>
  0x2e84940: ch,glue = CopyToReg 0x2e84740, 0x2e84840, 0x2e84440, 0x2e84740:1 [ORD=24] [ID=30]

    0x2e84940: <multiple use>
      0x2e84240: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=24]

    0x2ea9c80: i64 = X86ISD::Wrapper 0x2e84240 [ORD=24]

    0x2e7ffb0: <multiple use>
    0x2e84640: <multiple use>
    0x2e84840: <multiple use>
    0x2e7f3b0: <multiple use>
    0x2e84940: <multiple use>
  0x2ea9680: ch,glue = X86ISD::CALL 0x2e84940, 0x2ea9c80, 0x2e7ffb0, 0x2e84640, 0x2e84840, 0x2e7f3b0, 0x2e84940:1 [ORD=24] [ID=31]

    0x2ea9680: <multiple use>
    0x2e7f9b0: <multiple use>
    0x2e7f9b0: <multiple use>
    0x2ea9680: <multiple use>
  0x2ea9780: ch,glue = callseq_end 0x2ea9680, 0x2e7f9b0, 0x2e7f9b0, 0x2ea9680:1 [ORD=24] [ID=32]

      0x2ea9780: <multiple use>
      0x2ea9880: i32 = Register %EAX [ID=17]

      0x2ea9780: <multiple use>
    0x2ea9980: i32,ch,glue = CopyFromReg 0x2ea9780, 0x2ea9880, 0x2ea9780:1 [ORD=24] [ID=33]

    0x2ea9a80: i16 = TargetConstant<0> [ID=18]

  0x2ea9b80: ch = X86ISD::RET_FLAG 0x2ea9980:1, 0x2ea9a80 [ORD=25] [ID=34]


Optimized legalized selection DAG: BB#0 'func:entry'
SelectionDAG has 37 nodes:
  0x2e5c478: ch = EntryToken [ID=0]

  0x2e7f9b0: i64 = TargetConstant<0> [ID=5]

  0x2e7ffb0: i64 = Register %RDI [ID=6]

  0x2e7f8b0: i64 = Register %RSI [ID=7]

  0x2e7f3b0: Untyped = RegisterMask [ID=8]

  0x2e84640: i32 = Register %ESI [ID=15]

  0x2e84840: i8 = Register %AL [ID=16]

    0x2e5c478: <multiple use>
    0x2e7fab0: i32 = Register %vreg0 [ID=1]

  0x2e7fdb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=16] [ID=19]

      0x2e5c478: <multiple use>
      0x2e7f9b0: <multiple use>
    0x2e800b0: ch,glue = callseq_start 0x2e5c478, 0x2e7f9b0 [ORD=20] [ID=20]

    0x2e7ffb0: <multiple use>
    0x2e7feb0: i64 = Constant<48717472> [ID=3]

  0x2e83c40: ch,glue = CopyToReg 0x2e800b0, 0x2e7ffb0, 0x2e7feb0 [ORD=20] [ID=21]

    0x2e83c40: <multiple use>
    0x2e7f8b0: <multiple use>
    0x2e7fcb0: i64 = Constant<48397984> [ID=4]

    0x2e83c40: <multiple use>
  0x2e7f4b0: ch,glue = CopyToReg 0x2e83c40, 0x2e7f8b0, 0x2e7fcb0, 0x2e83c40:1 [ORD=20] [ID=22]

    0x2e7f4b0: <multiple use>
    0x2e83b40: i64 = Constant<8971440> [ID=2]

    0x2e7ffb0: <multiple use>
    0x2e7f8b0: <multiple use>
    0x2e7f3b0: <multiple use>
    0x2e7f4b0: <multiple use>
  0x2e7fbb0: ch,glue = X86ISD::CALL 0x2e7f4b0, 0x2e83b40, 0x2e7ffb0, 0x2e7f8b0, 0x2e7f3b0, 0x2e7f4b0:1 [ORD=20] [ID=23]

    0x2e7fbb0: <multiple use>
    0x2e7f9b0: <multiple use>
    0x2e7f9b0: <multiple use>
    0x2e7fbb0: <multiple use>
  0x2e7f7b0: ch,glue = callseq_end 0x2e7fbb0, 0x2e7f9b0, 0x2e7f9b0, 0x2e7fbb0:1 [ORD=20] [ID=24]

          0x2e7f7b0: <multiple use>
          0x2e801b0: i64 = Register %RAX [ID=9]

          0x2e7f7b0: <multiple use>
        0x2e7f5b0: i64,ch,glue = CopyFromReg 0x2e7f7b0, 0x2e801b0, 0x2e7f7b0:1 [ORD=20] [ID=25]

        0x2e7fdb0: <multiple use>
        0x2e7f6b0: i64 = FrameIndex<0> [ID=10]

        0x2e83e40: i64 = undef [ID=11]

      0x2e83f40: ch = store 0x2e7f5b0:1, 0x2e7fdb0, 0x2e7f6b0, 0x2e83e40<ST4[%i.addr]> [ORD=22] [ID=26]

      0x2e7f9b0: <multiple use>
    0x2e84340: ch,glue = callseq_start 0x2e83f40, 0x2e7f9b0 [ORD=24] [ID=27]

    0x2e7ffb0: <multiple use>
      0x2e83d40: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=24]

    0x2e84040: i64 = X86ISD::Wrapper 0x2e83d40 [ORD=24]

  0x2e84540: ch,glue = CopyToReg 0x2e84340, 0x2e7ffb0, 0x2e84040 [ORD=24] [ID=28]

    0x2e84540: <multiple use>
    0x2e84640: <multiple use>
    0x2e7fdb0: <multiple use>
    0x2e84540: <multiple use>
  0x2e84740: ch,glue = CopyToReg 0x2e84540, 0x2e84640, 0x2e7fdb0, 0x2e84540:1 [ORD=24] [ID=29]

    0x2e84740: <multiple use>
    0x2e84840: <multiple use>
    0x2e84440: i8 = Constant<0> [ID=14]

    0x2e84740: <multiple use>
  0x2e84940: ch,glue = CopyToReg 0x2e84740, 0x2e84840, 0x2e84440, 0x2e84740:1 [ORD=24] [ID=30]

    0x2e84940: <multiple use>
      0x2e84240: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=24]

    0x2ea9c80: i64 = X86ISD::Wrapper 0x2e84240 [ORD=24]

    0x2e7ffb0: <multiple use>
    0x2e84640: <multiple use>
    0x2e84840: <multiple use>
    0x2e7f3b0: <multiple use>
    0x2e84940: <multiple use>
  0x2ea9680: ch,glue = X86ISD::CALL 0x2e84940, 0x2ea9c80, 0x2e7ffb0, 0x2e84640, 0x2e84840, 0x2e7f3b0, 0x2e84940:1 [ORD=24] [ID=31]

    0x2ea9680: <multiple use>
    0x2e7f9b0: <multiple use>
    0x2e7f9b0: <multiple use>
    0x2ea9680: <multiple use>
  0x2ea9780: ch,glue = callseq_end 0x2ea9680, 0x2e7f9b0, 0x2e7f9b0, 0x2ea9680:1 [ORD=24] [ID=32]

      0x2ea9780: <multiple use>
      0x2ea9880: i32 = Register %EAX [ID=17]

      0x2ea9780: <multiple use>
    0x2ea9980: i32,ch,glue = CopyFromReg 0x2ea9780, 0x2ea9880, 0x2ea9780:1 [ORD=24] [ID=33]

    0x2ea9a80: i16 = TargetConstant<0> [ID=18]

  0x2ea9b80: ch = X86ISD::RET_FLAG 0x2ea9980:1, 0x2ea9a80 [ORD=25] [ID=34]


===== Instruction selection begins: BB#0 'entry'
Selecting: 0x2ea9b80: ch = X86ISD::RET_FLAG 0x2ea9980:1, 0x2ea9a80 [ORD=25] [ID=36]

ISEL: Starting pattern match on root node: 0x2ea9b80: ch = X86ISD::RET_FLAG 0x2ea9980:1, 0x2ea9a80 [ORD=25] [ID=36]

  Initial Opcode index to 93235
  Morphed node: 0x2ea9b80: ch = RET 0x2ea9980:1 [ORD=25]

ISEL: Match complete!
=> 0x2ea9b80: ch = RET 0x2ea9980:1 [ORD=25]

Selecting: 0x2ea9980: i32,ch,glue = CopyFromReg 0x2ea9780, 0x2ea9880, 0x2ea9780:1 [ORD=24] [ID=35]

=> 0x2ea9980: i32,ch,glue = CopyFromReg 0x2ea9780, 0x2ea9880, 0x2ea9780:1 [ORD=24]

Selecting: 0x2ea9780: ch,glue = callseq_end 0x2ea9680, 0x2e7f9b0, 0x2e7f9b0, 0x2ea9680:1 [ORD=24] [ID=34]

ISEL: Starting pattern match on root node: 0x2ea9780: ch,glue = callseq_end 0x2ea9680, 0x2e7f9b0, 0x2e7f9b0, 0x2ea9680:1 [ORD=24] [ID=34]

  Initial Opcode index to 92907
  Skipped scope entry (due to false predicate) at index 92925, continuing at 92937
  Morphed node: 0x2ea9780: i64,ch,glue = ADJCALLSTACKUP64 0x2e7f9b0, 0x2e7f9b0, 0x2ea9680, 0x2ea9680:1 [ORD=24]

ISEL: Match complete!
=> 0x2ea9780: i64,ch,glue = ADJCALLSTACKUP64 0x2e7f9b0, 0x2e7f9b0, 0x2ea9680, 0x2ea9680:1 [ORD=24]

Selecting: 0x2ea9680: ch,glue = X86ISD::CALL 0x2e84940, 0x2ea9c80, 0x2e7ffb0, 0x2e84640, 0x2e84840, 0x2e7f3b0, 0x2e84940:1 [ORD=24] [ID=33]

ISEL: Starting pattern match on root node: 0x2ea9680: ch,glue = X86ISD::CALL 0x2e84940, 0x2ea9c80, 0x2e7ffb0, 0x2e84640, 0x2e84840, 0x2e7f3b0, 0x2e84940:1 [ORD=24] [ID=33]

  Initial Opcode index to 69884
  Match failed at index 69890
  Continuing at 69951
  Match failed at index 69957
  Continuing at 70031
  Match failed at index 70032
  Continuing at 70044
  Morphed node: 0x2ea9680: ch,glue = CALL64r 0x2ea9c80, 0x2e7ffb0, 0x2e84640, 0x2e84840, 0x2e7f3b0, 0x2e84940, 0x2e84940:1 [ORD=24]

ISEL: Match complete!
=> 0x2ea9680: ch,glue = CALL64r 0x2ea9c80, 0x2e7ffb0, 0x2e84640, 0x2e84840, 0x2e7f3b0, 0x2e84940, 0x2e84940:1 [ORD=24]

Selecting: 0x2e84940: ch,glue = CopyToReg 0x2e84740, 0x2e84840, 0x2e84440, 0x2e84740:1 [ORD=24] [ID=32]

=> 0x2e84940: ch,glue = CopyToReg 0x2e84740, 0x2e84840, 0x2e84440, 0x2e84740:1 [ORD=24]

Selecting: 0x2e84740: ch,glue = CopyToReg 0x2e84540, 0x2e84640, 0x2e7fdb0, 0x2e84540:1 [ORD=24] [ID=31]

=> 0x2e84740: ch,glue = CopyToReg 0x2e84540, 0x2e84640, 0x2e7fdb0, 0x2e84540:1 [ORD=24]

Selecting: 0x2e84540: ch,glue = CopyToReg 0x2e84340, 0x2e7ffb0, 0x2e84040 [ORD=24] [ID=30]

=> 0x2e84540: ch,glue = CopyToReg 0x2e84340, 0x2e7ffb0, 0x2e84040 [ORD=24]

Selecting: 0x2e84340: ch,glue = callseq_start 0x2e83f40, 0x2e7f9b0 [ORD=24] [ID=29]

ISEL: Starting pattern match on root node: 0x2e84340: ch,glue = callseq_start 0x2e83f40, 0x2e7f9b0 [ORD=24] [ID=29]

  Initial Opcode index to 95380
  Skipped scope entry (due to false predicate) at index 95390, continuing at 95401
  Morphed node: 0x2e84340: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7f9b0, 0x2e83f40 [ORD=24]

ISEL: Match complete!
=> 0x2e84340: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7f9b0, 0x2e83f40 [ORD=24]

Selecting: 0x2e83f40: ch = store 0x2e7f5b0:1, 0x2e7fdb0, 0x2e7f6b0, 0x2e83e40<ST4[%i.addr]> [ORD=22] [ID=28]

ISEL: Starting pattern match on root node: 0x2e83f40: ch = store 0x2e7f5b0:1, 0x2e7fdb0, 0x2e7f6b0, 0x2e83e40<ST4[%i.addr]> [ORD=22] [ID=28]

  Initial Opcode index to 5
  Skipped scope entry (due to false predicate) at index 13, continuing at 58
  Skipped scope entry (due to false predicate) at index 59, continuing at 104
  Skipped scope entry (due to false predicate) at index 105, continuing at 188
  Skipped scope entry (due to false predicate) at index 189, continuing at 212
  Skipped scope entry (due to false predicate) at index 213, continuing at 236
  Skipped scope entry (due to false predicate) at index 237, continuing at 260
  Match failed at index 264
  Continuing at 284
  Match failed at index 285
  Continuing at 308
  Continuing at 309
  Match failed at index 313
  Continuing at 10708
  Match failed at index 10713
  Continuing at 11131
  Match failed at index 11135
  Continuing at 11509
  Match failed at index 11513
  Continuing at 11624
  Match failed at index 11628
  Continuing at 11859
  Skipped scope entry (due to false predicate) at index 11864, continuing at 11950
  Skipped scope entry (due to false predicate) at index 11951, continuing at 12064
  Skipped scope entry (due to false predicate) at index 12065, continuing at 12137
  Skipped scope entry (due to false predicate) at index 12138, continuing at 12161
  Skipped scope entry (due to false predicate) at index 12162, continuing at 12185
MatchAddress: X86ISelAddressMode 0x7fff29e7b3f0
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
  Morphed node: 0x2e83f40: ch = MOV32mr 0x2e84140, 0x2ea9d80, 0x2ea9a80, 0x2ea9e80, 0x2ea9f80, 0x2e7fdb0, 0x2e7f5b0:1<Mem:ST4[%i.addr]> [ORD=22]

ISEL: Match complete!
=> 0x2e83f40: ch = MOV32mr 0x2e84140, 0x2ea9d80, 0x2ea9a80, 0x2ea9e80, 0x2ea9f80, 0x2e7fdb0, 0x2e7f5b0:1<Mem:ST4[%i.addr]> [ORD=22]

Selecting: 0x2e7f5b0: i64,ch,glue = CopyFromReg 0x2e7f7b0, 0x2e801b0, 0x2e7f7b0:1 [ORD=20] [ID=27]

=> 0x2e7f5b0: i64,ch,glue = CopyFromReg 0x2e7f7b0, 0x2e801b0, 0x2e7f7b0:1 [ORD=20]

Selecting: 0x2e7f7b0: ch,glue = callseq_end 0x2e7fbb0, 0x2e7f9b0, 0x2e7f9b0, 0x2e7fbb0:1 [ORD=20] [ID=26]

ISEL: Starting pattern match on root node: 0x2e7f7b0: ch,glue = callseq_end 0x2e7fbb0, 0x2e7f9b0, 0x2e7f9b0, 0x2e7fbb0:1 [ORD=20] [ID=26]

  Initial Opcode index to 92907
  Skipped scope entry (due to false predicate) at index 92925, continuing at 92937
  Morphed node: 0x2e7f7b0: i64,ch,glue = ADJCALLSTACKUP64 0x2e7f9b0, 0x2e7f9b0, 0x2e7fbb0, 0x2e7fbb0:1 [ORD=20]

ISEL: Match complete!
=> 0x2e7f7b0: i64,ch,glue = ADJCALLSTACKUP64 0x2e7f9b0, 0x2e7f9b0, 0x2e7fbb0, 0x2e7fbb0:1 [ORD=20]

Selecting: 0x2e7fbb0: ch,glue = X86ISD::CALL 0x2e7f4b0, 0x2e83b40, 0x2e7ffb0, 0x2e7f8b0, 0x2e7f3b0, 0x2e7f4b0:1 [ORD=20] [ID=25]

ISEL: Starting pattern match on root node: 0x2e7fbb0: ch,glue = X86ISD::CALL 0x2e7f4b0, 0x2e83b40, 0x2e7ffb0, 0x2e7f8b0, 0x2e7f3b0, 0x2e7f4b0:1 [ORD=20] [ID=25]

  Initial Opcode index to 69884
  Match failed at index 69890
  Continuing at 69951
  OpcodeSwitch from 69957 to 70015
  Match failed at index 70015
  Continuing at 70031
  Match failed at index 70032
  Continuing at 70044
  Morphed node: 0x2e7fbb0: ch,glue = CALL64r 0x2e83b40, 0x2e7ffb0, 0x2e7f8b0, 0x2e7f3b0, 0x2e7f4b0, 0x2e7f4b0:1 [ORD=20]

ISEL: Match complete!
=> 0x2e7fbb0: ch,glue = CALL64r 0x2e83b40, 0x2e7ffb0, 0x2e7f8b0, 0x2e7f3b0, 0x2e7f4b0, 0x2e7f4b0:1 [ORD=20]

Selecting: 0x2e7f4b0: ch,glue = CopyToReg 0x2e83c40, 0x2e7f8b0, 0x2e7fcb0, 0x2e83c40:1 [ORD=20] [ID=24]

=> 0x2e7f4b0: ch,glue = CopyToReg 0x2e83c40, 0x2e7f8b0, 0x2e7fcb0, 0x2e83c40:1 [ORD=20]

Selecting: 0x2e83c40: ch,glue = CopyToReg 0x2e800b0, 0x2e7ffb0, 0x2e7feb0 [ORD=20] [ID=23]

=> 0x2e83c40: ch,glue = CopyToReg 0x2e800b0, 0x2e7ffb0, 0x2e7feb0 [ORD=20]

Selecting: 0x2ea9c80: i64 = X86ISD::Wrapper 0x2e84240 [ORD=24] [ID=22]

ISEL: Starting pattern match on root node: 0x2ea9c80: i64 = X86ISD::Wrapper 0x2e84240 [ORD=24] [ID=22]

  Initial Opcode index to 94787
  Match failed at index 94792
  Continuing at 94819
  OpcodeSwitch from 94824 to 94938
  TypeSwitch[i64] from 94939 to 94952
  Morphed node: 0x2ea9c80: i64 = MOV64ri 0x2e84240 [ORD=24]

ISEL: Match complete!
=> 0x2ea9c80: i64 = MOV64ri 0x2e84240 [ORD=24]

Selecting: 0x2e84040: i64 = X86ISD::Wrapper 0x2e83d40 [ORD=24] [ID=21]

ISEL: Starting pattern match on root node: 0x2e84040: i64 = X86ISD::Wrapper 0x2e83d40 [ORD=24] [ID=21]

  Initial Opcode index to 94787
  Match failed at index 94792
  Continuing at 94819
  OpcodeSwitch from 94824 to 94938
  TypeSwitch[i64] from 94939 to 94952
  Morphed node: 0x2e84040: i64 = MOV64ri 0x2e83d40 [ORD=24]

ISEL: Match complete!
=> 0x2e84040: i64 = MOV64ri 0x2e83d40 [ORD=24]

Selecting: 0x2e800b0: ch,glue = callseq_start 0x2e5c478, 0x2e7f9b0 [ORD=20] [ID=20]

ISEL: Starting pattern match on root node: 0x2e800b0: ch,glue = callseq_start 0x2e5c478, 0x2e7f9b0 [ORD=20] [ID=20]

  Initial Opcode index to 95380
  Skipped scope entry (due to false predicate) at index 95390, continuing at 95401
  Morphed node: 0x2e800b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7f9b0, 0x2e5c478 [ORD=20]

ISEL: Match complete!
=> 0x2e800b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7f9b0, 0x2e5c478 [ORD=20]

Selecting: 0x2e7fdb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=16] [ID=19]

=> 0x2e7fdb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=16]

Selecting: 0x2e84240: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=24] [ID=18]

=> 0x2e84240: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=24]

Selecting: 0x2e83d40: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=24] [ID=17]

=> 0x2e83d40: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=24]

Selecting: 0x2ea9880: i32 = Register %EAX [ID=15]

=> 0x2ea9880: i32 = Register %EAX

Selecting: 0x2e84840: i8 = Register %AL [ID=14]

=> 0x2e84840: i8 = Register %AL

Selecting: 0x2e84640: i32 = Register %ESI [ID=13]

=> 0x2e84640: i32 = Register %ESI

Selecting: 0x2e84440: i8 = Constant<0> [ID=12]

ISEL: Starting pattern match on root node: 0x2e84440: i8 = Constant<0> [ID=12]

  Initial Opcode index to 82786
  Match failed at index 82790
  Continuing at 82816
  Match failed at index 82818
  Continuing at 82847
  TypeSwitch[i8] from 82850 to 82863
  Created node: 0x2e7f6b0: i32,i32 = MOV32r0

  Morphed node: 0x2e84440: i8 = EXTRACT_SUBREG 0x2e7f6b0, 0x2e83e40

ISEL: Match complete!
=> 0x2e84440: i8 = EXTRACT_SUBREG 0x2e7f6b0, 0x2e83e40

Selecting: 0x2e801b0: i64 = Register %RAX [ID=9]

=> 0x2e801b0: i64 = Register %RAX

Selecting: 0x2e7f3b0: Untyped = RegisterMask [ID=8]

=> 0x2e7f3b0: Untyped = RegisterMask

Selecting: 0x2e7f8b0: i64 = Register %RSI [ID=7]

=> 0x2e7f8b0: i64 = Register %RSI

Selecting: 0x2e7ffb0: i64 = Register %RDI [ID=6]

=> 0x2e7ffb0: i64 = Register %RDI

Selecting: 0x2e7f9b0: i64 = TargetConstant<0> [ID=5]

=> 0x2e7f9b0: i64 = TargetConstant<0>

Selecting: 0x2e7fcb0: i64 = Constant<48397984> [ID=4]

ISEL: Starting pattern match on root node: 0x2e7fcb0: i64 = Constant<48397984> [ID=4]

  Initial Opcode index to 82786
  Skipped scope entry (due to false predicate) at index 82788, continuing at 82816
  Created node: 0x2eaa180: i32 = MOV32ri64 0x2eaa080

  Morphed node: 0x2e7fcb0: i64 = SUBREG_TO_REG 0x2e7f9b0, 0x2eaa180, 0x2eaa280

ISEL: Match complete!
=> 0x2e7fcb0: i64 = SUBREG_TO_REG 0x2e7f9b0, 0x2eaa180, 0x2eaa280

Selecting: 0x2e7feb0: i64 = Constant<48717472> [ID=3]

ISEL: Starting pattern match on root node: 0x2e7feb0: i64 = Constant<48717472> [ID=3]

  Initial Opcode index to 82786
  Skipped scope entry (due to false predicate) at index 82788, continuing at 82816
  Created node: 0x2eaa480: i32 = MOV32ri64 0x2eaa380

  Morphed node: 0x2e7feb0: i64 = SUBREG_TO_REG 0x2e7f9b0, 0x2eaa480, 0x2eaa280

ISEL: Match complete!
=> 0x2e7feb0: i64 = SUBREG_TO_REG 0x2e7f9b0, 0x2eaa480, 0x2eaa280

Selecting: 0x2e83b40: i64 = Constant<8971440> [ID=2]

ISEL: Starting pattern match on root node: 0x2e83b40: i64 = Constant<8971440> [ID=2]

  Initial Opcode index to 82786
  Skipped scope entry (due to false predicate) at index 82788, continuing at 82816
  Created node: 0x2eaa9d0: i32 = MOV32ri64 0x2eaa8d0

  Morphed node: 0x2e83b40: i64 = SUBREG_TO_REG 0x2e7f9b0, 0x2eaa9d0, 0x2eaa280

ISEL: Match complete!
=> 0x2e83b40: i64 = SUBREG_TO_REG 0x2e7f9b0, 0x2eaa9d0, 0x2eaa280

Selecting: 0x2e7fab0: i32 = Register %vreg0 [ID=1]

=> 0x2e7fab0: i32 = Register %vreg0

Selecting: 0x2e5c478: ch = EntryToken [ID=0]

=> 0x2e5c478: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: BB#0 'func:entry'
SelectionDAG has 48 nodes:
  0x2e5c478: ch = EntryToken

  0x2e7f9b0: i64 = TargetConstant<0>

  0x2e7ffb0: i64 = Register %RDI

  0x2e7f8b0: i64 = Register %RSI

  0x2e7f3b0: Untyped = RegisterMask

  0x2e84640: i32 = Register %ESI

  0x2e84840: i8 = Register %AL

    0x2e5c478: <multiple use>
    0x2e7fab0: i32 = Register %vreg0

  0x2e7fdb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=16]

      0x2e7f9b0: <multiple use>
      0x2e5c478: <multiple use>
    0x2e800b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7f9b0, 0x2e5c478 [ORD=20]

    0x2e7ffb0: <multiple use>
      0x2e7f9b0: <multiple use>
        0x2eaa380: i64 = TargetConstant<48717472>

      0x2eaa480: i32 = MOV32ri64 0x2eaa380

      0x2eaa280: <multiple use>
    0x2e7feb0: i64 = SUBREG_TO_REG 0x2e7f9b0, 0x2eaa480, 0x2eaa280

  0x2e83c40: ch,glue = CopyToReg 0x2e800b0:1, 0x2e7ffb0, 0x2e7feb0 [ORD=20]

    0x2e83c40: <multiple use>
    0x2e7f8b0: <multiple use>
      0x2e7f9b0: <multiple use>
        0x2eaa080: i64 = TargetConstant<48397984>

      0x2eaa180: i32 = MOV32ri64 0x2eaa080

      0x2eaa280: <multiple use>
    0x2e7fcb0: i64 = SUBREG_TO_REG 0x2e7f9b0, 0x2eaa180, 0x2eaa280

    0x2e83c40: <multiple use>
  0x2e7f4b0: ch,glue = CopyToReg 0x2e83c40, 0x2e7f8b0, 0x2e7fcb0, 0x2e83c40:1 [ORD=20]

      0x2e7f9b0: <multiple use>
        0x2eaa8d0: i64 = TargetConstant<8971440>

      0x2eaa9d0: i32 = MOV32ri64 0x2eaa8d0

      0x2eaa280: <multiple use>
    0x2e83b40: i64 = SUBREG_TO_REG 0x2e7f9b0, 0x2eaa9d0, 0x2eaa280

    0x2e7ffb0: <multiple use>
    0x2e7f8b0: <multiple use>
    0x2e7f3b0: <multiple use>
    0x2e7f4b0: <multiple use>
    0x2e7f4b0: <multiple use>
  0x2e7fbb0: ch,glue = CALL64r 0x2e83b40, 0x2e7ffb0, 0x2e7f8b0, 0x2e7f3b0, 0x2e7f4b0, 0x2e7f4b0:1 [ORD=20]

    0x2e7f9b0: <multiple use>
    0x2e7f9b0: <multiple use>
    0x2e7fbb0: <multiple use>
    0x2e7fbb0: <multiple use>
  0x2e7f7b0: i64,ch,glue = ADJCALLSTACKUP64 0x2e7f9b0, 0x2e7f9b0, 0x2e7fbb0, 0x2e7fbb0:1 [ORD=20]

      0x2e7f9b0: <multiple use>
        0x2e84140: i64 = TargetFrameIndex<0>

        0x2ea9d80: i8 = TargetConstant<1>

        0x2ea9a80: i64 = Register %noreg

        0x2ea9e80: i32 = TargetConstant<0>

        0x2ea9f80: i32 = Register %noreg

        0x2e7fdb0: <multiple use>
          0x2e7f7b0: <multiple use>
          0x2e801b0: i64 = Register %RAX

          0x2e7f7b0: <multiple use>
        0x2e7f5b0: i64,ch,glue = CopyFromReg 0x2e7f7b0:1, 0x2e801b0, 0x2e7f7b0:2 [ORD=20]

      0x2e83f40: ch = MOV32mr 0x2e84140, 0x2ea9d80, 0x2ea9a80, 0x2ea9e80, 0x2ea9f80, 0x2e7fdb0, 0x2e7f5b0:1<Mem:ST4[%i.addr]> [ORD=22]

    0x2e84340: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7f9b0, 0x2e83f40 [ORD=24]

    0x2e7ffb0: <multiple use>
      0x2e83d40: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=24]

    0x2e84040: i64 = MOV64ri 0x2e83d40 [ORD=24]

  0x2e84540: ch,glue = CopyToReg 0x2e84340:1, 0x2e7ffb0, 0x2e84040 [ORD=24]

    0x2e84540: <multiple use>
    0x2e84640: <multiple use>
    0x2e7fdb0: <multiple use>
    0x2e84540: <multiple use>
  0x2e84740: ch,glue = CopyToReg 0x2e84540, 0x2e84640, 0x2e7fdb0, 0x2e84540:1 [ORD=24]

    0x2e84740: <multiple use>
    0x2e84840: <multiple use>
      0x2e7f6b0: i32,i32 = MOV32r0

      0x2e83e40: i32 = TargetConstant<1>

    0x2e84440: i8 = EXTRACT_SUBREG 0x2e7f6b0, 0x2e83e40

    0x2e84740: <multiple use>
  0x2e84940: ch,glue = CopyToReg 0x2e84740, 0x2e84840, 0x2e84440, 0x2e84740:1 [ORD=24]

      0x2e84240: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=24]

    0x2ea9c80: i64 = MOV64ri 0x2e84240 [ORD=24]

    0x2e7ffb0: <multiple use>
    0x2e84640: <multiple use>
    0x2e84840: <multiple use>
    0x2e7f3b0: <multiple use>
    0x2e84940: <multiple use>
    0x2e84940: <multiple use>
  0x2ea9680: ch,glue = CALL64r 0x2ea9c80, 0x2e7ffb0, 0x2e84640, 0x2e84840, 0x2e7f3b0, 0x2e84940, 0x2e84940:1 [ORD=24]

    0x2e7f9b0: <multiple use>
    0x2e7f9b0: <multiple use>
    0x2ea9680: <multiple use>
    0x2ea9680: <multiple use>
  0x2ea9780: i64,ch,glue = ADJCALLSTACKUP64 0x2e7f9b0, 0x2e7f9b0, 0x2ea9680, 0x2ea9680:1 [ORD=24]

  0x2eaa280: i32 = TargetConstant<4>

      0x2ea9780: <multiple use>
      0x2ea9880: i32 = Register %EAX

      0x2ea9780: <multiple use>
    0x2ea9980: i32,ch,glue = CopyFromReg 0x2ea9780:1, 0x2ea9880, 0x2ea9780:2 [ORD=24]

  0x2ea9b80: ch = RET 0x2ea9980:1 [ORD=25]


********** List Scheduling BB#0 'entry' **********
SU(0): 0x2ea9b80: ch = RET 0x2ea9980:1 [ORD=25] [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 0
  Predecessors:
   ch  SU(1): Latency=1

SU(1): 0x2ea9980: i32,ch,glue = CopyFromReg 0x2ea9780:1, 0x2ea9880, 0x2ea9780:2 [ORD=24] [ID=1]

    0x2e84540: ch,glue = CopyToReg 0x2e84340:1, 0x2e7ffb0, 0x2e84040 [ORD=24] [ID=1]

    0x2e84740: ch,glue = CopyToReg 0x2e84540, 0x2e84640, 0x2e7fdb0, 0x2e84540:1 [ORD=24] [ID=1]

    0x2e84940: ch,glue = CopyToReg 0x2e84740, 0x2e84840, 0x2e84440, 0x2e84740:1 [ORD=24] [ID=1]

    0x2ea9680: ch,glue = CALL64r 0x2ea9c80, 0x2e7ffb0, 0x2e84640, 0x2e84840, 0x2e7f3b0, 0x2e84940, 0x2e84940:1 [ORD=24] [ID=1]

    0x2ea9780: i64,ch,glue = ADJCALLSTACKUP64 0x2e7f9b0, 0x2e7f9b0, 0x2ea9680, 0x2ea9680:1 [ORD=24] [ID=1]

  # preds left       : 5
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 1
  Predecessors:
   val SU(16): Latency=1
   val SU(2): Latency=1
   val SU(4): Latency=1
   ch  SU(6): Latency=1
   val SU(5): Latency=1
  Successors:
   ch  SU(0): Latency=1

SU(2): 0x2e84440: i8 = EXTRACT_SUBREG 0x2e7f6b0, 0x2e83e40 [ID=2]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
   val SU(3): Latency=1
  Successors:
   val SU(1): Latency=1

SU(3): 0x2e7f6b0: i32,i32 = MOV32r0 [ID=3]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
   val SU(2): Latency=1

SU(4): 0x2e7fdb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=16] [ID=4]

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
   val SU(1): Latency=1
   val SU(7): Latency=1

SU(5): 0x2e84040: i64 = MOV64ri 0x2e83d40 [ORD=24] [ID=5]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
   val SU(1): Latency=1

SU(6): 0x2e84340: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7f9b0, 0x2e83f40 [ORD=24] [ID=6]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 2
  Predecessors:
   ch  SU(7): Latency=1
  Successors:
   ch  SU(1): Latency=1

SU(7): 0x2e83f40: ch = MOV32mr 0x2e84140, 0x2ea9d80, 0x2ea9a80, 0x2ea9e80, 0x2ea9f80, 0x2e7fdb0, 0x2e7f5b0:1<Mem:ST4[%i.addr]> [ORD=22] [ID=7]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 3
  Predecessors:
   val SU(4): Latency=1
   ch  SU(8): Latency=1
  Successors:
   ch  SU(6): Latency=1

SU(8): 0x2e7f5b0: i64,ch,glue = CopyFromReg 0x2e7f7b0:1, 0x2e801b0, 0x2e7f7b0:2 [ORD=20] [ID=8]

    0x2e83c40: ch,glue = CopyToReg 0x2e800b0:1, 0x2e7ffb0, 0x2e7feb0 [ORD=20] [ID=8]

    0x2e7f4b0: ch,glue = CopyToReg 0x2e83c40, 0x2e7f8b0, 0x2e7fcb0, 0x2e83c40:1 [ORD=20] [ID=8]

    0x2e7fbb0: ch,glue = CALL64r 0x2e83b40, 0x2e7ffb0, 0x2e7f8b0, 0x2e7f3b0, 0x2e7f4b0, 0x2e7f4b0:1 [ORD=20] [ID=8]

    0x2e7f7b0: i64,ch,glue = ADJCALLSTACKUP64 0x2e7f9b0, 0x2e7f9b0, 0x2e7fbb0, 0x2e7fbb0:1 [ORD=20] [ID=8]

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 4
  Predecessors:
   val SU(14): Latency=1
   val SU(9): Latency=1
   ch  SU(13): Latency=1
   val SU(11): Latency=1
  Successors:
   ch  SU(7): Latency=1

SU(9): 0x2e7fcb0: i64 = SUBREG_TO_REG 0x2e7f9b0, 0x2eaa180, 0x2eaa280 [ID=9]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
   val SU(10): Latency=1
  Successors:
   val SU(8): Latency=1

SU(10): 0x2eaa180: i32 = MOV32ri64 0x2eaa080 [ID=10]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
   val SU(9): Latency=1

SU(11): 0x2e7feb0: i64 = SUBREG_TO_REG 0x2e7f9b0, 0x2eaa480, 0x2eaa280 [ID=11]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
   val SU(12): Latency=1
  Successors:
   val SU(8): Latency=1

SU(12): 0x2eaa480: i32 = MOV32ri64 0x2eaa380 [ID=12]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
   val SU(11): Latency=1

SU(13): 0x2e800b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7f9b0, 0x2e5c478 [ORD=20] [ID=13]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
   ch  SU(8): Latency=1

SU(14): 0x2e83b40: i64 = SUBREG_TO_REG 0x2e7f9b0, 0x2eaa9d0, 0x2eaa280 [ID=14]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
   val SU(15): Latency=1
  Successors:
   val SU(8): Latency=1

SU(15): 0x2eaa9d0: i32 = MOV32ri64 0x2eaa8d0 [ID=15]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
   val SU(14): Latency=1

SU(16): 0x2ea9c80: i64 = MOV64ri 0x2e84240 [ORD=24] [ID=16]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
   val SU(1): Latency=1


Examining Available:
Height 0: SU(0): 0x2ea9b80: ch = RET 0x2ea9980:1 [ORD=25] [ID=0]


*** Scheduling [0]: SU(0): 0x2ea9b80: ch = RET 0x2ea9980:1 [ORD=25] [ID=0]


Examining Available:
Height 1: SU(1): 0x2ea9980: i32,ch,glue = CopyFromReg 0x2ea9780:1, 0x2ea9880, 0x2ea9780:2 [ORD=24] [ID=1]

    0x2e84540: ch,glue = CopyToReg 0x2e84340:1, 0x2e7ffb0, 0x2e84040 [ORD=24] [ID=1]

    0x2e84740: ch,glue = CopyToReg 0x2e84540, 0x2e84640, 0x2e7fdb0, 0x2e84540:1 [ORD=24] [ID=1]

    0x2e84940: ch,glue = CopyToReg 0x2e84740, 0x2e84840, 0x2e84440, 0x2e84740:1 [ORD=24] [ID=1]

    0x2ea9680: ch,glue = CALL64r 0x2ea9c80, 0x2e7ffb0, 0x2e84640, 0x2e84840, 0x2e7f3b0, 0x2e84940, 0x2e84940:1 [ORD=24] [ID=1]

    0x2ea9780: i64,ch,glue = ADJCALLSTACKUP64 0x2e7f9b0, 0x2e7f9b0, 0x2ea9680, 0x2ea9680:1 [ORD=24] [ID=1]


*** Scheduling [1]: SU(1): 0x2ea9980: i32,ch,glue = CopyFromReg 0x2ea9780:1, 0x2ea9880, 0x2ea9780:2 [ORD=24] [ID=1]

    0x2e84540: ch,glue = CopyToReg 0x2e84340:1, 0x2e7ffb0, 0x2e84040 [ORD=24] [ID=1]

    0x2e84740: ch,glue = CopyToReg 0x2e84540, 0x2e84640, 0x2e7fdb0, 0x2e84540:1 [ORD=24] [ID=1]

    0x2e84940: ch,glue = CopyToReg 0x2e84740, 0x2e84840, 0x2e84440, 0x2e84740:1 [ORD=24] [ID=1]

    0x2ea9680: ch,glue = CALL64r 0x2ea9c80, 0x2e7ffb0, 0x2e84640, 0x2e84840, 0x2e7f3b0, 0x2e84940, 0x2e84940:1 [ORD=24] [ID=1]

    0x2ea9780: i64,ch,glue = ADJCALLSTACKUP64 0x2e7f9b0, 0x2e7f9b0, 0x2ea9680, 0x2ea9680:1 [ORD=24] [ID=1]


Examining Available:
Height 2: SU(2): 0x2e84440: i8 = EXTRACT_SUBREG 0x2e7f6b0, 0x2e83e40 [ID=2]

Height 2: SU(16): 0x2ea9c80: i64 = MOV64ri 0x2e84240 [ORD=24] [ID=16]

Height 2: SU(5): 0x2e84040: i64 = MOV64ri 0x2e83d40 [ORD=24] [ID=5]

Height 2: SU(6): 0x2e84340: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7f9b0, 0x2e83f40 [ORD=24] [ID=6]


*** Scheduling [2]: SU(2): 0x2e84440: i8 = EXTRACT_SUBREG 0x2e7f6b0, 0x2e83e40 [ID=2]


Examining Available:
Height 3: SU(3): 0x2e7f6b0: i32,i32 = MOV32r0 [ID=3]

Height 2: SU(16): 0x2ea9c80: i64 = MOV64ri 0x2e84240 [ORD=24] [ID=16]

Height 2: SU(5): 0x2e84040: i64 = MOV64ri 0x2e83d40 [ORD=24] [ID=5]

Height 2: SU(6): 0x2e84340: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7f9b0, 0x2e83f40 [ORD=24] [ID=6]


*** Scheduling [3]: SU(3): 0x2e7f6b0: i32,i32 = MOV32r0 [ID=3]


Examining Available:
Height 2: SU(16): 0x2ea9c80: i64 = MOV64ri 0x2e84240 [ORD=24] [ID=16]

Height 2: SU(5): 0x2e84040: i64 = MOV64ri 0x2e83d40 [ORD=24] [ID=5]

Height 2: SU(6): 0x2e84340: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7f9b0, 0x2e83f40 [ORD=24] [ID=6]


*** Scheduling [4]: SU(16): 0x2ea9c80: i64 = MOV64ri 0x2e84240 [ORD=24] [ID=16]


Examining Available:
Height 2: SU(5): 0x2e84040: i64 = MOV64ri 0x2e83d40 [ORD=24] [ID=5]

Height 2: SU(6): 0x2e84340: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7f9b0, 0x2e83f40 [ORD=24] [ID=6]


*** Scheduling [5]: SU(5): 0x2e84040: i64 = MOV64ri 0x2e83d40 [ORD=24] [ID=5]


Examining Available:
Height 2: SU(6): 0x2e84340: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7f9b0, 0x2e83f40 [ORD=24] [ID=6]


*** Scheduling [6]: SU(6): 0x2e84340: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7f9b0, 0x2e83f40 [ORD=24] [ID=6]


Examining Available:
Height 7: SU(7): 0x2e83f40: ch = MOV32mr 0x2e84140, 0x2ea9d80, 0x2ea9a80, 0x2ea9e80, 0x2ea9f80, 0x2e7fdb0, 0x2e7f5b0:1<Mem:ST4[%i.addr]> [ORD=22] [ID=7]


*** Scheduling [7]: SU(7): 0x2e83f40: ch = MOV32mr 0x2e84140, 0x2ea9d80, 0x2ea9a80, 0x2ea9e80, 0x2ea9f80, 0x2e7fdb0, 0x2e7f5b0:1<Mem:ST4[%i.addr]> [ORD=22] [ID=7]


Examining Available:
Height 8: SU(8): 0x2e7f5b0: i64,ch,glue = CopyFromReg 0x2e7f7b0:1, 0x2e801b0, 0x2e7f7b0:2 [ORD=20] [ID=8]

    0x2e83c40: ch,glue = CopyToReg 0x2e800b0:1, 0x2e7ffb0, 0x2e7feb0 [ORD=20] [ID=8]

    0x2e7f4b0: ch,glue = CopyToReg 0x2e83c40, 0x2e7f8b0, 0x2e7fcb0, 0x2e83c40:1 [ORD=20] [ID=8]

    0x2e7fbb0: ch,glue = CALL64r 0x2e83b40, 0x2e7ffb0, 0x2e7f8b0, 0x2e7f3b0, 0x2e7f4b0, 0x2e7f4b0:1 [ORD=20] [ID=8]

    0x2e7f7b0: i64,ch,glue = ADJCALLSTACKUP64 0x2e7f9b0, 0x2e7f9b0, 0x2e7fbb0, 0x2e7fbb0:1 [ORD=20] [ID=8]

Height 8: SU(4): 0x2e7fdb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=16] [ID=4]


*** Scheduling [8]: SU(8): 0x2e7f5b0: i64,ch,glue = CopyFromReg 0x2e7f7b0:1, 0x2e801b0, 0x2e7f7b0:2 [ORD=20] [ID=8]

    0x2e83c40: ch,glue = CopyToReg 0x2e800b0:1, 0x2e7ffb0, 0x2e7feb0 [ORD=20] [ID=8]

    0x2e7f4b0: ch,glue = CopyToReg 0x2e83c40, 0x2e7f8b0, 0x2e7fcb0, 0x2e83c40:1 [ORD=20] [ID=8]

    0x2e7fbb0: ch,glue = CALL64r 0x2e83b40, 0x2e7ffb0, 0x2e7f8b0, 0x2e7f3b0, 0x2e7f4b0, 0x2e7f4b0:1 [ORD=20] [ID=8]

    0x2e7f7b0: i64,ch,glue = ADJCALLSTACKUP64 0x2e7f9b0, 0x2e7f9b0, 0x2e7fbb0, 0x2e7fbb0:1 [ORD=20] [ID=8]


Examining Available:
Height 9: SU(14): 0x2e83b40: i64 = SUBREG_TO_REG 0x2e7f9b0, 0x2eaa9d0, 0x2eaa280 [ID=14]

Height 9: SU(9): 0x2e7fcb0: i64 = SUBREG_TO_REG 0x2e7f9b0, 0x2eaa180, 0x2eaa280 [ID=9]

Height 9: SU(11): 0x2e7feb0: i64 = SUBREG_TO_REG 0x2e7f9b0, 0x2eaa480, 0x2eaa280 [ID=11]

Height 9: SU(13): 0x2e800b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7f9b0, 0x2e5c478 [ORD=20] [ID=13]

Height 8: SU(4): 0x2e7fdb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=16] [ID=4]


*** Scheduling [9]: SU(14): 0x2e83b40: i64 = SUBREG_TO_REG 0x2e7f9b0, 0x2eaa9d0, 0x2eaa280 [ID=14]


Examining Available:
Height 10: SU(15): 0x2eaa9d0: i32 = MOV32ri64 0x2eaa8d0 [ID=15]

Height 9: SU(9): 0x2e7fcb0: i64 = SUBREG_TO_REG 0x2e7f9b0, 0x2eaa180, 0x2eaa280 [ID=9]

Height 9: SU(11): 0x2e7feb0: i64 = SUBREG_TO_REG 0x2e7f9b0, 0x2eaa480, 0x2eaa280 [ID=11]

Height 9: SU(13): 0x2e800b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7f9b0, 0x2e5c478 [ORD=20] [ID=13]

Height 8: SU(4): 0x2e7fdb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=16] [ID=4]


*** Scheduling [10]: SU(15): 0x2eaa9d0: i32 = MOV32ri64 0x2eaa8d0 [ID=15]


Examining Available:
Height 9: SU(9): 0x2e7fcb0: i64 = SUBREG_TO_REG 0x2e7f9b0, 0x2eaa180, 0x2eaa280 [ID=9]

Height 9: SU(11): 0x2e7feb0: i64 = SUBREG_TO_REG 0x2e7f9b0, 0x2eaa480, 0x2eaa280 [ID=11]

Height 9: SU(13): 0x2e800b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7f9b0, 0x2e5c478 [ORD=20] [ID=13]

Height 8: SU(4): 0x2e7fdb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=16] [ID=4]


*** Scheduling [11]: SU(9): 0x2e7fcb0: i64 = SUBREG_TO_REG 0x2e7f9b0, 0x2eaa180, 0x2eaa280 [ID=9]


Examining Available:
Height 12: SU(10): 0x2eaa180: i32 = MOV32ri64 0x2eaa080 [ID=10]

Height 9: SU(11): 0x2e7feb0: i64 = SUBREG_TO_REG 0x2e7f9b0, 0x2eaa480, 0x2eaa280 [ID=11]

Height 9: SU(13): 0x2e800b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7f9b0, 0x2e5c478 [ORD=20] [ID=13]

Height 8: SU(4): 0x2e7fdb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=16] [ID=4]


*** Scheduling [12]: SU(10): 0x2eaa180: i32 = MOV32ri64 0x2eaa080 [ID=10]


Examining Available:
Height 9: SU(11): 0x2e7feb0: i64 = SUBREG_TO_REG 0x2e7f9b0, 0x2eaa480, 0x2eaa280 [ID=11]

Height 9: SU(13): 0x2e800b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7f9b0, 0x2e5c478 [ORD=20] [ID=13]

Height 8: SU(4): 0x2e7fdb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=16] [ID=4]


*** Scheduling [13]: SU(11): 0x2e7feb0: i64 = SUBREG_TO_REG 0x2e7f9b0, 0x2eaa480, 0x2eaa280 [ID=11]


Examining Available:
Height 14: SU(12): 0x2eaa480: i32 = MOV32ri64 0x2eaa380 [ID=12]

Height 9: SU(13): 0x2e800b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7f9b0, 0x2e5c478 [ORD=20] [ID=13]

Height 8: SU(4): 0x2e7fdb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=16] [ID=4]


*** Scheduling [14]: SU(12): 0x2eaa480: i32 = MOV32ri64 0x2eaa380 [ID=12]


Examining Available:
Height 9: SU(13): 0x2e800b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7f9b0, 0x2e5c478 [ORD=20] [ID=13]

Height 8: SU(4): 0x2e7fdb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=16] [ID=4]


*** Scheduling [15]: SU(13): 0x2e800b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7f9b0, 0x2e5c478 [ORD=20] [ID=13]


Examining Available:
Height 8: SU(4): 0x2e7fdb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=16] [ID=4]


*** Scheduling [16]: SU(4): 0x2e7fdb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=16] [ID=4]

*** Final schedule ***
SU(4): 0x2e7fdb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=16] [ID=4]

SU(13): 0x2e800b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7f9b0, 0x2e5c478 [ORD=20] [ID=13]

SU(12): 0x2eaa480: i32 = MOV32ri64 0x2eaa380 [ID=12]

SU(11): 0x2e7feb0: i64 = SUBREG_TO_REG 0x2e7f9b0, 0x2eaa480, 0x2eaa280 [ID=11]

SU(10): 0x2eaa180: i32 = MOV32ri64 0x2eaa080 [ID=10]

SU(9): 0x2e7fcb0: i64 = SUBREG_TO_REG 0x2e7f9b0, 0x2eaa180, 0x2eaa280 [ID=9]

SU(15): 0x2eaa9d0: i32 = MOV32ri64 0x2eaa8d0 [ID=15]

SU(14): 0x2e83b40: i64 = SUBREG_TO_REG 0x2e7f9b0, 0x2eaa9d0, 0x2eaa280 [ID=14]

SU(8): 0x2e7f5b0: i64,ch,glue = CopyFromReg 0x2e7f7b0:1, 0x2e801b0, 0x2e7f7b0:2 [ORD=20] [ID=8]

    0x2e83c40: ch,glue = CopyToReg 0x2e800b0:1, 0x2e7ffb0, 0x2e7feb0 [ORD=20] [ID=8]

    0x2e7f4b0: ch,glue = CopyToReg 0x2e83c40, 0x2e7f8b0, 0x2e7fcb0, 0x2e83c40:1 [ORD=20] [ID=8]

    0x2e7fbb0: ch,glue = CALL64r 0x2e83b40, 0x2e7ffb0, 0x2e7f8b0, 0x2e7f3b0, 0x2e7f4b0, 0x2e7f4b0:1 [ORD=20] [ID=8]

    0x2e7f7b0: i64,ch,glue = ADJCALLSTACKUP64 0x2e7f9b0, 0x2e7f9b0, 0x2e7fbb0, 0x2e7fbb0:1 [ORD=20] [ID=8]

SU(7): 0x2e83f40: ch = MOV32mr 0x2e84140, 0x2ea9d80, 0x2ea9a80, 0x2ea9e80, 0x2ea9f80, 0x2e7fdb0, 0x2e7f5b0:1<Mem:ST4[%i.addr]> [ORD=22] [ID=7]

SU(6): 0x2e84340: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7f9b0, 0x2e83f40 [ORD=24] [ID=6]

SU(5): 0x2e84040: i64 = MOV64ri 0x2e83d40 [ORD=24] [ID=5]

SU(16): 0x2ea9c80: i64 = MOV64ri 0x2e84240 [ORD=24] [ID=16]

SU(3): 0x2e7f6b0: i32,i32 = MOV32r0 [ID=3]

SU(2): 0x2e84440: i8 = EXTRACT_SUBREG 0x2e7f6b0, 0x2e83e40 [ID=2]

SU(1): 0x2ea9980: i32,ch,glue = CopyFromReg 0x2ea9780:1, 0x2ea9880, 0x2ea9780:2 [ORD=24] [ID=1]

    0x2e84540: ch,glue = CopyToReg 0x2e84340:1, 0x2e7ffb0, 0x2e84040 [ORD=24] [ID=1]

    0x2e84740: ch,glue = CopyToReg 0x2e84540, 0x2e84640, 0x2e7fdb0, 0x2e84540:1 [ORD=24] [ID=1]

    0x2e84940: ch,glue = CopyToReg 0x2e84740, 0x2e84840, 0x2e84440, 0x2e84740:1 [ORD=24] [ID=1]

    0x2ea9680: ch,glue = CALL64r 0x2ea9c80, 0x2e7ffb0, 0x2e84640, 0x2e84840, 0x2e7f3b0, 0x2e84940, 0x2e84940:1 [ORD=24] [ID=1]

    0x2ea9780: i64,ch,glue = ADJCALLSTACKUP64 0x2e7f9b0, 0x2e7f9b0, 0x2ea9680, 0x2ea9680:1 [ORD=24] [ID=1]

SU(0): 0x2ea9b80: ch = RET 0x2ea9980:1 [ORD=25] [ID=0]


Total amount of phi nodes to update: 0
# Machine code for function func: SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
48B		%vreg1<def> = MOV32ri64 48717472; GR32:%vreg1
64B		%vreg2<def> = SUBREG_TO_REG 0, %vreg1<kill>, 4; GR64:%vreg2 GR32:%vreg1
80B		%vreg3<def> = MOV32ri64 48397984; GR32:%vreg3
96B		%vreg4<def> = SUBREG_TO_REG 0, %vreg3<kill>, 4; GR64:%vreg4 GR32:%vreg3
112B		%vreg5<def> = MOV32ri64 8971440; GR32:%vreg5
128B		%vreg6<def> = SUBREG_TO_REG 0, %vreg5<kill>, 4; GR64:%vreg6 GR32:%vreg5
144B		%RDI<def> = COPY %vreg2; GR64:%vreg2
160B		%RSI<def> = COPY %vreg4; GR64:%vreg4
176B		CALL64r %vreg6<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def>; GR64:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		%vreg7<def> = COPY %RAX; GR64:%vreg7
224B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
240B		ADJCALLSTACKDOWN64 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg8<def> = MOV64ri <ga:@.str>; GR64:%vreg8
272B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
288B		%vreg10<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
304B		%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
320B		%RDI<def> = COPY %vreg8; GR64:%vreg8
336B		%ESI<def> = COPY %vreg0; GR32:%vreg0
352B		%AL<def> = COPY %vreg11; GR8:%vreg11
368B		CALL64r %vreg9<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def>; GR64:%vreg9
384B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
400B		%vreg12<def> = COPY %EAX; GR32:%vreg12
416B		RET

# End machine code for function func.

********** Stack Coloring **********
********** Function: func
Found 0 markers and 1 slots
Slot structure:
Slot #0 - 4 bytes.
Total Stack size: 4 bytes

Will not try to merge slots.
Removed 0 markers.
DeadMachineInstructionElim: DELETING: %vreg12<def> = COPY %EAX; GR32:%vreg12
DeadMachineInstructionElim: DELETING: %vreg7<def> = COPY %RAX; GR64:%vreg7
******** Pre-regalloc Machine LICM: func ********
Entering: entry
Exiting: entry
******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: func
********** PROCESS IMPLICIT DEFS **********
********** Function: func
********** REWRITING TWO-ADDR INSTRS **********
********** Function: func
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI<kill>; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
48B		%vreg1<def> = MOV32ri64 48717472; GR32:%vreg1
64B		%vreg2<def> = SUBREG_TO_REG 0, %vreg1<kill>, 4; GR64:%vreg2 GR32:%vreg1
80B		%vreg3<def> = MOV32ri64 48397984; GR32:%vreg3
96B		%vreg4<def> = SUBREG_TO_REG 0, %vreg3<kill>, 4; GR64:%vreg4 GR32:%vreg3
112B		%vreg5<def> = MOV32ri64 8971440; GR32:%vreg5
128B		%vreg6<def> = SUBREG_TO_REG 0, %vreg5<kill>, 4; GR64:%vreg6 GR32:%vreg5
144B		%RDI<def> = COPY %vreg2<kill>; GR64:%vreg2
160B		%RSI<def> = COPY %vreg4<kill>; GR64:%vreg4
176B		CALL64r %vreg6<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use,kill>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
240B		%vreg8<def> = MOV64ri <ga:@.str>; GR64:%vreg8
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
272B		%vreg10<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
288B		%vreg11<def> = COPY %vreg10:sub_8bit<kill>; GR8:%vreg11 GR32:%vreg10
304B		%RDI<def> = COPY %vreg8<kill>; GR64:%vreg8
320B		%ESI<def> = COPY %vreg0<kill>; GR32:%vreg0
336B		%AL<def> = COPY %vreg11<kill>; GR8:%vreg11
352B		CALL64r %vreg9<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use,kill>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

Computing live-in reg-units in ABI blocks.
0B	BB#0 DIL#0
Created 1 new intervals.
********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
%vreg0 [16r,320r:0)  0@16r
%vreg1 [48r,64r:0)  0@48r
%vreg2 [64r,144r:0)  0@64r
%vreg3 [80r,96r:0)  0@80r
%vreg4 [96r,160r:0)  0@96r
%vreg5 [112r,128r:0)  0@112r
%vreg6 [128r,176r:0)  0@128r
%vreg8 [240r,304r:0)  0@240r
%vreg9 [256r,352r:0)  0@256r
%vreg10 [272r,288r:0)  0@272r
%vreg11 [288r,336r:0)  0@288r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
48B		%vreg1<def> = MOV32ri64 48717472; GR32:%vreg1
64B		%vreg2<def> = SUBREG_TO_REG 0, %vreg1, 4; GR64:%vreg2 GR32:%vreg1
80B		%vreg3<def> = MOV32ri64 48397984; GR32:%vreg3
96B		%vreg4<def> = SUBREG_TO_REG 0, %vreg3, 4; GR64:%vreg4 GR32:%vreg3
112B		%vreg5<def> = MOV32ri64 8971440; GR32:%vreg5
128B		%vreg6<def> = SUBREG_TO_REG 0, %vreg5, 4; GR64:%vreg6 GR32:%vreg5
144B		%RDI<def> = COPY %vreg2; GR64:%vreg2
160B		%RSI<def> = COPY %vreg4; GR64:%vreg4
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
240B		%vreg8<def> = MOV64ri <ga:@.str>; GR64:%vreg8
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
272B		%vreg10<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
288B		%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
304B		%RDI<def> = COPY %vreg8; GR64:%vreg8
320B		%ESI<def> = COPY %vreg0; GR32:%vreg0
336B		%AL<def> = COPY %vreg11; GR8:%vreg11
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

********** SIMPLE REGISTER COALESCING **********
********** Function: func
********** JOINING INTERVALS ***********
entry:
16B	%vreg0<def> = COPY %EDI; GR32:%vreg0
	Considering merging %vreg0 with %EDI
	Can only merge into reserved registers.
64B	%vreg2<def> = SUBREG_TO_REG 0, %vreg1, 4; GR64:%vreg2 GR32:%vreg1
	Considering merging to GR64_with_sub_8bit with %vreg1 in %vreg2:sub_32bit
		RHS = %vreg1 [48r,64r:0)  0@48r
		LHS = %vreg2 [64r,144r:0)  0@64r
		merge %vreg2:0@64r into %vreg1:0@48r --> @48r
		erased:	64r	%vreg2<def> = SUBREG_TO_REG 0, %vreg1, 4; GR64:%vreg2 GR32:%vreg1
AllocationOrder(GR64) = [ %RAX %RCX %RDX %RSI %RDI %R8 %R9 %R10 %R11 %RBX %R14 %R15 %R12 %R13 ]
AllocationOrder(GR64_with_sub_8bit) = [ %RAX %RCX %RDX %RSI %RDI %R8 %R9 %R10 %R11 %RBX %R14 %R15 %R12 %R13 ]
		updated: 48B	%vreg2:sub_32bit<def,read-undef> = MOV32ri64 48717472; GR64_with_sub_8bit:%vreg2
	Joined. Result = %vreg2 [48r,144r:0)  0@48r
96B	%vreg4<def> = SUBREG_TO_REG 0, %vreg3, 4; GR64:%vreg4 GR32:%vreg3
	Considering merging to GR64_with_sub_8bit with %vreg3 in %vreg4:sub_32bit
		RHS = %vreg3 [80r,96r:0)  0@80r
		LHS = %vreg4 [96r,160r:0)  0@96r
		merge %vreg4:0@96r into %vreg3:0@80r --> @80r
		erased:	96r	%vreg4<def> = SUBREG_TO_REG 0, %vreg3, 4; GR64:%vreg4 GR32:%vreg3
		updated: 80B	%vreg4:sub_32bit<def,read-undef> = MOV32ri64 48397984; GR64_with_sub_8bit:%vreg4
	Joined. Result = %vreg4 [80r,160r:0)  0@80r
128B	%vreg6<def> = SUBREG_TO_REG 0, %vreg5, 4; GR64:%vreg6 GR32:%vreg5
	Considering merging to GR64_with_sub_8bit with %vreg5 in %vreg6:sub_32bit
		RHS = %vreg5 [112r,128r:0)  0@112r
		LHS = %vreg6 [128r,176r:0)  0@128r
		merge %vreg6:0@128r into %vreg5:0@112r --> @112r
		erased:	128r	%vreg6<def> = SUBREG_TO_REG 0, %vreg5, 4; GR64:%vreg6 GR32:%vreg5
		updated: 112B	%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
	Joined. Result = %vreg6 [112r,176r:0)  0@112r
144B	%RDI<def> = COPY %vreg2; GR64_with_sub_8bit:%vreg2
	Considering merging %vreg2 with %RDI
	Can only merge into reserved registers.
Remat: %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
Shrink: %vreg2 [48r,144r:0)  0@48r
All defs dead: 48r	%vreg2:sub_32bit<def,read-undef,dead> = MOV32ri64 48717472; GR64_with_sub_8bit:%vreg2
Shrunk: %vreg2 [48r,48d:0)  0@48r
Deleting dead def 48r	%vreg2:sub_32bit<def,read-undef,dead> = MOV32ri64 48717472; GR64_with_sub_8bit:%vreg2
160B	%RSI<def> = COPY %vreg4; GR64_with_sub_8bit:%vreg4
	Considering merging %vreg4 with %RSI
	Can only merge into reserved registers.
Remat: %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
Shrink: %vreg4 [80r,160r:0)  0@80r
All defs dead: 80r	%vreg4:sub_32bit<def,read-undef,dead> = MOV32ri64 48397984; GR64_with_sub_8bit:%vreg4
Shrunk: %vreg4 [80r,80d:0)  0@80r
Deleting dead def 80r	%vreg4:sub_32bit<def,read-undef,dead> = MOV32ri64 48397984; GR64_with_sub_8bit:%vreg4
304B	%RDI<def> = COPY %vreg8; GR64:%vreg8
	Considering merging %vreg8 with %RDI
	Can only merge into reserved registers.
Remat: %RDI<def> = MOV64ri <ga:@.str>
Shrink: %vreg8 [240r,304r:0)  0@240r
All defs dead: 240r	%vreg8<def,dead> = MOV64ri <ga:@.str>; GR64:%vreg8
Shrunk: %vreg8 [240r,240d:0)  0@240r
Deleting dead def 240r	%vreg8<def,dead> = MOV64ri <ga:@.str>; GR64:%vreg8
320B	%ESI<def> = COPY %vreg0; GR32:%vreg0
	Considering merging %vreg0 with %ESI
	Can only merge into reserved registers.
336B	%AL<def> = COPY %vreg11; GR8:%vreg11
	Considering merging %vreg11 with %AL
	Can only merge into reserved registers.
288B	%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
	Considering merging to GR32 with %vreg11 in %vreg10:sub_8bit
		RHS = %vreg11 [288r,336r:0)  0@288r
		LHS = %vreg10 [272r,288r:0)  0@272r
		merge %vreg11:0@288r into %vreg10:0@272r --> @272r
		erased:	288r	%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
AllocationOrder(GR32) = [ %EAX %ECX %EDX %ESI %EDI %R8D %R9D %R10D %R11D %EBX %R14D %R15D %R12D %R13D ]
		updated: 336B	%AL<def> = COPY %vreg10:sub_8bit; GR32:%vreg10
	Joined. Result = %vreg10 [272r,336r:0)  0@272r
320B	%ESI<def> = COPY %vreg0; GR32:%vreg0
	Considering merging %vreg0 with %ESI
	Can only merge into reserved registers.
336B	%AL<def> = COPY %vreg10:sub_8bit; GR32:%vreg10
	Considering merging %vreg10 with %EAX
	Can only merge into reserved registers.
Remat: %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
Shrink: %vreg10 [272r,336r:0)  0@272r
All defs dead: 272r	%vreg10<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
Shrunk: %vreg10 [272r,272d:0)  0@272r
Deleting dead def 272r	%vreg10<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
320B	%ESI<def> = COPY %vreg0; GR32:%vreg0
	Considering merging %vreg0 with %ESI
	Can only merge into reserved registers.
Trying to inflate 0 regs.
********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
%vreg0 [16r,320r:0)  0@16r
%vreg6 [112r,176r:0)  0@112r
%vreg9 [256r,352r:0)  0@256r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
320B		%ESI<def> = COPY %vreg0; GR32:%vreg0
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

Before MISsched:
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

BB#0: derived from LLVM BB %entry
    Live Ins: %EDI
	%vreg0<def> = COPY %EDI; GR32:%vreg0
	ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
	%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
	%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
	CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
	ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
	ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
	%RDI<def> = MOV64ri <ga:@.str>
	%ESI<def> = COPY %vreg0; GR32:%vreg0
	%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
	CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
	ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	RET

# End machine code for function func.

********** MI Scheduling **********
func:BB#0 entry
  From: %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
    To: CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
 RegionInstrs: 4 Remaining: 9
Disabled scoreboard hazard recognizer
Disabled scoreboard hazard recognizer
SU(0):   %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   val SU(4294967295): Latency=1 Reg=%vreg9

SU(1):   %RDI<def> = MOV64ri <ga:@.str>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

SU(2):   %ESI<def> = COPY %vreg0; GR32:%vreg0
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
   ch  SU(4294967295) *: Latency=0

SU(3):   %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

Critical Path: 1
BotQ.A: 0 3 2 1 
  SU(0) ORDER                              
  SU(3) ORDER                              
  SU(2) PREG-COPY                         
Pick Bot PREG-COPY
Scheduling SU(2) %ESI<def> = COPY %vreg0; GR32:%vreg0
handleMove 320B -> 344B: %ESI<def> = COPY %vreg0; GR32:%vreg0
     SIL:	[160r,176r:0)[344r,352r:1)  0@160r 1@344r
        -->	[160r,176r:0)[344r,352r:1)  0@160r 1@344r
     %vreg0:	[16r,320r:0)  0@16r
        -->	[16r,344r:0)  0@16r
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
BotQ.A: 0 3 1 
  SU(0) ORDER                              
  SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
  Ready @1c
  BotQ.A BotLatency SU(3) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
BotQ.A: 0 1 
  SU(0) ORDER                              
  SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %RDI<def> = MOV64ri <ga:@.str>
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
Scheduling SU(0) %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
*** Final schedule for BB#0 ***
SU(0):   %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
SU(1):   %RDI<def> = MOV64ri <ga:@.str>
SU(3):   %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
SU(2):   %ESI<def> = COPY %vreg0; GR32:%vreg0

********** MI Scheduling **********
func:BB#0 entry
  From: %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
    To: CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
 RegionInstrs: 3 Remaining: 2
SU(0):   %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   val SU(4294967295): Latency=1 Reg=%vreg6

SU(1):   %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

SU(2):   %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

Critical Path: 1
BotQ.A: 0 2 1 
  SU(0) ORDER                              
  SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
  Ready @1c
  SBPort015 +1x4u
  *** Critical resource SBPort015: 0c
  SBPortAny +1x2u
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
BotQ.A: 0 1 
  SU(0) ORDER                              
  SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
Scheduling SU(0) %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 3
  Executed: 1c
  Critical: 1c, 3 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
*** Final schedule for BB#0 ***
SU(0):   %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
SU(1):   %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
SU(2):   %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>

********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
SIL [160r,176r:0)[344r,352r:1)  0@160r 1@344r
%vreg0 [16r,344r:0)  0@16r
%vreg6 [112r,176r:0)  0@112r
%vreg9 [256r,352r:0)  0@256r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
344B		%ESI<def> = COPY %vreg0; GR32:%vreg0
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

RPO[BB#0 derived from LLVM BB entry] = 1
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#0 derived from LLVM BB entry)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0.0
Frequency(BB#0 derived from LLVM BB entry) = 1.0
LoopExitProb[BB#0 derived from LLVM BB entry] = 16383 / 16384 = 99.9939% from 1 - 0.0 / 1.0.
********** COMPUTING LIVE DEBUG VARIABLES: func **********
********** DEBUG VARIABLES **********
********** GREEDY REGISTER ALLOCATION **********
********** Function: func
********** Compute Spill Weights **********
********** Function: func
********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
SIL [160r,176r:0)[344r,352r:1)  0@160r 1@344r
%vreg0 [16r,344r:0)  0@16r
%vreg6 [112r,176r:0)  0@112r
%vreg9 [256r,352r:0)  0@256r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
344B		%ESI<def> = COPY %vreg0; GR32:%vreg0
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.


selectOrSplit GR32:%vreg0 [16r,344r:0)  0@16r
hints: %EDI
missed hint %EDI
assigning %vreg0 to %EBX: BH BL

selectOrSplit GR64_with_sub_8bit:%vreg6 [112r,176r:0)  0@112r
AllocationOrder(GR64_with_sub_8bit) = [ %RAX %RCX %RDX %RSI %RDI %R8 %R9 %R10 %R11 %RBX %R14 %R15 %R12 %R13 ]
assigning %vreg6 to %RAX: AH AL

selectOrSplit GR64:%vreg9 [256r,352r:0)  0@256r
assigning %vreg9 to %RCX: CH CL
********** REWRITE VIRTUAL REGISTERS **********
********** Function: func
********** REGISTER MAP **********
[%vreg0 -> %EBX] GR32
[%vreg6 -> %RAX] GR64_with_sub_8bit
[%vreg9 -> %RCX] GR64

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
344B		%ESI<def> = COPY %vreg0<kill>; GR32:%vreg0
352B		CALL64r %vreg9<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET
> %EBX<def> = COPY %EDI
> ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> %EAX<def> = MOV32ri64 8971440, %RAX<imp-def>
> %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
> %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
> CALL64r %RAX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>
> ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %EBX; mem:ST4[%i.addr]
> ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> %RCX<def> = MOV64ri <ga:@printf>
> %RDI<def> = MOV64ri <ga:@.str>
> %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
> %ESI<def> = COPY %EBX<kill>
> CALL64r %RCX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def,dead>
> ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> RET
********** EMITTING LIVE DEBUG VARIABLES **********
********** Stack Slot Coloring **********
********** Function: func
******** Post-regalloc Machine LICM: func ********

Setting up live-ins for BB#0 derived from entry.
Block has no FP live-ins.

FPInst:	RET
Stack contents:
Inserted instructions:
	RET
Stack contents:
alloc FI(0) at SP[-28]
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: func
real copy:   %EBX<def> = COPY %EDI
replaced by: %EBX<def> = MOV32rr %EDI
real copy:   %ESI<def> = COPY %EBX<kill>
replaced by: %ESI<def> = MOV32rr %EBX<kill>
RPO[BB#0 derived from LLVM BB entry] = 1
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#0 derived from LLVM BB entry)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0.0
Frequency(BB#0 derived from LLVM BB entry) = 1.0
LoopExitProb[BB#0 derived from LLVM BB entry] = 16383 / 16384 = 99.9939% from 1 - 0.0 / 1.0.
********** FIX EXECUTION DEPENDENCIES: VR128 **********
BB#0: entry
JITTing function 'func'
JIT: Starting CodeGen of Function func
JIT: Emitting BB0 at [0x7f7e4367b060]
PUSH64r %RBP<kill>, %RSP<imp-def>, %RSP<imp-use>; flags: FrameSetup
PROLOG_LABEL <MCSym=.Ltmp3>
%RBP<def> = MOV64rr %RSP; flags: FrameSetup
PROLOG_LABEL <MCSym=.Ltmp4>
PUSH64r %RBX<kill>, %RSP<imp-def>, %RSP<imp-use>; flags: FrameSetup
PUSH64r %RAX<undef>, %RSP<imp-def>, %RSP<imp-use>; flags: FrameSetup
PROLOG_LABEL <MCSym=.Ltmp5>
%EBX<def> = MOV32rr %EDI
%EAX<def> = MOV32ri64 8971440, %RAX<imp-def>
%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
CALL64r %RAX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>
MOV32mr %RBP, 1, %noreg, -12, %noreg, %EBX; mem:ST4[%i.addr]
%RCX<def> = MOV64ri <ga:@printf>
%RDI<def> = MOV64ri <ga:@.str>
%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
%ESI<def> = MOV32rr %EBX<kill>
CALL64r %RCX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def,dead>
%RSP<def,tied1> = ADD64ri8 %RSP<tied0>, 8, %EFLAGS<imp-def,dead>
%RBX<def> = POP64r %RSP<imp-def>, %RSP<imp-use>
%RBP<def> = POP64r %RSP<imp-def>, %RSP<imp-use>
RET
JIT: Map 'printf' to [0x353284f3f0]
JIT: Map '.str' to [0x7f7e4366b010]
JIT: Initializing 0x7f7e4366b010 [4 x i8] c"%d\0A\00"
JIT: Finished CodeGen of [0x7f7e4367b060] Function: func: 61 bytes of text, 2 relocations
JIT: Binary code:
JIT: 0: 2291377285 2511378083 136228176184 941601910 
JIT: 16: 1601902231 2552226126 24493137208 24324018572 
JIT: 32: 05350132 1917200 6710217616 00127126 
JIT: 48: 22213719249 13172209255 93918196 195
Inside Func callback func
Inside Func callback func
Inside Func callback func
Inside Func callback func
Function func does not need BB profiling [has single BB]!
Inside Func callback func
JIT: Map 'func' to [0x0]
CGP: Found      local addrmode: [Base:%i.addr]
CGP: Found      local addrmode: [Base:%i.addr]
Computing probabilities for entry



=== func
Initial selection DAG: BB#0 'func:entry'
SelectionDAG has 37 nodes:
  0x2e5c478: ch = EntryToken

  0x2eaa180: i64 = TargetConstant<0>

  0x2e83e40: i64 = Register %RDI

      0x2e5c478: <multiple use>
      0x2eaa180: <multiple use>
    0x2eaa080: ch,glue = callseq_start 0x2e5c478, 0x2eaa180 [ORD=29]

    0x2e83e40: <multiple use>
    0x2eaa380: i64 = Constant<48717472>

  0x2e7f6b0: ch,glue = CopyToReg 0x2eaa080, 0x2e83e40, 0x2eaa380 [ORD=29]

  0x2ea9f80: i64 = Register %RSI

    0x2e7f6b0: <multiple use>
    0x2ea9f80: <multiple use>
    0x2eaa280: i64 = Constant<48397984>

    0x2e7f6b0: <multiple use>
  0x2ea9e80: ch,glue = CopyToReg 0x2e7f6b0, 0x2ea9f80, 0x2eaa280, 0x2e7f6b0:1 [ORD=29]

  0x2ea9d80: Untyped = RegisterMask

    0x2ea9e80: <multiple use>
    0x2eaa480: i64 = Constant<8971440>

    0x2e83e40: <multiple use>
    0x2ea9f80: <multiple use>
    0x2ea9d80: <multiple use>
    0x2ea9e80: <multiple use>
  0x2e84140: ch,glue = X86ISD::CALL 0x2ea9e80, 0x2eaa480, 0x2e83e40, 0x2ea9f80, 0x2ea9d80, 0x2ea9e80:1 [ORD=29]

    0x2e84140: <multiple use>
    0x2eaa180: <multiple use>
    0x2eaa180: <multiple use>
    0x2e84140: <multiple use>
  0x2ea9a80: ch,glue = callseq_end 0x2e84140, 0x2eaa180, 0x2eaa180, 0x2e84140:1 [ORD=29]

  0x2ea9780: i64 = FrameIndex<0>

  0x2ea9680: i64 = Constant<0>

  0x2e84940: i64 = undef

        0x2ea9a80: <multiple use>
        0x2ea9b80: i64 = Register %RAX

        0x2ea9a80: <multiple use>
      0x2ea9980: i64,ch,glue = CopyFromReg 0x2ea9a80, 0x2ea9b80, 0x2ea9a80:1 [ORD=29]

        0x2e5c478: <multiple use>
        0x2eaa9d0: i32 = Register %vreg0

      0x2eaa8d0: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=25]

      0x2ea9780: <multiple use>
      0x2e84940: <multiple use>
    0x2e84740: ch = store 0x2ea9980:1, 0x2eaa8d0, 0x2ea9780, 0x2e84940<ST4[%i.addr]> [ORD=31]

    0x2ea9780: <multiple use>
    0x2e84940: <multiple use>
  0x2e84540: i32,ch = load 0x2e84740, 0x2ea9780, 0x2e84940<LD4[%i.addr]> [ORD=32]

      0x2e84540: <multiple use>
      0x2eaa180: <multiple use>
    0x2e7f5b0: ch,glue = callseq_start 0x2e84540:1, 0x2eaa180 [ORD=33]

    0x2e83e40: <multiple use>
    0x2e83f40: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=33]

  0x2e7fbb0: ch,glue = CopyToReg 0x2e7f5b0, 0x2e83e40, 0x2e83f40 [ORD=33]

  0x2e7f4b0: i32 = Register %ESI

    0x2e7fbb0: <multiple use>
    0x2e7f4b0: <multiple use>
    0x2e84540: <multiple use>
    0x2e7fbb0: <multiple use>
  0x2e83c40: ch,glue = CopyToReg 0x2e7fbb0, 0x2e7f4b0, 0x2e84540, 0x2e7fbb0:1 [ORD=33]

  0x2ea9c80: i8 = Register %AL

    0x2e83c40: <multiple use>
    0x2ea9c80: <multiple use>
    0x2e7f7b0: i8 = Constant<0>

    0x2e83c40: <multiple use>
  0x2e84040: ch,glue = CopyToReg 0x2e83c40, 0x2ea9c80, 0x2e7f7b0, 0x2e83c40:1 [ORD=33]

    0x2e84040: <multiple use>
    0x2e84340: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=33]

    0x2e83e40: <multiple use>
    0x2e7f4b0: <multiple use>
    0x2ea9c80: <multiple use>
    0x2ea9d80: <multiple use>
    0x2e84040: <multiple use>
  0x2e800b0: ch,glue = X86ISD::CALL 0x2e84040, 0x2e84340, 0x2e83e40, 0x2e7f4b0, 0x2ea9c80, 0x2ea9d80, 0x2e84040:1 [ORD=33]

    0x2e800b0: <multiple use>
    0x2eaa180: <multiple use>
    0x2eaa180: <multiple use>
    0x2e800b0: <multiple use>
  0x2e7fdb0: ch,glue = callseq_end 0x2e800b0, 0x2eaa180, 0x2eaa180, 0x2e800b0:1 [ORD=33]

      0x2e7fdb0: <multiple use>
      0x2e84240: i32 = Register %EAX

      0x2e7fdb0: <multiple use>
    0x2e83d40: i32,ch,glue = CopyFromReg 0x2e7fdb0, 0x2e84240, 0x2e7fdb0:1 [ORD=33]

    0x2ea9880: i16 = TargetConstant<0>

  0x2e84840: ch = X86ISD::RET_FLAG 0x2e83d40:1, 0x2ea9880 [ORD=34]



Replacing.1 0x2e84540: i32,ch = load 0x2e84740, 0x2ea9780, 0x2e84940<LD4[%i.addr]> [ORD=32]

With: 0x2eaa8d0: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=25]
 and 1 other values
Optimized lowered selection DAG: BB#0 'func:entry'
SelectionDAG has 35 nodes:
  0x2e5c478: ch = EntryToken

    0x2e5c478: <multiple use>
    0x2eaa9d0: i32 = Register %vreg0

  0x2eaa8d0: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=25]

  0x2eaa180: i64 = TargetConstant<0>

  0x2e83e40: i64 = Register %RDI

      0x2e5c478: <multiple use>
      0x2eaa180: <multiple use>
    0x2eaa080: ch,glue = callseq_start 0x2e5c478, 0x2eaa180 [ORD=29]

    0x2e83e40: <multiple use>
    0x2eaa380: i64 = Constant<48717472>

  0x2e7f6b0: ch,glue = CopyToReg 0x2eaa080, 0x2e83e40, 0x2eaa380 [ORD=29]

  0x2ea9f80: i64 = Register %RSI

    0x2e7f6b0: <multiple use>
    0x2ea9f80: <multiple use>
    0x2eaa280: i64 = Constant<48397984>

    0x2e7f6b0: <multiple use>
  0x2ea9e80: ch,glue = CopyToReg 0x2e7f6b0, 0x2ea9f80, 0x2eaa280, 0x2e7f6b0:1 [ORD=29]

  0x2ea9d80: Untyped = RegisterMask

    0x2ea9e80: <multiple use>
    0x2eaa480: i64 = Constant<8971440>

    0x2e83e40: <multiple use>
    0x2ea9f80: <multiple use>
    0x2ea9d80: <multiple use>
    0x2ea9e80: <multiple use>
  0x2e84140: ch,glue = X86ISD::CALL 0x2ea9e80, 0x2eaa480, 0x2e83e40, 0x2ea9f80, 0x2ea9d80, 0x2ea9e80:1 [ORD=29]

    0x2e84140: <multiple use>
    0x2eaa180: <multiple use>
    0x2eaa180: <multiple use>
    0x2e84140: <multiple use>
  0x2ea9a80: ch,glue = callseq_end 0x2e84140, 0x2eaa180, 0x2eaa180, 0x2e84140:1 [ORD=29]

          0x2ea9a80: <multiple use>
          0x2ea9b80: i64 = Register %RAX

          0x2ea9a80: <multiple use>
        0x2ea9980: i64,ch,glue = CopyFromReg 0x2ea9a80, 0x2ea9b80, 0x2ea9a80:1 [ORD=29]

        0x2eaa8d0: <multiple use>
        0x2ea9780: i64 = FrameIndex<0>

        0x2e84940: i64 = undef

      0x2e84740: ch = store 0x2ea9980:1, 0x2eaa8d0, 0x2ea9780, 0x2e84940<ST4[%i.addr]> [ORD=31]

      0x2eaa180: <multiple use>
    0x2e7f5b0: ch,glue = callseq_start 0x2e84740, 0x2eaa180 [ORD=33]

    0x2e83e40: <multiple use>
    0x2e83f40: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=33]

  0x2e7fbb0: ch,glue = CopyToReg 0x2e7f5b0, 0x2e83e40, 0x2e83f40 [ORD=33]

  0x2e7f4b0: i32 = Register %ESI

    0x2e7fbb0: <multiple use>
    0x2e7f4b0: <multiple use>
    0x2eaa8d0: <multiple use>
    0x2e7fbb0: <multiple use>
  0x2e83c40: ch,glue = CopyToReg 0x2e7fbb0, 0x2e7f4b0, 0x2eaa8d0, 0x2e7fbb0:1 [ORD=33]

  0x2ea9c80: i8 = Register %AL

    0x2e83c40: <multiple use>
    0x2ea9c80: <multiple use>
    0x2e7f7b0: i8 = Constant<0>

    0x2e83c40: <multiple use>
  0x2e84040: ch,glue = CopyToReg 0x2e83c40, 0x2ea9c80, 0x2e7f7b0, 0x2e83c40:1 [ORD=33]

    0x2e84040: <multiple use>
    0x2e84340: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=33]

    0x2e83e40: <multiple use>
    0x2e7f4b0: <multiple use>
    0x2ea9c80: <multiple use>
    0x2ea9d80: <multiple use>
    0x2e84040: <multiple use>
  0x2e800b0: ch,glue = X86ISD::CALL 0x2e84040, 0x2e84340, 0x2e83e40, 0x2e7f4b0, 0x2ea9c80, 0x2ea9d80, 0x2e84040:1 [ORD=33]

    0x2e800b0: <multiple use>
    0x2eaa180: <multiple use>
    0x2eaa180: <multiple use>
    0x2e800b0: <multiple use>
  0x2e7fdb0: ch,glue = callseq_end 0x2e800b0, 0x2eaa180, 0x2eaa180, 0x2e800b0:1 [ORD=33]

      0x2e7fdb0: <multiple use>
      0x2e84240: i32 = Register %EAX

      0x2e7fdb0: <multiple use>
    0x2e83d40: i32,ch,glue = CopyFromReg 0x2e7fdb0, 0x2e84240, 0x2e7fdb0:1 [ORD=33]

    0x2ea9880: i16 = TargetConstant<0>

  0x2e84840: ch = X86ISD::RET_FLAG 0x2e83d40:1, 0x2ea9880 [ORD=34]


Legally typed node: 0x2ea9880: i16 = TargetConstant<0> [ID=0]

Legally typed node: 0x2e84240: i32 = Register %EAX [ID=0]

Legally typed node: 0x2ea9c80: i8 = Register %AL [ID=0]

Legally typed node: 0x2e7f4b0: i32 = Register %ESI [ID=0]

Legally typed node: 0x2e7f7b0: i8 = Constant<0> [ID=0]

Legally typed node: 0x2e83f40: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=33] [ID=0]

Legally typed node: 0x2e84340: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=33] [ID=0]

Legally typed node: 0x2e84940: i64 = undef [ID=0]

Legally typed node: 0x2ea9780: i64 = FrameIndex<0> [ID=0]

Legally typed node: 0x2ea9b80: i64 = Register %RAX [ID=0]

Legally typed node: 0x2ea9d80: Untyped = RegisterMask [ID=0]

Legally typed node: 0x2ea9f80: i64 = Register %RSI [ID=0]

Legally typed node: 0x2e83e40: i64 = Register %RDI [ID=0]

Legally typed node: 0x2eaa180: i64 = TargetConstant<0> [ID=0]

Legally typed node: 0x2eaa280: i64 = Constant<48397984> [ID=0]

Legally typed node: 0x2eaa380: i64 = Constant<48717472> [ID=0]

Legally typed node: 0x2eaa480: i64 = Constant<8971440> [ID=0]

Legally typed node: 0x2eaa9d0: i32 = Register %vreg0 [ID=0]

Legally typed node: 0x2e5c478: ch = EntryToken [ID=0]

Legally typed node: 0x2eaa8d0: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=25] [ID=0]

Legally typed node: 0x2eaa080: ch,glue = callseq_start 0x2e5c478, 0x2eaa180 [ORD=29] [ID=0]

Legally typed node: 0x2e7f6b0: ch,glue = CopyToReg 0x2eaa080, 0x2e83e40, 0x2eaa380 [ORD=29] [ID=0]

Legally typed node: 0x2ea9e80: ch,glue = CopyToReg 0x2e7f6b0, 0x2ea9f80, 0x2eaa280, 0x2e7f6b0:1 [ORD=29] [ID=0]

Legally typed node: 0x2e84140: ch,glue = X86ISD::CALL 0x2ea9e80, 0x2eaa480, 0x2e83e40, 0x2ea9f80, 0x2ea9d80, 0x2ea9e80:1 [ORD=29] [ID=0]

Legally typed node: 0x2ea9a80: ch,glue = callseq_end 0x2e84140, 0x2eaa180, 0x2eaa180, 0x2e84140:1 [ORD=29] [ID=0]

Legally typed node: 0x2ea9980: i64,ch,glue = CopyFromReg 0x2ea9a80, 0x2ea9b80, 0x2ea9a80:1 [ORD=29] [ID=0]

Legally typed node: 0x2e84740: ch = store 0x2ea9980:1, 0x2eaa8d0, 0x2ea9780, 0x2e84940<ST4[%i.addr]> [ORD=31] [ID=0]

Legally typed node: 0x2e7f5b0: ch,glue = callseq_start 0x2e84740, 0x2eaa180 [ORD=33] [ID=0]

Legally typed node: 0x2e7fbb0: ch,glue = CopyToReg 0x2e7f5b0, 0x2e83e40, 0x2e83f40 [ORD=33] [ID=0]

Legally typed node: 0x2e83c40: ch,glue = CopyToReg 0x2e7fbb0, 0x2e7f4b0, 0x2eaa8d0, 0x2e7fbb0:1 [ORD=33] [ID=0]

Legally typed node: 0x2e84040: ch,glue = CopyToReg 0x2e83c40, 0x2ea9c80, 0x2e7f7b0, 0x2e83c40:1 [ORD=33] [ID=0]

Legally typed node: 0x2e800b0: ch,glue = X86ISD::CALL 0x2e84040, 0x2e84340, 0x2e83e40, 0x2e7f4b0, 0x2ea9c80, 0x2ea9d80, 0x2e84040:1 [ORD=33] [ID=0]

Legally typed node: 0x2e7fdb0: ch,glue = callseq_end 0x2e800b0, 0x2eaa180, 0x2eaa180, 0x2e800b0:1 [ORD=33] [ID=0]

Legally typed node: 0x2e83d40: i32,ch,glue = CopyFromReg 0x2e7fdb0, 0x2e84240, 0x2e7fdb0:1 [ORD=33] [ID=0]

Legally typed node: 0x2e84840: ch = X86ISD::RET_FLAG 0x2e83d40:1, 0x2ea9880 [ORD=34] [ID=0]

Legally typed node: 0x7fff29e7ba10: ch = handlenode 0x2e84840 [ID=0]

Type-legalized selection DAG: BB#0 'func:entry'
SelectionDAG has 35 nodes:
  0x2e5c478: ch = EntryToken [ID=-3]

    0x2e5c478: <multiple use>
    0x2eaa9d0: i32 = Register %vreg0 [ID=-3]

  0x2eaa8d0: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=25] [ID=-3]

  0x2eaa180: i64 = TargetConstant<0> [ID=-3]

  0x2e83e40: i64 = Register %RDI [ID=-3]

      0x2e5c478: <multiple use>
      0x2eaa180: <multiple use>
    0x2eaa080: ch,glue = callseq_start 0x2e5c478, 0x2eaa180 [ORD=29] [ID=-3]

    0x2e83e40: <multiple use>
    0x2eaa380: i64 = Constant<48717472> [ID=-3]

  0x2e7f6b0: ch,glue = CopyToReg 0x2eaa080, 0x2e83e40, 0x2eaa380 [ORD=29] [ID=-3]

  0x2ea9f80: i64 = Register %RSI [ID=-3]

    0x2e7f6b0: <multiple use>
    0x2ea9f80: <multiple use>
    0x2eaa280: i64 = Constant<48397984> [ID=-3]

    0x2e7f6b0: <multiple use>
  0x2ea9e80: ch,glue = CopyToReg 0x2e7f6b0, 0x2ea9f80, 0x2eaa280, 0x2e7f6b0:1 [ORD=29] [ID=-3]

  0x2ea9d80: Untyped = RegisterMask [ID=-3]

    0x2ea9e80: <multiple use>
    0x2eaa480: i64 = Constant<8971440> [ID=-3]

    0x2e83e40: <multiple use>
    0x2ea9f80: <multiple use>
    0x2ea9d80: <multiple use>
    0x2ea9e80: <multiple use>
  0x2e84140: ch,glue = X86ISD::CALL 0x2ea9e80, 0x2eaa480, 0x2e83e40, 0x2ea9f80, 0x2ea9d80, 0x2ea9e80:1 [ORD=29] [ID=-3]

    0x2e84140: <multiple use>
    0x2eaa180: <multiple use>
    0x2eaa180: <multiple use>
    0x2e84140: <multiple use>
  0x2ea9a80: ch,glue = callseq_end 0x2e84140, 0x2eaa180, 0x2eaa180, 0x2e84140:1 [ORD=29] [ID=-3]

          0x2ea9a80: <multiple use>
          0x2ea9b80: i64 = Register %RAX [ID=-3]

          0x2ea9a80: <multiple use>
        0x2ea9980: i64,ch,glue = CopyFromReg 0x2ea9a80, 0x2ea9b80, 0x2ea9a80:1 [ORD=29] [ID=-3]

        0x2eaa8d0: <multiple use>
        0x2ea9780: i64 = FrameIndex<0> [ID=-3]

        0x2e84940: i64 = undef [ID=-3]

      0x2e84740: ch = store 0x2ea9980:1, 0x2eaa8d0, 0x2ea9780, 0x2e84940<ST4[%i.addr]> [ORD=31] [ID=-3]

      0x2eaa180: <multiple use>
    0x2e7f5b0: ch,glue = callseq_start 0x2e84740, 0x2eaa180 [ORD=33] [ID=-3]

    0x2e83e40: <multiple use>
    0x2e83f40: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=33] [ID=-3]

  0x2e7fbb0: ch,glue = CopyToReg 0x2e7f5b0, 0x2e83e40, 0x2e83f40 [ORD=33] [ID=-3]

  0x2e7f4b0: i32 = Register %ESI [ID=-3]

    0x2e7fbb0: <multiple use>
    0x2e7f4b0: <multiple use>
    0x2eaa8d0: <multiple use>
    0x2e7fbb0: <multiple use>
  0x2e83c40: ch,glue = CopyToReg 0x2e7fbb0, 0x2e7f4b0, 0x2eaa8d0, 0x2e7fbb0:1 [ORD=33] [ID=-3]

  0x2ea9c80: i8 = Register %AL [ID=-3]

    0x2e83c40: <multiple use>
    0x2ea9c80: <multiple use>
    0x2e7f7b0: i8 = Constant<0> [ID=-3]

    0x2e83c40: <multiple use>
  0x2e84040: ch,glue = CopyToReg 0x2e83c40, 0x2ea9c80, 0x2e7f7b0, 0x2e83c40:1 [ORD=33] [ID=-3]

    0x2e84040: <multiple use>
    0x2e84340: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=33] [ID=-3]

    0x2e83e40: <multiple use>
    0x2e7f4b0: <multiple use>
    0x2ea9c80: <multiple use>
    0x2ea9d80: <multiple use>
    0x2e84040: <multiple use>
  0x2e800b0: ch,glue = X86ISD::CALL 0x2e84040, 0x2e84340, 0x2e83e40, 0x2e7f4b0, 0x2ea9c80, 0x2ea9d80, 0x2e84040:1 [ORD=33] [ID=-3]

    0x2e800b0: <multiple use>
    0x2eaa180: <multiple use>
    0x2eaa180: <multiple use>
    0x2e800b0: <multiple use>
  0x2e7fdb0: ch,glue = callseq_end 0x2e800b0, 0x2eaa180, 0x2eaa180, 0x2e800b0:1 [ORD=33] [ID=-3]

      0x2e7fdb0: <multiple use>
      0x2e84240: i32 = Register %EAX [ID=-3]

      0x2e7fdb0: <multiple use>
    0x2e83d40: i32,ch,glue = CopyFromReg 0x2e7fdb0, 0x2e84240, 0x2e7fdb0:1 [ORD=33] [ID=-3]

    0x2ea9880: i16 = TargetConstant<0> [ID=-3]

  0x2e84840: ch = X86ISD::RET_FLAG 0x2e83d40:1, 0x2ea9880 [ORD=34] [ID=-3]


Legalized selection DAG: BB#0 'func:entry'
SelectionDAG has 37 nodes:
  0x2e5c478: ch = EntryToken [ID=0]

  0x2eaa180: i64 = TargetConstant<0> [ID=5]

  0x2e83e40: i64 = Register %RDI [ID=6]

  0x2ea9f80: i64 = Register %RSI [ID=7]

  0x2ea9d80: Untyped = RegisterMask [ID=8]

  0x2e7f4b0: i32 = Register %ESI [ID=15]

  0x2ea9c80: i8 = Register %AL [ID=16]

    0x2e5c478: <multiple use>
    0x2eaa9d0: i32 = Register %vreg0 [ID=1]

  0x2eaa8d0: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=25] [ID=19]

      0x2e5c478: <multiple use>
      0x2eaa180: <multiple use>
    0x2eaa080: ch,glue = callseq_start 0x2e5c478, 0x2eaa180 [ORD=29] [ID=20]

    0x2e83e40: <multiple use>
    0x2eaa380: i64 = Constant<48717472> [ID=3]

  0x2e7f6b0: ch,glue = CopyToReg 0x2eaa080, 0x2e83e40, 0x2eaa380 [ORD=29] [ID=21]

    0x2e7f6b0: <multiple use>
    0x2ea9f80: <multiple use>
    0x2eaa280: i64 = Constant<48397984> [ID=4]

    0x2e7f6b0: <multiple use>
  0x2ea9e80: ch,glue = CopyToReg 0x2e7f6b0, 0x2ea9f80, 0x2eaa280, 0x2e7f6b0:1 [ORD=29] [ID=22]

    0x2ea9e80: <multiple use>
    0x2eaa480: i64 = Constant<8971440> [ID=2]

    0x2e83e40: <multiple use>
    0x2ea9f80: <multiple use>
    0x2ea9d80: <multiple use>
    0x2ea9e80: <multiple use>
  0x2e84140: ch,glue = X86ISD::CALL 0x2ea9e80, 0x2eaa480, 0x2e83e40, 0x2ea9f80, 0x2ea9d80, 0x2ea9e80:1 [ORD=29] [ID=23]

    0x2e84140: <multiple use>
    0x2eaa180: <multiple use>
    0x2eaa180: <multiple use>
    0x2e84140: <multiple use>
  0x2ea9a80: ch,glue = callseq_end 0x2e84140, 0x2eaa180, 0x2eaa180, 0x2e84140:1 [ORD=29] [ID=24]

          0x2ea9a80: <multiple use>
          0x2ea9b80: i64 = Register %RAX [ID=9]

          0x2ea9a80: <multiple use>
        0x2ea9980: i64,ch,glue = CopyFromReg 0x2ea9a80, 0x2ea9b80, 0x2ea9a80:1 [ORD=29] [ID=25]

        0x2eaa8d0: <multiple use>
        0x2ea9780: i64 = FrameIndex<0> [ID=10]

        0x2e84940: i64 = undef [ID=11]

      0x2e84740: ch = store 0x2ea9980:1, 0x2eaa8d0, 0x2ea9780, 0x2e84940<ST4[%i.addr]> [ORD=31] [ID=26]

      0x2eaa180: <multiple use>
    0x2e7f5b0: ch,glue = callseq_start 0x2e84740, 0x2eaa180 [ORD=33] [ID=27]

    0x2e83e40: <multiple use>
      0x2ea9680: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=33]

    0x2e84540: i64 = X86ISD::Wrapper 0x2ea9680 [ORD=33]

  0x2e7fbb0: ch,glue = CopyToReg 0x2e7f5b0, 0x2e83e40, 0x2e84540 [ORD=33] [ID=28]

    0x2e7fbb0: <multiple use>
    0x2e7f4b0: <multiple use>
    0x2eaa8d0: <multiple use>
    0x2e7fbb0: <multiple use>
  0x2e83c40: ch,glue = CopyToReg 0x2e7fbb0, 0x2e7f4b0, 0x2eaa8d0, 0x2e7fbb0:1 [ORD=33] [ID=29]

    0x2e83c40: <multiple use>
    0x2ea9c80: <multiple use>
    0x2e7f7b0: i8 = Constant<0> [ID=14]

    0x2e83c40: <multiple use>
  0x2e84040: ch,glue = CopyToReg 0x2e83c40, 0x2ea9c80, 0x2e7f7b0, 0x2e83c40:1 [ORD=33] [ID=30]

    0x2e84040: <multiple use>
      0x2e83f40: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=33]

    0x2e84640: i64 = X86ISD::Wrapper 0x2e83f40 [ORD=33]

    0x2e83e40: <multiple use>
    0x2e7f4b0: <multiple use>
    0x2ea9c80: <multiple use>
    0x2ea9d80: <multiple use>
    0x2e84040: <multiple use>
  0x2e800b0: ch,glue = X86ISD::CALL 0x2e84040, 0x2e84640, 0x2e83e40, 0x2e7f4b0, 0x2ea9c80, 0x2ea9d80, 0x2e84040:1 [ORD=33] [ID=31]

    0x2e800b0: <multiple use>
    0x2eaa180: <multiple use>
    0x2eaa180: <multiple use>
    0x2e800b0: <multiple use>
  0x2e7fdb0: ch,glue = callseq_end 0x2e800b0, 0x2eaa180, 0x2eaa180, 0x2e800b0:1 [ORD=33] [ID=32]

      0x2e7fdb0: <multiple use>
      0x2e84240: i32 = Register %EAX [ID=17]

      0x2e7fdb0: <multiple use>
    0x2e83d40: i32,ch,glue = CopyFromReg 0x2e7fdb0, 0x2e84240, 0x2e7fdb0:1 [ORD=33] [ID=33]

    0x2ea9880: i16 = TargetConstant<0> [ID=18]

  0x2e84840: ch = X86ISD::RET_FLAG 0x2e83d40:1, 0x2ea9880 [ORD=34] [ID=34]


Optimized legalized selection DAG: BB#0 'func:entry'
SelectionDAG has 37 nodes:
  0x2e5c478: ch = EntryToken [ID=0]

  0x2eaa180: i64 = TargetConstant<0> [ID=5]

  0x2e83e40: i64 = Register %RDI [ID=6]

  0x2ea9f80: i64 = Register %RSI [ID=7]

  0x2ea9d80: Untyped = RegisterMask [ID=8]

  0x2e7f4b0: i32 = Register %ESI [ID=15]

  0x2ea9c80: i8 = Register %AL [ID=16]

    0x2e5c478: <multiple use>
    0x2eaa9d0: i32 = Register %vreg0 [ID=1]

  0x2eaa8d0: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=25] [ID=19]

      0x2e5c478: <multiple use>
      0x2eaa180: <multiple use>
    0x2eaa080: ch,glue = callseq_start 0x2e5c478, 0x2eaa180 [ORD=29] [ID=20]

    0x2e83e40: <multiple use>
    0x2eaa380: i64 = Constant<48717472> [ID=3]

  0x2e7f6b0: ch,glue = CopyToReg 0x2eaa080, 0x2e83e40, 0x2eaa380 [ORD=29] [ID=21]

    0x2e7f6b0: <multiple use>
    0x2ea9f80: <multiple use>
    0x2eaa280: i64 = Constant<48397984> [ID=4]

    0x2e7f6b0: <multiple use>
  0x2ea9e80: ch,glue = CopyToReg 0x2e7f6b0, 0x2ea9f80, 0x2eaa280, 0x2e7f6b0:1 [ORD=29] [ID=22]

    0x2ea9e80: <multiple use>
    0x2eaa480: i64 = Constant<8971440> [ID=2]

    0x2e83e40: <multiple use>
    0x2ea9f80: <multiple use>
    0x2ea9d80: <multiple use>
    0x2ea9e80: <multiple use>
  0x2e84140: ch,glue = X86ISD::CALL 0x2ea9e80, 0x2eaa480, 0x2e83e40, 0x2ea9f80, 0x2ea9d80, 0x2ea9e80:1 [ORD=29] [ID=23]

    0x2e84140: <multiple use>
    0x2eaa180: <multiple use>
    0x2eaa180: <multiple use>
    0x2e84140: <multiple use>
  0x2ea9a80: ch,glue = callseq_end 0x2e84140, 0x2eaa180, 0x2eaa180, 0x2e84140:1 [ORD=29] [ID=24]

          0x2ea9a80: <multiple use>
          0x2ea9b80: i64 = Register %RAX [ID=9]

          0x2ea9a80: <multiple use>
        0x2ea9980: i64,ch,glue = CopyFromReg 0x2ea9a80, 0x2ea9b80, 0x2ea9a80:1 [ORD=29] [ID=25]

        0x2eaa8d0: <multiple use>
        0x2ea9780: i64 = FrameIndex<0> [ID=10]

        0x2e84940: i64 = undef [ID=11]

      0x2e84740: ch = store 0x2ea9980:1, 0x2eaa8d0, 0x2ea9780, 0x2e84940<ST4[%i.addr]> [ORD=31] [ID=26]

      0x2eaa180: <multiple use>
    0x2e7f5b0: ch,glue = callseq_start 0x2e84740, 0x2eaa180 [ORD=33] [ID=27]

    0x2e83e40: <multiple use>
      0x2ea9680: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=33]

    0x2e84540: i64 = X86ISD::Wrapper 0x2ea9680 [ORD=33]

  0x2e7fbb0: ch,glue = CopyToReg 0x2e7f5b0, 0x2e83e40, 0x2e84540 [ORD=33] [ID=28]

    0x2e7fbb0: <multiple use>
    0x2e7f4b0: <multiple use>
    0x2eaa8d0: <multiple use>
    0x2e7fbb0: <multiple use>
  0x2e83c40: ch,glue = CopyToReg 0x2e7fbb0, 0x2e7f4b0, 0x2eaa8d0, 0x2e7fbb0:1 [ORD=33] [ID=29]

    0x2e83c40: <multiple use>
    0x2ea9c80: <multiple use>
    0x2e7f7b0: i8 = Constant<0> [ID=14]

    0x2e83c40: <multiple use>
  0x2e84040: ch,glue = CopyToReg 0x2e83c40, 0x2ea9c80, 0x2e7f7b0, 0x2e83c40:1 [ORD=33] [ID=30]

    0x2e84040: <multiple use>
      0x2e83f40: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=33]

    0x2e84640: i64 = X86ISD::Wrapper 0x2e83f40 [ORD=33]

    0x2e83e40: <multiple use>
    0x2e7f4b0: <multiple use>
    0x2ea9c80: <multiple use>
    0x2ea9d80: <multiple use>
    0x2e84040: <multiple use>
  0x2e800b0: ch,glue = X86ISD::CALL 0x2e84040, 0x2e84640, 0x2e83e40, 0x2e7f4b0, 0x2ea9c80, 0x2ea9d80, 0x2e84040:1 [ORD=33] [ID=31]

    0x2e800b0: <multiple use>
    0x2eaa180: <multiple use>
    0x2eaa180: <multiple use>
    0x2e800b0: <multiple use>
  0x2e7fdb0: ch,glue = callseq_end 0x2e800b0, 0x2eaa180, 0x2eaa180, 0x2e800b0:1 [ORD=33] [ID=32]

      0x2e7fdb0: <multiple use>
      0x2e84240: i32 = Register %EAX [ID=17]

      0x2e7fdb0: <multiple use>
    0x2e83d40: i32,ch,glue = CopyFromReg 0x2e7fdb0, 0x2e84240, 0x2e7fdb0:1 [ORD=33] [ID=33]

    0x2ea9880: i16 = TargetConstant<0> [ID=18]

  0x2e84840: ch = X86ISD::RET_FLAG 0x2e83d40:1, 0x2ea9880 [ORD=34] [ID=34]


===== Instruction selection begins: BB#0 'entry'
Selecting: 0x2e84840: ch = X86ISD::RET_FLAG 0x2e83d40:1, 0x2ea9880 [ORD=34] [ID=36]

ISEL: Starting pattern match on root node: 0x2e84840: ch = X86ISD::RET_FLAG 0x2e83d40:1, 0x2ea9880 [ORD=34] [ID=36]

  Initial Opcode index to 93235
  Morphed node: 0x2e84840: ch = RET 0x2e83d40:1 [ORD=34]

ISEL: Match complete!
=> 0x2e84840: ch = RET 0x2e83d40:1 [ORD=34]

Selecting: 0x2e83d40: i32,ch,glue = CopyFromReg 0x2e7fdb0, 0x2e84240, 0x2e7fdb0:1 [ORD=33] [ID=35]

=> 0x2e83d40: i32,ch,glue = CopyFromReg 0x2e7fdb0, 0x2e84240, 0x2e7fdb0:1 [ORD=33]

Selecting: 0x2e7fdb0: ch,glue = callseq_end 0x2e800b0, 0x2eaa180, 0x2eaa180, 0x2e800b0:1 [ORD=33] [ID=34]

ISEL: Starting pattern match on root node: 0x2e7fdb0: ch,glue = callseq_end 0x2e800b0, 0x2eaa180, 0x2eaa180, 0x2e800b0:1 [ORD=33] [ID=34]

  Initial Opcode index to 92907
  Skipped scope entry (due to false predicate) at index 92925, continuing at 92937
  Morphed node: 0x2e7fdb0: i64,ch,glue = ADJCALLSTACKUP64 0x2eaa180, 0x2eaa180, 0x2e800b0, 0x2e800b0:1 [ORD=33]

ISEL: Match complete!
=> 0x2e7fdb0: i64,ch,glue = ADJCALLSTACKUP64 0x2eaa180, 0x2eaa180, 0x2e800b0, 0x2e800b0:1 [ORD=33]

Selecting: 0x2e800b0: ch,glue = X86ISD::CALL 0x2e84040, 0x2e84640, 0x2e83e40, 0x2e7f4b0, 0x2ea9c80, 0x2ea9d80, 0x2e84040:1 [ORD=33] [ID=33]

ISEL: Starting pattern match on root node: 0x2e800b0: ch,glue = X86ISD::CALL 0x2e84040, 0x2e84640, 0x2e83e40, 0x2e7f4b0, 0x2ea9c80, 0x2ea9d80, 0x2e84040:1 [ORD=33] [ID=33]

  Initial Opcode index to 69884
  Match failed at index 69890
  Continuing at 69951
  Match failed at index 69957
  Continuing at 70031
  Match failed at index 70032
  Continuing at 70044
  Morphed node: 0x2e800b0: ch,glue = CALL64r 0x2e84640, 0x2e83e40, 0x2e7f4b0, 0x2ea9c80, 0x2ea9d80, 0x2e84040, 0x2e84040:1 [ORD=33]

ISEL: Match complete!
=> 0x2e800b0: ch,glue = CALL64r 0x2e84640, 0x2e83e40, 0x2e7f4b0, 0x2ea9c80, 0x2ea9d80, 0x2e84040, 0x2e84040:1 [ORD=33]

Selecting: 0x2e84040: ch,glue = CopyToReg 0x2e83c40, 0x2ea9c80, 0x2e7f7b0, 0x2e83c40:1 [ORD=33] [ID=32]

=> 0x2e84040: ch,glue = CopyToReg 0x2e83c40, 0x2ea9c80, 0x2e7f7b0, 0x2e83c40:1 [ORD=33]

Selecting: 0x2e83c40: ch,glue = CopyToReg 0x2e7fbb0, 0x2e7f4b0, 0x2eaa8d0, 0x2e7fbb0:1 [ORD=33] [ID=31]

=> 0x2e83c40: ch,glue = CopyToReg 0x2e7fbb0, 0x2e7f4b0, 0x2eaa8d0, 0x2e7fbb0:1 [ORD=33]

Selecting: 0x2e7fbb0: ch,glue = CopyToReg 0x2e7f5b0, 0x2e83e40, 0x2e84540 [ORD=33] [ID=30]

=> 0x2e7fbb0: ch,glue = CopyToReg 0x2e7f5b0, 0x2e83e40, 0x2e84540 [ORD=33]

Selecting: 0x2e7f5b0: ch,glue = callseq_start 0x2e84740, 0x2eaa180 [ORD=33] [ID=29]

ISEL: Starting pattern match on root node: 0x2e7f5b0: ch,glue = callseq_start 0x2e84740, 0x2eaa180 [ORD=33] [ID=29]

  Initial Opcode index to 95380
  Skipped scope entry (due to false predicate) at index 95390, continuing at 95401
  Morphed node: 0x2e7f5b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2eaa180, 0x2e84740 [ORD=33]

ISEL: Match complete!
=> 0x2e7f5b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2eaa180, 0x2e84740 [ORD=33]

Selecting: 0x2e84740: ch = store 0x2ea9980:1, 0x2eaa8d0, 0x2ea9780, 0x2e84940<ST4[%i.addr]> [ORD=31] [ID=28]

ISEL: Starting pattern match on root node: 0x2e84740: ch = store 0x2ea9980:1, 0x2eaa8d0, 0x2ea9780, 0x2e84940<ST4[%i.addr]> [ORD=31] [ID=28]

  Initial Opcode index to 5
  Skipped scope entry (due to false predicate) at index 13, continuing at 58
  Skipped scope entry (due to false predicate) at index 59, continuing at 104
  Skipped scope entry (due to false predicate) at index 105, continuing at 188
  Skipped scope entry (due to false predicate) at index 189, continuing at 212
  Skipped scope entry (due to false predicate) at index 213, continuing at 236
  Skipped scope entry (due to false predicate) at index 237, continuing at 260
  Match failed at index 264
  Continuing at 284
  Match failed at index 285
  Continuing at 308
  Continuing at 309
  Match failed at index 313
  Continuing at 10708
  Match failed at index 10713
  Continuing at 11131
  Match failed at index 11135
  Continuing at 11509
  Match failed at index 11513
  Continuing at 11624
  Match failed at index 11628
  Continuing at 11859
  Skipped scope entry (due to false predicate) at index 11864, continuing at 11950
  Skipped scope entry (due to false predicate) at index 11951, continuing at 12064
  Skipped scope entry (due to false predicate) at index 12065, continuing at 12137
  Skipped scope entry (due to false predicate) at index 12138, continuing at 12161
  Skipped scope entry (due to false predicate) at index 12162, continuing at 12185
MatchAddress: X86ISelAddressMode 0x7fff29e7b560
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
  Morphed node: 0x2e84740: ch = MOV32mr 0x2e84340, 0x2e84440, 0x2ea9880, 0x2e801b0, 0x2e7f3b0, 0x2eaa8d0, 0x2ea9980:1<Mem:ST4[%i.addr]> [ORD=31]

ISEL: Match complete!
=> 0x2e84740: ch = MOV32mr 0x2e84340, 0x2e84440, 0x2ea9880, 0x2e801b0, 0x2e7f3b0, 0x2eaa8d0, 0x2ea9980:1<Mem:ST4[%i.addr]> [ORD=31]

Selecting: 0x2ea9980: i64,ch,glue = CopyFromReg 0x2ea9a80, 0x2ea9b80, 0x2ea9a80:1 [ORD=29] [ID=27]

=> 0x2ea9980: i64,ch,glue = CopyFromReg 0x2ea9a80, 0x2ea9b80, 0x2ea9a80:1 [ORD=29]

Selecting: 0x2ea9a80: ch,glue = callseq_end 0x2e84140, 0x2eaa180, 0x2eaa180, 0x2e84140:1 [ORD=29] [ID=26]

ISEL: Starting pattern match on root node: 0x2ea9a80: ch,glue = callseq_end 0x2e84140, 0x2eaa180, 0x2eaa180, 0x2e84140:1 [ORD=29] [ID=26]

  Initial Opcode index to 92907
  Skipped scope entry (due to false predicate) at index 92925, continuing at 92937
  Morphed node: 0x2ea9a80: i64,ch,glue = ADJCALLSTACKUP64 0x2eaa180, 0x2eaa180, 0x2e84140, 0x2e84140:1 [ORD=29]

ISEL: Match complete!
=> 0x2ea9a80: i64,ch,glue = ADJCALLSTACKUP64 0x2eaa180, 0x2eaa180, 0x2e84140, 0x2e84140:1 [ORD=29]

Selecting: 0x2e84140: ch,glue = X86ISD::CALL 0x2ea9e80, 0x2eaa480, 0x2e83e40, 0x2ea9f80, 0x2ea9d80, 0x2ea9e80:1 [ORD=29] [ID=25]

ISEL: Starting pattern match on root node: 0x2e84140: ch,glue = X86ISD::CALL 0x2ea9e80, 0x2eaa480, 0x2e83e40, 0x2ea9f80, 0x2ea9d80, 0x2ea9e80:1 [ORD=29] [ID=25]

  Initial Opcode index to 69884
  Match failed at index 69890
  Continuing at 69951
  OpcodeSwitch from 69957 to 70015
  Match failed at index 70015
  Continuing at 70031
  Match failed at index 70032
  Continuing at 70044
  Morphed node: 0x2e84140: ch,glue = CALL64r 0x2eaa480, 0x2e83e40, 0x2ea9f80, 0x2ea9d80, 0x2ea9e80, 0x2ea9e80:1 [ORD=29]

ISEL: Match complete!
=> 0x2e84140: ch,glue = CALL64r 0x2eaa480, 0x2e83e40, 0x2ea9f80, 0x2ea9d80, 0x2ea9e80, 0x2ea9e80:1 [ORD=29]

Selecting: 0x2ea9e80: ch,glue = CopyToReg 0x2e7f6b0, 0x2ea9f80, 0x2eaa280, 0x2e7f6b0:1 [ORD=29] [ID=24]

=> 0x2ea9e80: ch,glue = CopyToReg 0x2e7f6b0, 0x2ea9f80, 0x2eaa280, 0x2e7f6b0:1 [ORD=29]

Selecting: 0x2e7f6b0: ch,glue = CopyToReg 0x2eaa080, 0x2e83e40, 0x2eaa380 [ORD=29] [ID=23]

=> 0x2e7f6b0: ch,glue = CopyToReg 0x2eaa080, 0x2e83e40, 0x2eaa380 [ORD=29]

Selecting: 0x2e84640: i64 = X86ISD::Wrapper 0x2e83f40 [ORD=33] [ID=22]

ISEL: Starting pattern match on root node: 0x2e84640: i64 = X86ISD::Wrapper 0x2e83f40 [ORD=33] [ID=22]

  Initial Opcode index to 94787
  Match failed at index 94792
  Continuing at 94819
  OpcodeSwitch from 94824 to 94938
  TypeSwitch[i64] from 94939 to 94952
  Morphed node: 0x2e84640: i64 = MOV64ri 0x2e83f40 [ORD=33]

ISEL: Match complete!
=> 0x2e84640: i64 = MOV64ri 0x2e83f40 [ORD=33]

Selecting: 0x2e84540: i64 = X86ISD::Wrapper 0x2ea9680 [ORD=33] [ID=21]

ISEL: Starting pattern match on root node: 0x2e84540: i64 = X86ISD::Wrapper 0x2ea9680 [ORD=33] [ID=21]

  Initial Opcode index to 94787
  Match failed at index 94792
  Continuing at 94819
  OpcodeSwitch from 94824 to 94938
  TypeSwitch[i64] from 94939 to 94952
  Morphed node: 0x2e84540: i64 = MOV64ri 0x2ea9680 [ORD=33]

ISEL: Match complete!
=> 0x2e84540: i64 = MOV64ri 0x2ea9680 [ORD=33]

Selecting: 0x2eaa080: ch,glue = callseq_start 0x2e5c478, 0x2eaa180 [ORD=29] [ID=20]

ISEL: Starting pattern match on root node: 0x2eaa080: ch,glue = callseq_start 0x2e5c478, 0x2eaa180 [ORD=29] [ID=20]

  Initial Opcode index to 95380
  Skipped scope entry (due to false predicate) at index 95390, continuing at 95401
  Morphed node: 0x2eaa080: i64,ch,glue = ADJCALLSTACKDOWN64 0x2eaa180, 0x2e5c478 [ORD=29]

ISEL: Match complete!
=> 0x2eaa080: i64,ch,glue = ADJCALLSTACKDOWN64 0x2eaa180, 0x2e5c478 [ORD=29]

Selecting: 0x2eaa8d0: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=25] [ID=19]

=> 0x2eaa8d0: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=25]

Selecting: 0x2e83f40: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=33] [ID=18]

=> 0x2e83f40: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=33]

Selecting: 0x2ea9680: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=33] [ID=17]

=> 0x2ea9680: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=33]

Selecting: 0x2e84240: i32 = Register %EAX [ID=15]

=> 0x2e84240: i32 = Register %EAX

Selecting: 0x2ea9c80: i8 = Register %AL [ID=14]

=> 0x2ea9c80: i8 = Register %AL

Selecting: 0x2e7f4b0: i32 = Register %ESI [ID=13]

=> 0x2e7f4b0: i32 = Register %ESI

Selecting: 0x2e7f7b0: i8 = Constant<0> [ID=12]

ISEL: Starting pattern match on root node: 0x2e7f7b0: i8 = Constant<0> [ID=12]

  Initial Opcode index to 82786
  Match failed at index 82790
  Continuing at 82816
  Match failed at index 82818
  Continuing at 82847
  TypeSwitch[i8] from 82850 to 82863
  Created node: 0x2ea9780: i32,i32 = MOV32r0

  Morphed node: 0x2e7f7b0: i8 = EXTRACT_SUBREG 0x2ea9780, 0x2e84940

ISEL: Match complete!
=> 0x2e7f7b0: i8 = EXTRACT_SUBREG 0x2ea9780, 0x2e84940

Selecting: 0x2ea9b80: i64 = Register %RAX [ID=9]

=> 0x2ea9b80: i64 = Register %RAX

Selecting: 0x2ea9d80: Untyped = RegisterMask [ID=8]

=> 0x2ea9d80: Untyped = RegisterMask

Selecting: 0x2ea9f80: i64 = Register %RSI [ID=7]

=> 0x2ea9f80: i64 = Register %RSI

Selecting: 0x2e83e40: i64 = Register %RDI [ID=6]

=> 0x2e83e40: i64 = Register %RDI

Selecting: 0x2eaa180: i64 = TargetConstant<0> [ID=5]

=> 0x2eaa180: i64 = TargetConstant<0>

Selecting: 0x2eaa280: i64 = Constant<48397984> [ID=4]

ISEL: Starting pattern match on root node: 0x2eaa280: i64 = Constant<48397984> [ID=4]

  Initial Opcode index to 82786
  Skipped scope entry (due to false predicate) at index 82788, continuing at 82816
  Created node: 0x2e7ffb0: i32 = MOV32ri64 0x2e7f8b0

  Morphed node: 0x2eaa280: i64 = SUBREG_TO_REG 0x2eaa180, 0x2e7ffb0, 0x2e7f9b0

ISEL: Match complete!
=> 0x2eaa280: i64 = SUBREG_TO_REG 0x2eaa180, 0x2e7ffb0, 0x2e7f9b0

Selecting: 0x2eaa380: i64 = Constant<48717472> [ID=3]

ISEL: Starting pattern match on root node: 0x2eaa380: i64 = Constant<48717472> [ID=3]

  Initial Opcode index to 82786
  Skipped scope entry (due to false predicate) at index 82788, continuing at 82816
  Created node: 0x2e7feb0: i32 = MOV32ri64 0x2e7fcb0

  Morphed node: 0x2eaa380: i64 = SUBREG_TO_REG 0x2eaa180, 0x2e7feb0, 0x2e7f9b0

ISEL: Match complete!
=> 0x2eaa380: i64 = SUBREG_TO_REG 0x2eaa180, 0x2e7feb0, 0x2e7f9b0

Selecting: 0x2eaa480: i64 = Constant<8971440> [ID=2]

ISEL: Starting pattern match on root node: 0x2eaa480: i64 = Constant<8971440> [ID=2]

  Initial Opcode index to 82786
  Skipped scope entry (due to false predicate) at index 82788, continuing at 82816
  Created node: 0x2e7fab0: i32 = MOV32ri64 0x2e83b40

  Morphed node: 0x2eaa480: i64 = SUBREG_TO_REG 0x2eaa180, 0x2e7fab0, 0x2e7f9b0

ISEL: Match complete!
=> 0x2eaa480: i64 = SUBREG_TO_REG 0x2eaa180, 0x2e7fab0, 0x2e7f9b0

Selecting: 0x2eaa9d0: i32 = Register %vreg0 [ID=1]

=> 0x2eaa9d0: i32 = Register %vreg0

Selecting: 0x2e5c478: ch = EntryToken [ID=0]

=> 0x2e5c478: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: BB#0 'func:entry'
SelectionDAG has 48 nodes:
  0x2e5c478: ch = EntryToken

  0x2eaa180: i64 = TargetConstant<0>

  0x2e83e40: i64 = Register %RDI

  0x2ea9f80: i64 = Register %RSI

  0x2ea9d80: Untyped = RegisterMask

  0x2e7f4b0: i32 = Register %ESI

  0x2ea9c80: i8 = Register %AL

    0x2e5c478: <multiple use>
    0x2eaa9d0: i32 = Register %vreg0

  0x2eaa8d0: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=25]

      0x2eaa180: <multiple use>
      0x2e5c478: <multiple use>
    0x2eaa080: i64,ch,glue = ADJCALLSTACKDOWN64 0x2eaa180, 0x2e5c478 [ORD=29]

    0x2e83e40: <multiple use>
      0x2eaa180: <multiple use>
        0x2e7fcb0: i64 = TargetConstant<48717472>

      0x2e7feb0: i32 = MOV32ri64 0x2e7fcb0

      0x2e7f9b0: <multiple use>
    0x2eaa380: i64 = SUBREG_TO_REG 0x2eaa180, 0x2e7feb0, 0x2e7f9b0

  0x2e7f6b0: ch,glue = CopyToReg 0x2eaa080:1, 0x2e83e40, 0x2eaa380 [ORD=29]

    0x2e7f6b0: <multiple use>
    0x2ea9f80: <multiple use>
      0x2eaa180: <multiple use>
        0x2e7f8b0: i64 = TargetConstant<48397984>

      0x2e7ffb0: i32 = MOV32ri64 0x2e7f8b0

      0x2e7f9b0: <multiple use>
    0x2eaa280: i64 = SUBREG_TO_REG 0x2eaa180, 0x2e7ffb0, 0x2e7f9b0

    0x2e7f6b0: <multiple use>
  0x2ea9e80: ch,glue = CopyToReg 0x2e7f6b0, 0x2ea9f80, 0x2eaa280, 0x2e7f6b0:1 [ORD=29]

      0x2eaa180: <multiple use>
        0x2e83b40: i64 = TargetConstant<8971440>

      0x2e7fab0: i32 = MOV32ri64 0x2e83b40

      0x2e7f9b0: <multiple use>
    0x2eaa480: i64 = SUBREG_TO_REG 0x2eaa180, 0x2e7fab0, 0x2e7f9b0

    0x2e83e40: <multiple use>
    0x2ea9f80: <multiple use>
    0x2ea9d80: <multiple use>
    0x2ea9e80: <multiple use>
    0x2ea9e80: <multiple use>
  0x2e84140: ch,glue = CALL64r 0x2eaa480, 0x2e83e40, 0x2ea9f80, 0x2ea9d80, 0x2ea9e80, 0x2ea9e80:1 [ORD=29]

    0x2eaa180: <multiple use>
    0x2eaa180: <multiple use>
    0x2e84140: <multiple use>
    0x2e84140: <multiple use>
  0x2ea9a80: i64,ch,glue = ADJCALLSTACKUP64 0x2eaa180, 0x2eaa180, 0x2e84140, 0x2e84140:1 [ORD=29]

      0x2eaa180: <multiple use>
        0x2e84340: i64 = TargetFrameIndex<0>

        0x2e84440: i8 = TargetConstant<1>

        0x2ea9880: i64 = Register %noreg

        0x2e801b0: i32 = TargetConstant<0>

        0x2e7f3b0: i32 = Register %noreg

        0x2eaa8d0: <multiple use>
          0x2ea9a80: <multiple use>
          0x2ea9b80: i64 = Register %RAX

          0x2ea9a80: <multiple use>
        0x2ea9980: i64,ch,glue = CopyFromReg 0x2ea9a80:1, 0x2ea9b80, 0x2ea9a80:2 [ORD=29]

      0x2e84740: ch = MOV32mr 0x2e84340, 0x2e84440, 0x2ea9880, 0x2e801b0, 0x2e7f3b0, 0x2eaa8d0, 0x2ea9980:1<Mem:ST4[%i.addr]> [ORD=31]

    0x2e7f5b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2eaa180, 0x2e84740 [ORD=33]

    0x2e83e40: <multiple use>
      0x2ea9680: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=33]

    0x2e84540: i64 = MOV64ri 0x2ea9680 [ORD=33]

  0x2e7fbb0: ch,glue = CopyToReg 0x2e7f5b0:1, 0x2e83e40, 0x2e84540 [ORD=33]

    0x2e7fbb0: <multiple use>
    0x2e7f4b0: <multiple use>
    0x2eaa8d0: <multiple use>
    0x2e7fbb0: <multiple use>
  0x2e83c40: ch,glue = CopyToReg 0x2e7fbb0, 0x2e7f4b0, 0x2eaa8d0, 0x2e7fbb0:1 [ORD=33]

    0x2e83c40: <multiple use>
    0x2ea9c80: <multiple use>
      0x2ea9780: i32,i32 = MOV32r0

      0x2e84940: i32 = TargetConstant<1>

    0x2e7f7b0: i8 = EXTRACT_SUBREG 0x2ea9780, 0x2e84940

    0x2e83c40: <multiple use>
  0x2e84040: ch,glue = CopyToReg 0x2e83c40, 0x2ea9c80, 0x2e7f7b0, 0x2e83c40:1 [ORD=33]

      0x2e83f40: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=33]

    0x2e84640: i64 = MOV64ri 0x2e83f40 [ORD=33]

    0x2e83e40: <multiple use>
    0x2e7f4b0: <multiple use>
    0x2ea9c80: <multiple use>
    0x2ea9d80: <multiple use>
    0x2e84040: <multiple use>
    0x2e84040: <multiple use>
  0x2e800b0: ch,glue = CALL64r 0x2e84640, 0x2e83e40, 0x2e7f4b0, 0x2ea9c80, 0x2ea9d80, 0x2e84040, 0x2e84040:1 [ORD=33]

    0x2eaa180: <multiple use>
    0x2eaa180: <multiple use>
    0x2e800b0: <multiple use>
    0x2e800b0: <multiple use>
  0x2e7fdb0: i64,ch,glue = ADJCALLSTACKUP64 0x2eaa180, 0x2eaa180, 0x2e800b0, 0x2e800b0:1 [ORD=33]

  0x2e7f9b0: i32 = TargetConstant<4>

      0x2e7fdb0: <multiple use>
      0x2e84240: i32 = Register %EAX

      0x2e7fdb0: <multiple use>
    0x2e83d40: i32,ch,glue = CopyFromReg 0x2e7fdb0:1, 0x2e84240, 0x2e7fdb0:2 [ORD=33]

  0x2e84840: ch = RET 0x2e83d40:1 [ORD=34]


********** List Scheduling BB#0 'entry' **********
SU(0): 0x2e84840: ch = RET 0x2e83d40:1 [ORD=34] [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 0
  Predecessors:
   ch  SU(1): Latency=1

SU(1): 0x2e83d40: i32,ch,glue = CopyFromReg 0x2e7fdb0:1, 0x2e84240, 0x2e7fdb0:2 [ORD=33] [ID=1]

    0x2e7fbb0: ch,glue = CopyToReg 0x2e7f5b0:1, 0x2e83e40, 0x2e84540 [ORD=33] [ID=1]

    0x2e83c40: ch,glue = CopyToReg 0x2e7fbb0, 0x2e7f4b0, 0x2eaa8d0, 0x2e7fbb0:1 [ORD=33] [ID=1]

    0x2e84040: ch,glue = CopyToReg 0x2e83c40, 0x2ea9c80, 0x2e7f7b0, 0x2e83c40:1 [ORD=33] [ID=1]

    0x2e800b0: ch,glue = CALL64r 0x2e84640, 0x2e83e40, 0x2e7f4b0, 0x2ea9c80, 0x2ea9d80, 0x2e84040, 0x2e84040:1 [ORD=33] [ID=1]

    0x2e7fdb0: i64,ch,glue = ADJCALLSTACKUP64 0x2eaa180, 0x2eaa180, 0x2e800b0, 0x2e800b0:1 [ORD=33] [ID=1]

  # preds left       : 5
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 1
  Predecessors:
   val SU(16): Latency=1
   val SU(2): Latency=1
   val SU(4): Latency=1
   ch  SU(6): Latency=1
   val SU(5): Latency=1
  Successors:
   ch  SU(0): Latency=1

SU(2): 0x2e7f7b0: i8 = EXTRACT_SUBREG 0x2ea9780, 0x2e84940 [ID=2]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
   val SU(3): Latency=1
  Successors:
   val SU(1): Latency=1

SU(3): 0x2ea9780: i32,i32 = MOV32r0 [ID=3]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
   val SU(2): Latency=1

SU(4): 0x2eaa8d0: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=25] [ID=4]

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
   val SU(1): Latency=1
   val SU(7): Latency=1

SU(5): 0x2e84540: i64 = MOV64ri 0x2ea9680 [ORD=33] [ID=5]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
   val SU(1): Latency=1

SU(6): 0x2e7f5b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2eaa180, 0x2e84740 [ORD=33] [ID=6]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 2
  Predecessors:
   ch  SU(7): Latency=1
  Successors:
   ch  SU(1): Latency=1

SU(7): 0x2e84740: ch = MOV32mr 0x2e84340, 0x2e84440, 0x2ea9880, 0x2e801b0, 0x2e7f3b0, 0x2eaa8d0, 0x2ea9980:1<Mem:ST4[%i.addr]> [ORD=31] [ID=7]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 3
  Predecessors:
   val SU(4): Latency=1
   ch  SU(8): Latency=1
  Successors:
   ch  SU(6): Latency=1

SU(8): 0x2ea9980: i64,ch,glue = CopyFromReg 0x2ea9a80:1, 0x2ea9b80, 0x2ea9a80:2 [ORD=29] [ID=8]

    0x2e7f6b0: ch,glue = CopyToReg 0x2eaa080:1, 0x2e83e40, 0x2eaa380 [ORD=29] [ID=8]

    0x2ea9e80: ch,glue = CopyToReg 0x2e7f6b0, 0x2ea9f80, 0x2eaa280, 0x2e7f6b0:1 [ORD=29] [ID=8]

    0x2e84140: ch,glue = CALL64r 0x2eaa480, 0x2e83e40, 0x2ea9f80, 0x2ea9d80, 0x2ea9e80, 0x2ea9e80:1 [ORD=29] [ID=8]

    0x2ea9a80: i64,ch,glue = ADJCALLSTACKUP64 0x2eaa180, 0x2eaa180, 0x2e84140, 0x2e84140:1 [ORD=29] [ID=8]

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 4
  Predecessors:
   val SU(14): Latency=1
   val SU(9): Latency=1
   ch  SU(13): Latency=1
   val SU(11): Latency=1
  Successors:
   ch  SU(7): Latency=1

SU(9): 0x2eaa280: i64 = SUBREG_TO_REG 0x2eaa180, 0x2e7ffb0, 0x2e7f9b0 [ID=9]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
   val SU(10): Latency=1
  Successors:
   val SU(8): Latency=1

SU(10): 0x2e7ffb0: i32 = MOV32ri64 0x2e7f8b0 [ID=10]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
   val SU(9): Latency=1

SU(11): 0x2eaa380: i64 = SUBREG_TO_REG 0x2eaa180, 0x2e7feb0, 0x2e7f9b0 [ID=11]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
   val SU(12): Latency=1
  Successors:
   val SU(8): Latency=1

SU(12): 0x2e7feb0: i32 = MOV32ri64 0x2e7fcb0 [ID=12]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
   val SU(11): Latency=1

SU(13): 0x2eaa080: i64,ch,glue = ADJCALLSTACKDOWN64 0x2eaa180, 0x2e5c478 [ORD=29] [ID=13]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
   ch  SU(8): Latency=1

SU(14): 0x2eaa480: i64 = SUBREG_TO_REG 0x2eaa180, 0x2e7fab0, 0x2e7f9b0 [ID=14]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
   val SU(15): Latency=1
  Successors:
   val SU(8): Latency=1

SU(15): 0x2e7fab0: i32 = MOV32ri64 0x2e83b40 [ID=15]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
   val SU(14): Latency=1

SU(16): 0x2e84640: i64 = MOV64ri 0x2e83f40 [ORD=33] [ID=16]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
   val SU(1): Latency=1


Examining Available:
Height 0: SU(0): 0x2e84840: ch = RET 0x2e83d40:1 [ORD=34] [ID=0]


*** Scheduling [0]: SU(0): 0x2e84840: ch = RET 0x2e83d40:1 [ORD=34] [ID=0]


Examining Available:
Height 1: SU(1): 0x2e83d40: i32,ch,glue = CopyFromReg 0x2e7fdb0:1, 0x2e84240, 0x2e7fdb0:2 [ORD=33] [ID=1]

    0x2e7fbb0: ch,glue = CopyToReg 0x2e7f5b0:1, 0x2e83e40, 0x2e84540 [ORD=33] [ID=1]

    0x2e83c40: ch,glue = CopyToReg 0x2e7fbb0, 0x2e7f4b0, 0x2eaa8d0, 0x2e7fbb0:1 [ORD=33] [ID=1]

    0x2e84040: ch,glue = CopyToReg 0x2e83c40, 0x2ea9c80, 0x2e7f7b0, 0x2e83c40:1 [ORD=33] [ID=1]

    0x2e800b0: ch,glue = CALL64r 0x2e84640, 0x2e83e40, 0x2e7f4b0, 0x2ea9c80, 0x2ea9d80, 0x2e84040, 0x2e84040:1 [ORD=33] [ID=1]

    0x2e7fdb0: i64,ch,glue = ADJCALLSTACKUP64 0x2eaa180, 0x2eaa180, 0x2e800b0, 0x2e800b0:1 [ORD=33] [ID=1]


*** Scheduling [1]: SU(1): 0x2e83d40: i32,ch,glue = CopyFromReg 0x2e7fdb0:1, 0x2e84240, 0x2e7fdb0:2 [ORD=33] [ID=1]

    0x2e7fbb0: ch,glue = CopyToReg 0x2e7f5b0:1, 0x2e83e40, 0x2e84540 [ORD=33] [ID=1]

    0x2e83c40: ch,glue = CopyToReg 0x2e7fbb0, 0x2e7f4b0, 0x2eaa8d0, 0x2e7fbb0:1 [ORD=33] [ID=1]

    0x2e84040: ch,glue = CopyToReg 0x2e83c40, 0x2ea9c80, 0x2e7f7b0, 0x2e83c40:1 [ORD=33] [ID=1]

    0x2e800b0: ch,glue = CALL64r 0x2e84640, 0x2e83e40, 0x2e7f4b0, 0x2ea9c80, 0x2ea9d80, 0x2e84040, 0x2e84040:1 [ORD=33] [ID=1]

    0x2e7fdb0: i64,ch,glue = ADJCALLSTACKUP64 0x2eaa180, 0x2eaa180, 0x2e800b0, 0x2e800b0:1 [ORD=33] [ID=1]


Examining Available:
Height 2: SU(2): 0x2e7f7b0: i8 = EXTRACT_SUBREG 0x2ea9780, 0x2e84940 [ID=2]

Height 2: SU(16): 0x2e84640: i64 = MOV64ri 0x2e83f40 [ORD=33] [ID=16]

Height 2: SU(5): 0x2e84540: i64 = MOV64ri 0x2ea9680 [ORD=33] [ID=5]

Height 2: SU(6): 0x2e7f5b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2eaa180, 0x2e84740 [ORD=33] [ID=6]


*** Scheduling [2]: SU(2): 0x2e7f7b0: i8 = EXTRACT_SUBREG 0x2ea9780, 0x2e84940 [ID=2]


Examining Available:
Height 3: SU(3): 0x2ea9780: i32,i32 = MOV32r0 [ID=3]

Height 2: SU(16): 0x2e84640: i64 = MOV64ri 0x2e83f40 [ORD=33] [ID=16]

Height 2: SU(5): 0x2e84540: i64 = MOV64ri 0x2ea9680 [ORD=33] [ID=5]

Height 2: SU(6): 0x2e7f5b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2eaa180, 0x2e84740 [ORD=33] [ID=6]


*** Scheduling [3]: SU(3): 0x2ea9780: i32,i32 = MOV32r0 [ID=3]


Examining Available:
Height 2: SU(16): 0x2e84640: i64 = MOV64ri 0x2e83f40 [ORD=33] [ID=16]

Height 2: SU(5): 0x2e84540: i64 = MOV64ri 0x2ea9680 [ORD=33] [ID=5]

Height 2: SU(6): 0x2e7f5b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2eaa180, 0x2e84740 [ORD=33] [ID=6]


*** Scheduling [4]: SU(16): 0x2e84640: i64 = MOV64ri 0x2e83f40 [ORD=33] [ID=16]


Examining Available:
Height 2: SU(5): 0x2e84540: i64 = MOV64ri 0x2ea9680 [ORD=33] [ID=5]

Height 2: SU(6): 0x2e7f5b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2eaa180, 0x2e84740 [ORD=33] [ID=6]


*** Scheduling [5]: SU(5): 0x2e84540: i64 = MOV64ri 0x2ea9680 [ORD=33] [ID=5]


Examining Available:
Height 2: SU(6): 0x2e7f5b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2eaa180, 0x2e84740 [ORD=33] [ID=6]


*** Scheduling [6]: SU(6): 0x2e7f5b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2eaa180, 0x2e84740 [ORD=33] [ID=6]


Examining Available:
Height 7: SU(7): 0x2e84740: ch = MOV32mr 0x2e84340, 0x2e84440, 0x2ea9880, 0x2e801b0, 0x2e7f3b0, 0x2eaa8d0, 0x2ea9980:1<Mem:ST4[%i.addr]> [ORD=31] [ID=7]


*** Scheduling [7]: SU(7): 0x2e84740: ch = MOV32mr 0x2e84340, 0x2e84440, 0x2ea9880, 0x2e801b0, 0x2e7f3b0, 0x2eaa8d0, 0x2ea9980:1<Mem:ST4[%i.addr]> [ORD=31] [ID=7]


Examining Available:
Height 8: SU(8): 0x2ea9980: i64,ch,glue = CopyFromReg 0x2ea9a80:1, 0x2ea9b80, 0x2ea9a80:2 [ORD=29] [ID=8]

    0x2e7f6b0: ch,glue = CopyToReg 0x2eaa080:1, 0x2e83e40, 0x2eaa380 [ORD=29] [ID=8]

    0x2ea9e80: ch,glue = CopyToReg 0x2e7f6b0, 0x2ea9f80, 0x2eaa280, 0x2e7f6b0:1 [ORD=29] [ID=8]

    0x2e84140: ch,glue = CALL64r 0x2eaa480, 0x2e83e40, 0x2ea9f80, 0x2ea9d80, 0x2ea9e80, 0x2ea9e80:1 [ORD=29] [ID=8]

    0x2ea9a80: i64,ch,glue = ADJCALLSTACKUP64 0x2eaa180, 0x2eaa180, 0x2e84140, 0x2e84140:1 [ORD=29] [ID=8]

Height 8: SU(4): 0x2eaa8d0: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=25] [ID=4]


*** Scheduling [8]: SU(8): 0x2ea9980: i64,ch,glue = CopyFromReg 0x2ea9a80:1, 0x2ea9b80, 0x2ea9a80:2 [ORD=29] [ID=8]

    0x2e7f6b0: ch,glue = CopyToReg 0x2eaa080:1, 0x2e83e40, 0x2eaa380 [ORD=29] [ID=8]

    0x2ea9e80: ch,glue = CopyToReg 0x2e7f6b0, 0x2ea9f80, 0x2eaa280, 0x2e7f6b0:1 [ORD=29] [ID=8]

    0x2e84140: ch,glue = CALL64r 0x2eaa480, 0x2e83e40, 0x2ea9f80, 0x2ea9d80, 0x2ea9e80, 0x2ea9e80:1 [ORD=29] [ID=8]

    0x2ea9a80: i64,ch,glue = ADJCALLSTACKUP64 0x2eaa180, 0x2eaa180, 0x2e84140, 0x2e84140:1 [ORD=29] [ID=8]


Examining Available:
Height 9: SU(14): 0x2eaa480: i64 = SUBREG_TO_REG 0x2eaa180, 0x2e7fab0, 0x2e7f9b0 [ID=14]

Height 9: SU(9): 0x2eaa280: i64 = SUBREG_TO_REG 0x2eaa180, 0x2e7ffb0, 0x2e7f9b0 [ID=9]

Height 9: SU(11): 0x2eaa380: i64 = SUBREG_TO_REG 0x2eaa180, 0x2e7feb0, 0x2e7f9b0 [ID=11]

Height 9: SU(13): 0x2eaa080: i64,ch,glue = ADJCALLSTACKDOWN64 0x2eaa180, 0x2e5c478 [ORD=29] [ID=13]

Height 8: SU(4): 0x2eaa8d0: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=25] [ID=4]


*** Scheduling [9]: SU(14): 0x2eaa480: i64 = SUBREG_TO_REG 0x2eaa180, 0x2e7fab0, 0x2e7f9b0 [ID=14]


Examining Available:
Height 10: SU(15): 0x2e7fab0: i32 = MOV32ri64 0x2e83b40 [ID=15]

Height 9: SU(9): 0x2eaa280: i64 = SUBREG_TO_REG 0x2eaa180, 0x2e7ffb0, 0x2e7f9b0 [ID=9]

Height 9: SU(11): 0x2eaa380: i64 = SUBREG_TO_REG 0x2eaa180, 0x2e7feb0, 0x2e7f9b0 [ID=11]

Height 9: SU(13): 0x2eaa080: i64,ch,glue = ADJCALLSTACKDOWN64 0x2eaa180, 0x2e5c478 [ORD=29] [ID=13]

Height 8: SU(4): 0x2eaa8d0: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=25] [ID=4]


*** Scheduling [10]: SU(15): 0x2e7fab0: i32 = MOV32ri64 0x2e83b40 [ID=15]


Examining Available:
Height 9: SU(9): 0x2eaa280: i64 = SUBREG_TO_REG 0x2eaa180, 0x2e7ffb0, 0x2e7f9b0 [ID=9]

Height 9: SU(11): 0x2eaa380: i64 = SUBREG_TO_REG 0x2eaa180, 0x2e7feb0, 0x2e7f9b0 [ID=11]

Height 9: SU(13): 0x2eaa080: i64,ch,glue = ADJCALLSTACKDOWN64 0x2eaa180, 0x2e5c478 [ORD=29] [ID=13]

Height 8: SU(4): 0x2eaa8d0: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=25] [ID=4]


*** Scheduling [11]: SU(9): 0x2eaa280: i64 = SUBREG_TO_REG 0x2eaa180, 0x2e7ffb0, 0x2e7f9b0 [ID=9]


Examining Available:
Height 12: SU(10): 0x2e7ffb0: i32 = MOV32ri64 0x2e7f8b0 [ID=10]

Height 9: SU(11): 0x2eaa380: i64 = SUBREG_TO_REG 0x2eaa180, 0x2e7feb0, 0x2e7f9b0 [ID=11]

Height 9: SU(13): 0x2eaa080: i64,ch,glue = ADJCALLSTACKDOWN64 0x2eaa180, 0x2e5c478 [ORD=29] [ID=13]

Height 8: SU(4): 0x2eaa8d0: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=25] [ID=4]


*** Scheduling [12]: SU(10): 0x2e7ffb0: i32 = MOV32ri64 0x2e7f8b0 [ID=10]


Examining Available:
Height 9: SU(11): 0x2eaa380: i64 = SUBREG_TO_REG 0x2eaa180, 0x2e7feb0, 0x2e7f9b0 [ID=11]

Height 9: SU(13): 0x2eaa080: i64,ch,glue = ADJCALLSTACKDOWN64 0x2eaa180, 0x2e5c478 [ORD=29] [ID=13]

Height 8: SU(4): 0x2eaa8d0: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=25] [ID=4]


*** Scheduling [13]: SU(11): 0x2eaa380: i64 = SUBREG_TO_REG 0x2eaa180, 0x2e7feb0, 0x2e7f9b0 [ID=11]


Examining Available:
Height 14: SU(12): 0x2e7feb0: i32 = MOV32ri64 0x2e7fcb0 [ID=12]

Height 9: SU(13): 0x2eaa080: i64,ch,glue = ADJCALLSTACKDOWN64 0x2eaa180, 0x2e5c478 [ORD=29] [ID=13]

Height 8: SU(4): 0x2eaa8d0: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=25] [ID=4]


*** Scheduling [14]: SU(12): 0x2e7feb0: i32 = MOV32ri64 0x2e7fcb0 [ID=12]


Examining Available:
Height 9: SU(13): 0x2eaa080: i64,ch,glue = ADJCALLSTACKDOWN64 0x2eaa180, 0x2e5c478 [ORD=29] [ID=13]

Height 8: SU(4): 0x2eaa8d0: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=25] [ID=4]


*** Scheduling [15]: SU(13): 0x2eaa080: i64,ch,glue = ADJCALLSTACKDOWN64 0x2eaa180, 0x2e5c478 [ORD=29] [ID=13]


Examining Available:
Height 8: SU(4): 0x2eaa8d0: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=25] [ID=4]


*** Scheduling [16]: SU(4): 0x2eaa8d0: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=25] [ID=4]

*** Final schedule ***
SU(4): 0x2eaa8d0: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=25] [ID=4]

SU(13): 0x2eaa080: i64,ch,glue = ADJCALLSTACKDOWN64 0x2eaa180, 0x2e5c478 [ORD=29] [ID=13]

SU(12): 0x2e7feb0: i32 = MOV32ri64 0x2e7fcb0 [ID=12]

SU(11): 0x2eaa380: i64 = SUBREG_TO_REG 0x2eaa180, 0x2e7feb0, 0x2e7f9b0 [ID=11]

SU(10): 0x2e7ffb0: i32 = MOV32ri64 0x2e7f8b0 [ID=10]

SU(9): 0x2eaa280: i64 = SUBREG_TO_REG 0x2eaa180, 0x2e7ffb0, 0x2e7f9b0 [ID=9]

SU(15): 0x2e7fab0: i32 = MOV32ri64 0x2e83b40 [ID=15]

SU(14): 0x2eaa480: i64 = SUBREG_TO_REG 0x2eaa180, 0x2e7fab0, 0x2e7f9b0 [ID=14]

SU(8): 0x2ea9980: i64,ch,glue = CopyFromReg 0x2ea9a80:1, 0x2ea9b80, 0x2ea9a80:2 [ORD=29] [ID=8]

    0x2e7f6b0: ch,glue = CopyToReg 0x2eaa080:1, 0x2e83e40, 0x2eaa380 [ORD=29] [ID=8]

    0x2ea9e80: ch,glue = CopyToReg 0x2e7f6b0, 0x2ea9f80, 0x2eaa280, 0x2e7f6b0:1 [ORD=29] [ID=8]

    0x2e84140: ch,glue = CALL64r 0x2eaa480, 0x2e83e40, 0x2ea9f80, 0x2ea9d80, 0x2ea9e80, 0x2ea9e80:1 [ORD=29] [ID=8]

    0x2ea9a80: i64,ch,glue = ADJCALLSTACKUP64 0x2eaa180, 0x2eaa180, 0x2e84140, 0x2e84140:1 [ORD=29] [ID=8]

SU(7): 0x2e84740: ch = MOV32mr 0x2e84340, 0x2e84440, 0x2ea9880, 0x2e801b0, 0x2e7f3b0, 0x2eaa8d0, 0x2ea9980:1<Mem:ST4[%i.addr]> [ORD=31] [ID=7]

SU(6): 0x2e7f5b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2eaa180, 0x2e84740 [ORD=33] [ID=6]

SU(5): 0x2e84540: i64 = MOV64ri 0x2ea9680 [ORD=33] [ID=5]

SU(16): 0x2e84640: i64 = MOV64ri 0x2e83f40 [ORD=33] [ID=16]

SU(3): 0x2ea9780: i32,i32 = MOV32r0 [ID=3]

SU(2): 0x2e7f7b0: i8 = EXTRACT_SUBREG 0x2ea9780, 0x2e84940 [ID=2]

SU(1): 0x2e83d40: i32,ch,glue = CopyFromReg 0x2e7fdb0:1, 0x2e84240, 0x2e7fdb0:2 [ORD=33] [ID=1]

    0x2e7fbb0: ch,glue = CopyToReg 0x2e7f5b0:1, 0x2e83e40, 0x2e84540 [ORD=33] [ID=1]

    0x2e83c40: ch,glue = CopyToReg 0x2e7fbb0, 0x2e7f4b0, 0x2eaa8d0, 0x2e7fbb0:1 [ORD=33] [ID=1]

    0x2e84040: ch,glue = CopyToReg 0x2e83c40, 0x2ea9c80, 0x2e7f7b0, 0x2e83c40:1 [ORD=33] [ID=1]

    0x2e800b0: ch,glue = CALL64r 0x2e84640, 0x2e83e40, 0x2e7f4b0, 0x2ea9c80, 0x2ea9d80, 0x2e84040, 0x2e84040:1 [ORD=33] [ID=1]

    0x2e7fdb0: i64,ch,glue = ADJCALLSTACKUP64 0x2eaa180, 0x2eaa180, 0x2e800b0, 0x2e800b0:1 [ORD=33] [ID=1]

SU(0): 0x2e84840: ch = RET 0x2e83d40:1 [ORD=34] [ID=0]


Total amount of phi nodes to update: 0
# Machine code for function func: SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
48B		%vreg1<def> = MOV32ri64 48717472; GR32:%vreg1
64B		%vreg2<def> = SUBREG_TO_REG 0, %vreg1<kill>, 4; GR64:%vreg2 GR32:%vreg1
80B		%vreg3<def> = MOV32ri64 48397984; GR32:%vreg3
96B		%vreg4<def> = SUBREG_TO_REG 0, %vreg3<kill>, 4; GR64:%vreg4 GR32:%vreg3
112B		%vreg5<def> = MOV32ri64 8971440; GR32:%vreg5
128B		%vreg6<def> = SUBREG_TO_REG 0, %vreg5<kill>, 4; GR64:%vreg6 GR32:%vreg5
144B		%RDI<def> = COPY %vreg2; GR64:%vreg2
160B		%RSI<def> = COPY %vreg4; GR64:%vreg4
176B		CALL64r %vreg6<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def>; GR64:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		%vreg7<def> = COPY %RAX; GR64:%vreg7
224B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
240B		ADJCALLSTACKDOWN64 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg8<def> = MOV64ri <ga:@.str>; GR64:%vreg8
272B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
288B		%vreg10<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
304B		%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
320B		%RDI<def> = COPY %vreg8; GR64:%vreg8
336B		%ESI<def> = COPY %vreg0; GR32:%vreg0
352B		%AL<def> = COPY %vreg11; GR8:%vreg11
368B		CALL64r %vreg9<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def>; GR64:%vreg9
384B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
400B		%vreg12<def> = COPY %EAX; GR32:%vreg12
416B		RET

# End machine code for function func.

********** Stack Coloring **********
********** Function: func
Found 0 markers and 1 slots
Slot structure:
Slot #0 - 4 bytes.
Total Stack size: 4 bytes

Will not try to merge slots.
Removed 0 markers.
DeadMachineInstructionElim: DELETING: %vreg12<def> = COPY %EAX; GR32:%vreg12
DeadMachineInstructionElim: DELETING: %vreg7<def> = COPY %RAX; GR64:%vreg7
******** Pre-regalloc Machine LICM: func ********
Entering: entry
Exiting: entry
******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: func
********** PROCESS IMPLICIT DEFS **********
********** Function: func
********** REWRITING TWO-ADDR INSTRS **********
********** Function: func
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI<kill>; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
48B		%vreg1<def> = MOV32ri64 48717472; GR32:%vreg1
64B		%vreg2<def> = SUBREG_TO_REG 0, %vreg1<kill>, 4; GR64:%vreg2 GR32:%vreg1
80B		%vreg3<def> = MOV32ri64 48397984; GR32:%vreg3
96B		%vreg4<def> = SUBREG_TO_REG 0, %vreg3<kill>, 4; GR64:%vreg4 GR32:%vreg3
112B		%vreg5<def> = MOV32ri64 8971440; GR32:%vreg5
128B		%vreg6<def> = SUBREG_TO_REG 0, %vreg5<kill>, 4; GR64:%vreg6 GR32:%vreg5
144B		%RDI<def> = COPY %vreg2<kill>; GR64:%vreg2
160B		%RSI<def> = COPY %vreg4<kill>; GR64:%vreg4
176B		CALL64r %vreg6<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use,kill>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
240B		%vreg8<def> = MOV64ri <ga:@.str>; GR64:%vreg8
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
272B		%vreg10<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
288B		%vreg11<def> = COPY %vreg10:sub_8bit<kill>; GR8:%vreg11 GR32:%vreg10
304B		%RDI<def> = COPY %vreg8<kill>; GR64:%vreg8
320B		%ESI<def> = COPY %vreg0<kill>; GR32:%vreg0
336B		%AL<def> = COPY %vreg11<kill>; GR8:%vreg11
352B		CALL64r %vreg9<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use,kill>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

Computing live-in reg-units in ABI blocks.
0B	BB#0 DIL#0
Created 1 new intervals.
********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
%vreg0 [16r,320r:0)  0@16r
%vreg1 [48r,64r:0)  0@48r
%vreg2 [64r,144r:0)  0@64r
%vreg3 [80r,96r:0)  0@80r
%vreg4 [96r,160r:0)  0@96r
%vreg5 [112r,128r:0)  0@112r
%vreg6 [128r,176r:0)  0@128r
%vreg8 [240r,304r:0)  0@240r
%vreg9 [256r,352r:0)  0@256r
%vreg10 [272r,288r:0)  0@272r
%vreg11 [288r,336r:0)  0@288r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
48B		%vreg1<def> = MOV32ri64 48717472; GR32:%vreg1
64B		%vreg2<def> = SUBREG_TO_REG 0, %vreg1, 4; GR64:%vreg2 GR32:%vreg1
80B		%vreg3<def> = MOV32ri64 48397984; GR32:%vreg3
96B		%vreg4<def> = SUBREG_TO_REG 0, %vreg3, 4; GR64:%vreg4 GR32:%vreg3
112B		%vreg5<def> = MOV32ri64 8971440; GR32:%vreg5
128B		%vreg6<def> = SUBREG_TO_REG 0, %vreg5, 4; GR64:%vreg6 GR32:%vreg5
144B		%RDI<def> = COPY %vreg2; GR64:%vreg2
160B		%RSI<def> = COPY %vreg4; GR64:%vreg4
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
240B		%vreg8<def> = MOV64ri <ga:@.str>; GR64:%vreg8
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
272B		%vreg10<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
288B		%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
304B		%RDI<def> = COPY %vreg8; GR64:%vreg8
320B		%ESI<def> = COPY %vreg0; GR32:%vreg0
336B		%AL<def> = COPY %vreg11; GR8:%vreg11
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

********** SIMPLE REGISTER COALESCING **********
********** Function: func
********** JOINING INTERVALS ***********
entry:
16B	%vreg0<def> = COPY %EDI; GR32:%vreg0
	Considering merging %vreg0 with %EDI
	Can only merge into reserved registers.
64B	%vreg2<def> = SUBREG_TO_REG 0, %vreg1, 4; GR64:%vreg2 GR32:%vreg1
	Considering merging to GR64_with_sub_8bit with %vreg1 in %vreg2:sub_32bit
		RHS = %vreg1 [48r,64r:0)  0@48r
		LHS = %vreg2 [64r,144r:0)  0@64r
		merge %vreg2:0@64r into %vreg1:0@48r --> @48r
		erased:	64r	%vreg2<def> = SUBREG_TO_REG 0, %vreg1, 4; GR64:%vreg2 GR32:%vreg1
		updated: 48B	%vreg2:sub_32bit<def,read-undef> = MOV32ri64 48717472; GR64_with_sub_8bit:%vreg2
	Joined. Result = %vreg2 [48r,144r:0)  0@48r
96B	%vreg4<def> = SUBREG_TO_REG 0, %vreg3, 4; GR64:%vreg4 GR32:%vreg3
	Considering merging to GR64_with_sub_8bit with %vreg3 in %vreg4:sub_32bit
		RHS = %vreg3 [80r,96r:0)  0@80r
		LHS = %vreg4 [96r,160r:0)  0@96r
		merge %vreg4:0@96r into %vreg3:0@80r --> @80r
		erased:	96r	%vreg4<def> = SUBREG_TO_REG 0, %vreg3, 4; GR64:%vreg4 GR32:%vreg3
		updated: 80B	%vreg4:sub_32bit<def,read-undef> = MOV32ri64 48397984; GR64_with_sub_8bit:%vreg4
	Joined. Result = %vreg4 [80r,160r:0)  0@80r
128B	%vreg6<def> = SUBREG_TO_REG 0, %vreg5, 4; GR64:%vreg6 GR32:%vreg5
	Considering merging to GR64_with_sub_8bit with %vreg5 in %vreg6:sub_32bit
		RHS = %vreg5 [112r,128r:0)  0@112r
		LHS = %vreg6 [128r,176r:0)  0@128r
		merge %vreg6:0@128r into %vreg5:0@112r --> @112r
		erased:	128r	%vreg6<def> = SUBREG_TO_REG 0, %vreg5, 4; GR64:%vreg6 GR32:%vreg5
		updated: 112B	%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
	Joined. Result = %vreg6 [112r,176r:0)  0@112r
144B	%RDI<def> = COPY %vreg2; GR64_with_sub_8bit:%vreg2
	Considering merging %vreg2 with %RDI
	Can only merge into reserved registers.
Remat: %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
Shrink: %vreg2 [48r,144r:0)  0@48r
All defs dead: 48r	%vreg2:sub_32bit<def,read-undef,dead> = MOV32ri64 48717472; GR64_with_sub_8bit:%vreg2
Shrunk: %vreg2 [48r,48d:0)  0@48r
Deleting dead def 48r	%vreg2:sub_32bit<def,read-undef,dead> = MOV32ri64 48717472; GR64_with_sub_8bit:%vreg2
160B	%RSI<def> = COPY %vreg4; GR64_with_sub_8bit:%vreg4
	Considering merging %vreg4 with %RSI
	Can only merge into reserved registers.
Remat: %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
Shrink: %vreg4 [80r,160r:0)  0@80r
All defs dead: 80r	%vreg4:sub_32bit<def,read-undef,dead> = MOV32ri64 48397984; GR64_with_sub_8bit:%vreg4
Shrunk: %vreg4 [80r,80d:0)  0@80r
Deleting dead def 80r	%vreg4:sub_32bit<def,read-undef,dead> = MOV32ri64 48397984; GR64_with_sub_8bit:%vreg4
304B	%RDI<def> = COPY %vreg8; GR64:%vreg8
	Considering merging %vreg8 with %RDI
	Can only merge into reserved registers.
Remat: %RDI<def> = MOV64ri <ga:@.str>
Shrink: %vreg8 [240r,304r:0)  0@240r
All defs dead: 240r	%vreg8<def,dead> = MOV64ri <ga:@.str>; GR64:%vreg8
Shrunk: %vreg8 [240r,240d:0)  0@240r
Deleting dead def 240r	%vreg8<def,dead> = MOV64ri <ga:@.str>; GR64:%vreg8
320B	%ESI<def> = COPY %vreg0; GR32:%vreg0
	Considering merging %vreg0 with %ESI
	Can only merge into reserved registers.
336B	%AL<def> = COPY %vreg11; GR8:%vreg11
	Considering merging %vreg11 with %AL
	Can only merge into reserved registers.
288B	%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
	Considering merging to GR32 with %vreg11 in %vreg10:sub_8bit
		RHS = %vreg11 [288r,336r:0)  0@288r
		LHS = %vreg10 [272r,288r:0)  0@272r
		merge %vreg11:0@288r into %vreg10:0@272r --> @272r
		erased:	288r	%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
		updated: 336B	%AL<def> = COPY %vreg10:sub_8bit; GR32:%vreg10
	Joined. Result = %vreg10 [272r,336r:0)  0@272r
320B	%ESI<def> = COPY %vreg0; GR32:%vreg0
	Considering merging %vreg0 with %ESI
	Can only merge into reserved registers.
336B	%AL<def> = COPY %vreg10:sub_8bit; GR32:%vreg10
	Considering merging %vreg10 with %EAX
	Can only merge into reserved registers.
Remat: %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
Shrink: %vreg10 [272r,336r:0)  0@272r
All defs dead: 272r	%vreg10<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
Shrunk: %vreg10 [272r,272d:0)  0@272r
Deleting dead def 272r	%vreg10<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
320B	%ESI<def> = COPY %vreg0; GR32:%vreg0
	Considering merging %vreg0 with %ESI
	Can only merge into reserved registers.
Trying to inflate 0 regs.
********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
%vreg0 [16r,320r:0)  0@16r
%vreg6 [112r,176r:0)  0@112r
%vreg9 [256r,352r:0)  0@256r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
320B		%ESI<def> = COPY %vreg0; GR32:%vreg0
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

Before MISsched:
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

BB#0: derived from LLVM BB %entry
    Live Ins: %EDI
	%vreg0<def> = COPY %EDI; GR32:%vreg0
	ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
	%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
	%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
	CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
	ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
	ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
	%RDI<def> = MOV64ri <ga:@.str>
	%ESI<def> = COPY %vreg0; GR32:%vreg0
	%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
	CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
	ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	RET

# End machine code for function func.

********** MI Scheduling **********
func:BB#0 entry
  From: %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
    To: CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
 RegionInstrs: 4 Remaining: 9
Disabled scoreboard hazard recognizer
Disabled scoreboard hazard recognizer
SU(0):   %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   val SU(4294967295): Latency=1 Reg=%vreg9

SU(1):   %RDI<def> = MOV64ri <ga:@.str>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

SU(2):   %ESI<def> = COPY %vreg0; GR32:%vreg0
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
   ch  SU(4294967295) *: Latency=0

SU(3):   %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

Critical Path: 1
BotQ.A: 0 3 2 1 
  SU(0) ORDER                              
  SU(3) ORDER                              
  SU(2) PREG-COPY                         
Pick Bot PREG-COPY
Scheduling SU(2) %ESI<def> = COPY %vreg0; GR32:%vreg0
handleMove 320B -> 344B: %ESI<def> = COPY %vreg0; GR32:%vreg0
     SIL:	[160r,176r:0)[344r,352r:1)  0@160r 1@344r
        -->	[160r,176r:0)[344r,352r:1)  0@160r 1@344r
     %vreg0:	[16r,320r:0)  0@16r
        -->	[16r,344r:0)  0@16r
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
BotQ.A: 0 3 1 
  SU(0) ORDER                              
  SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
  Ready @1c
  BotQ.A BotLatency SU(3) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
BotQ.A: 0 1 
  SU(0) ORDER                              
  SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %RDI<def> = MOV64ri <ga:@.str>
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
Scheduling SU(0) %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
*** Final schedule for BB#0 ***
SU(0):   %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
SU(1):   %RDI<def> = MOV64ri <ga:@.str>
SU(3):   %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
SU(2):   %ESI<def> = COPY %vreg0; GR32:%vreg0

********** MI Scheduling **********
func:BB#0 entry
  From: %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
    To: CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
 RegionInstrs: 3 Remaining: 2
SU(0):   %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   val SU(4294967295): Latency=1 Reg=%vreg6

SU(1):   %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

SU(2):   %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

Critical Path: 1
BotQ.A: 0 2 1 
  SU(0) ORDER                              
  SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
  Ready @1c
  SBPort015 +1x4u
  *** Critical resource SBPort015: 0c
  SBPortAny +1x2u
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
BotQ.A: 0 1 
  SU(0) ORDER                              
  SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
Scheduling SU(0) %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 3
  Executed: 1c
  Critical: 1c, 3 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
*** Final schedule for BB#0 ***
SU(0):   %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
SU(1):   %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
SU(2):   %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>

********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
SIL [160r,176r:0)[344r,352r:1)  0@160r 1@344r
%vreg0 [16r,344r:0)  0@16r
%vreg6 [112r,176r:0)  0@112r
%vreg9 [256r,352r:0)  0@256r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
344B		%ESI<def> = COPY %vreg0; GR32:%vreg0
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

RPO[BB#0 derived from LLVM BB entry] = 1
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#0 derived from LLVM BB entry)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0.0
Frequency(BB#0 derived from LLVM BB entry) = 1.0
LoopExitProb[BB#0 derived from LLVM BB entry] = 16383 / 16384 = 99.9939% from 1 - 0.0 / 1.0.
********** COMPUTING LIVE DEBUG VARIABLES: func **********
********** DEBUG VARIABLES **********
********** GREEDY REGISTER ALLOCATION **********
********** Function: func
********** Compute Spill Weights **********
********** Function: func
********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
SIL [160r,176r:0)[344r,352r:1)  0@160r 1@344r
%vreg0 [16r,344r:0)  0@16r
%vreg6 [112r,176r:0)  0@112r
%vreg9 [256r,352r:0)  0@256r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
344B		%ESI<def> = COPY %vreg0; GR32:%vreg0
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.


selectOrSplit GR32:%vreg0 [16r,344r:0)  0@16r
hints: %EDI
missed hint %EDI
assigning %vreg0 to %EBX: BH BL

selectOrSplit GR64_with_sub_8bit:%vreg6 [112r,176r:0)  0@112r
assigning %vreg6 to %RAX: AH AL

selectOrSplit GR64:%vreg9 [256r,352r:0)  0@256r
assigning %vreg9 to %RCX: CH CL
********** REWRITE VIRTUAL REGISTERS **********
********** Function: func
********** REGISTER MAP **********
[%vreg0 -> %EBX] GR32
[%vreg6 -> %RAX] GR64_with_sub_8bit
[%vreg9 -> %RCX] GR64

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
344B		%ESI<def> = COPY %vreg0<kill>; GR32:%vreg0
352B		CALL64r %vreg9<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET
> %EBX<def> = COPY %EDI
> ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> %EAX<def> = MOV32ri64 8971440, %RAX<imp-def>
> %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
> %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
> CALL64r %RAX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>
> ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %EBX; mem:ST4[%i.addr]
> ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> %RCX<def> = MOV64ri <ga:@printf>
> %RDI<def> = MOV64ri <ga:@.str>
> %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
> %ESI<def> = COPY %EBX<kill>
> CALL64r %RCX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def,dead>
> ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> RET
********** EMITTING LIVE DEBUG VARIABLES **********
********** Stack Slot Coloring **********
********** Function: func
******** Post-regalloc Machine LICM: func ********

Setting up live-ins for BB#0 derived from entry.
Block has no FP live-ins.

FPInst:	RET
Stack contents:
Inserted instructions:
	RET
Stack contents:
alloc FI(0) at SP[-28]
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: func
real copy:   %EBX<def> = COPY %EDI
replaced by: %EBX<def> = MOV32rr %EDI
real copy:   %ESI<def> = COPY %EBX<kill>
replaced by: %ESI<def> = MOV32rr %EBX<kill>
RPO[BB#0 derived from LLVM BB entry] = 1
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#0 derived from LLVM BB entry)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0.0
Frequency(BB#0 derived from LLVM BB entry) = 1.0
LoopExitProb[BB#0 derived from LLVM BB entry] = 16383 / 16384 = 99.9939% from 1 - 0.0 / 1.0.
********** FIX EXECUTION DEPENDENCIES: VR128 **********
BB#0: entry
JITTing function 'func'
JIT: Starting CodeGen of Function func
JIT: Emitting BB0 at [0x7f7e4367b0b0]
PUSH64r %RBP<kill>, %RSP<imp-def>, %RSP<imp-use>; flags: FrameSetup
PROLOG_LABEL <MCSym=.Ltmp6>
%RBP<def> = MOV64rr %RSP; flags: FrameSetup
PROLOG_LABEL <MCSym=.Ltmp7>
PUSH64r %RBX<kill>, %RSP<imp-def>, %RSP<imp-use>; flags: FrameSetup
PUSH64r %RAX<undef>, %RSP<imp-def>, %RSP<imp-use>; flags: FrameSetup
PROLOG_LABEL <MCSym=.Ltmp8>
%EBX<def> = MOV32rr %EDI
%EAX<def> = MOV32ri64 8971440, %RAX<imp-def>
%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
CALL64r %RAX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>
MOV32mr %RBP, 1, %noreg, -12, %noreg, %EBX; mem:ST4[%i.addr]
%RCX<def> = MOV64ri <ga:@printf>
%RDI<def> = MOV64ri <ga:@.str>
%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
%ESI<def> = MOV32rr %EBX<kill>
CALL64r %RCX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def,dead>
%RSP<def,tied1> = ADD64ri8 %RSP<tied0>, 8, %EFLAGS<imp-def,dead>
%RBX<def> = POP64r %RSP<imp-def>, %RSP<imp-use>
%RBP<def> = POP64r %RSP<imp-def>, %RSP<imp-use>
RET
JIT: Finished CodeGen of [0x7f7e4367b0b0] Function: func: 61 bytes of text, 2 relocations
JIT: Binary code:
JIT: 0: 2291377285 2511378083 136228176184 941601910 
JIT: 16: 1601902231 2552226126 24493137208 24324018572 
JIT: 32: 05350132 1917200 6710217616 00127126 
JIT: 48: 22213719249 13172209255 93918196 195
Inside Func callback func
JIT: Map 'func' to [0x0]
CGP: Found      local addrmode: [Base:%i.addr]
CGP: Found      local addrmode: [Base:%i.addr]
Computing probabilities for entry



=== func
Initial selection DAG: BB#0 'func:entry'
SelectionDAG has 37 nodes:
  0x2e5c478: ch = EntryToken

  0x2e7ffb0: i64 = TargetConstant<0>

  0x2e84940: i64 = Register %RDI

      0x2e5c478: <multiple use>
      0x2e7ffb0: <multiple use>
    0x2e7f8b0: ch,glue = callseq_start 0x2e5c478, 0x2e7ffb0 [ORD=38]

    0x2e84940: <multiple use>
    0x2e7fcb0: i64 = Constant<48717472>

  0x2ea9780: ch,glue = CopyToReg 0x2e7f8b0, 0x2e84940, 0x2e7fcb0 [ORD=38]

  0x2e7f3b0: i64 = Register %RSI

    0x2ea9780: <multiple use>
    0x2e7f3b0: <multiple use>
    0x2e7f9b0: i64 = Constant<48397984>

    0x2ea9780: <multiple use>
  0x2e801b0: ch,glue = CopyToReg 0x2ea9780, 0x2e7f3b0, 0x2e7f9b0, 0x2ea9780:1 [ORD=38]

  0x2e84440: Untyped = RegisterMask

    0x2e801b0: <multiple use>
    0x2e7feb0: i64 = Constant<8971440>

    0x2e84940: <multiple use>
    0x2e7f3b0: <multiple use>
    0x2e84440: <multiple use>
    0x2e801b0: <multiple use>
  0x2e84340: ch,glue = X86ISD::CALL 0x2e801b0, 0x2e7feb0, 0x2e84940, 0x2e7f3b0, 0x2e84440, 0x2e801b0:1 [ORD=38]

    0x2e84340: <multiple use>
    0x2e7ffb0: <multiple use>
    0x2e7ffb0: <multiple use>
    0x2e84340: <multiple use>
  0x2ea9880: ch,glue = callseq_end 0x2e84340, 0x2e7ffb0, 0x2e7ffb0, 0x2e84340:1 [ORD=38]

  0x2e7fdb0: i64 = FrameIndex<0>

  0x2e800b0: i64 = Constant<0>

  0x2e84040: i64 = undef

        0x2ea9880: <multiple use>
        0x2e84840: i64 = Register %RAX

        0x2ea9880: <multiple use>
      0x2e83d40: i64,ch,glue = CopyFromReg 0x2ea9880, 0x2e84840, 0x2ea9880:1 [ORD=38]

        0x2e5c478: <multiple use>
        0x2e7fab0: i32 = Register %vreg0

      0x2e83b40: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=34]

      0x2e7fdb0: <multiple use>
      0x2e84040: <multiple use>
    0x2e83c40: ch = store 0x2e83d40:1, 0x2e83b40, 0x2e7fdb0, 0x2e84040<ST4[%i.addr]> [ORD=40]

    0x2e7fdb0: <multiple use>
    0x2e84040: <multiple use>
  0x2e7fbb0: i32,ch = load 0x2e83c40, 0x2e7fdb0, 0x2e84040<LD4[%i.addr]> [ORD=41]

      0x2e7fbb0: <multiple use>
      0x2e7ffb0: <multiple use>
    0x2ea9980: ch,glue = callseq_start 0x2e7fbb0:1, 0x2e7ffb0 [ORD=42]

    0x2e84940: <multiple use>
    0x2e84740: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=42]

  0x2e84140: ch,glue = CopyToReg 0x2ea9980, 0x2e84940, 0x2e84740 [ORD=42]

  0x2ea9e80: i32 = Register %ESI

    0x2e84140: <multiple use>
    0x2ea9e80: <multiple use>
    0x2e7fbb0: <multiple use>
    0x2e84140: <multiple use>
  0x2e7f6b0: ch,glue = CopyToReg 0x2e84140, 0x2ea9e80, 0x2e7fbb0, 0x2e84140:1 [ORD=42]

  0x2e84640: i8 = Register %AL

    0x2e7f6b0: <multiple use>
    0x2e84640: <multiple use>
    0x2ea9a80: i8 = Constant<0>

    0x2e7f6b0: <multiple use>
  0x2e84540: ch,glue = CopyToReg 0x2e7f6b0, 0x2e84640, 0x2ea9a80, 0x2e7f6b0:1 [ORD=42]

    0x2e84540: <multiple use>
    0x2e7f5b0: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=42]

    0x2e84940: <multiple use>
    0x2ea9e80: <multiple use>
    0x2e84640: <multiple use>
    0x2e84440: <multiple use>
    0x2e84540: <multiple use>
  0x2eaa080: ch,glue = X86ISD::CALL 0x2e84540, 0x2e7f5b0, 0x2e84940, 0x2ea9e80, 0x2e84640, 0x2e84440, 0x2e84540:1 [ORD=42]

    0x2eaa080: <multiple use>
    0x2e7ffb0: <multiple use>
    0x2e7ffb0: <multiple use>
    0x2eaa080: <multiple use>
  0x2eaa8d0: ch,glue = callseq_end 0x2eaa080, 0x2e7ffb0, 0x2e7ffb0, 0x2eaa080:1 [ORD=42]

      0x2eaa8d0: <multiple use>
      0x2e83f40: i32 = Register %EAX

      0x2eaa8d0: <multiple use>
    0x2ea9680: i32,ch,glue = CopyFromReg 0x2eaa8d0, 0x2e83f40, 0x2eaa8d0:1 [ORD=42]

    0x2e84240: i16 = TargetConstant<0>

  0x2ea9c80: ch = X86ISD::RET_FLAG 0x2ea9680:1, 0x2e84240 [ORD=43]



Replacing.1 0x2e7fbb0: i32,ch = load 0x2e83c40, 0x2e7fdb0, 0x2e84040<LD4[%i.addr]> [ORD=41]

With: 0x2e83b40: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=34]
 and 1 other values
Optimized lowered selection DAG: BB#0 'func:entry'
SelectionDAG has 35 nodes:
  0x2e5c478: ch = EntryToken

    0x2e5c478: <multiple use>
    0x2e7fab0: i32 = Register %vreg0

  0x2e83b40: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=34]

  0x2e7ffb0: i64 = TargetConstant<0>

  0x2e84940: i64 = Register %RDI

      0x2e5c478: <multiple use>
      0x2e7ffb0: <multiple use>
    0x2e7f8b0: ch,glue = callseq_start 0x2e5c478, 0x2e7ffb0 [ORD=38]

    0x2e84940: <multiple use>
    0x2e7fcb0: i64 = Constant<48717472>

  0x2ea9780: ch,glue = CopyToReg 0x2e7f8b0, 0x2e84940, 0x2e7fcb0 [ORD=38]

  0x2e7f3b0: i64 = Register %RSI

    0x2ea9780: <multiple use>
    0x2e7f3b0: <multiple use>
    0x2e7f9b0: i64 = Constant<48397984>

    0x2ea9780: <multiple use>
  0x2e801b0: ch,glue = CopyToReg 0x2ea9780, 0x2e7f3b0, 0x2e7f9b0, 0x2ea9780:1 [ORD=38]

  0x2e84440: Untyped = RegisterMask

    0x2e801b0: <multiple use>
    0x2e7feb0: i64 = Constant<8971440>

    0x2e84940: <multiple use>
    0x2e7f3b0: <multiple use>
    0x2e84440: <multiple use>
    0x2e801b0: <multiple use>
  0x2e84340: ch,glue = X86ISD::CALL 0x2e801b0, 0x2e7feb0, 0x2e84940, 0x2e7f3b0, 0x2e84440, 0x2e801b0:1 [ORD=38]

    0x2e84340: <multiple use>
    0x2e7ffb0: <multiple use>
    0x2e7ffb0: <multiple use>
    0x2e84340: <multiple use>
  0x2ea9880: ch,glue = callseq_end 0x2e84340, 0x2e7ffb0, 0x2e7ffb0, 0x2e84340:1 [ORD=38]

          0x2ea9880: <multiple use>
          0x2e84840: i64 = Register %RAX

          0x2ea9880: <multiple use>
        0x2e83d40: i64,ch,glue = CopyFromReg 0x2ea9880, 0x2e84840, 0x2ea9880:1 [ORD=38]

        0x2e83b40: <multiple use>
        0x2e7fdb0: i64 = FrameIndex<0>

        0x2e84040: i64 = undef

      0x2e83c40: ch = store 0x2e83d40:1, 0x2e83b40, 0x2e7fdb0, 0x2e84040<ST4[%i.addr]> [ORD=40]

      0x2e7ffb0: <multiple use>
    0x2ea9980: ch,glue = callseq_start 0x2e83c40, 0x2e7ffb0 [ORD=42]

    0x2e84940: <multiple use>
    0x2e84740: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=42]

  0x2e84140: ch,glue = CopyToReg 0x2ea9980, 0x2e84940, 0x2e84740 [ORD=42]

  0x2ea9e80: i32 = Register %ESI

    0x2e84140: <multiple use>
    0x2ea9e80: <multiple use>
    0x2e83b40: <multiple use>
    0x2e84140: <multiple use>
  0x2e7f6b0: ch,glue = CopyToReg 0x2e84140, 0x2ea9e80, 0x2e83b40, 0x2e84140:1 [ORD=42]

  0x2e84640: i8 = Register %AL

    0x2e7f6b0: <multiple use>
    0x2e84640: <multiple use>
    0x2ea9a80: i8 = Constant<0>

    0x2e7f6b0: <multiple use>
  0x2e84540: ch,glue = CopyToReg 0x2e7f6b0, 0x2e84640, 0x2ea9a80, 0x2e7f6b0:1 [ORD=42]

    0x2e84540: <multiple use>
    0x2e7f5b0: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=42]

    0x2e84940: <multiple use>
    0x2ea9e80: <multiple use>
    0x2e84640: <multiple use>
    0x2e84440: <multiple use>
    0x2e84540: <multiple use>
  0x2eaa080: ch,glue = X86ISD::CALL 0x2e84540, 0x2e7f5b0, 0x2e84940, 0x2ea9e80, 0x2e84640, 0x2e84440, 0x2e84540:1 [ORD=42]

    0x2eaa080: <multiple use>
    0x2e7ffb0: <multiple use>
    0x2e7ffb0: <multiple use>
    0x2eaa080: <multiple use>
  0x2eaa8d0: ch,glue = callseq_end 0x2eaa080, 0x2e7ffb0, 0x2e7ffb0, 0x2eaa080:1 [ORD=42]

      0x2eaa8d0: <multiple use>
      0x2e83f40: i32 = Register %EAX

      0x2eaa8d0: <multiple use>
    0x2ea9680: i32,ch,glue = CopyFromReg 0x2eaa8d0, 0x2e83f40, 0x2eaa8d0:1 [ORD=42]

    0x2e84240: i16 = TargetConstant<0>

  0x2ea9c80: ch = X86ISD::RET_FLAG 0x2ea9680:1, 0x2e84240 [ORD=43]


Legally typed node: 0x2e84240: i16 = TargetConstant<0> [ID=0]

Legally typed node: 0x2e83f40: i32 = Register %EAX [ID=0]

Legally typed node: 0x2e84640: i8 = Register %AL [ID=0]

Legally typed node: 0x2ea9e80: i32 = Register %ESI [ID=0]

Legally typed node: 0x2ea9a80: i8 = Constant<0> [ID=0]

Legally typed node: 0x2e84740: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=42] [ID=0]

Legally typed node: 0x2e7f5b0: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=42] [ID=0]

Legally typed node: 0x2e84040: i64 = undef [ID=0]

Legally typed node: 0x2e7fdb0: i64 = FrameIndex<0> [ID=0]

Legally typed node: 0x2e84840: i64 = Register %RAX [ID=0]

Legally typed node: 0x2e84440: Untyped = RegisterMask [ID=0]

Legally typed node: 0x2e7f3b0: i64 = Register %RSI [ID=0]

Legally typed node: 0x2e84940: i64 = Register %RDI [ID=0]

Legally typed node: 0x2e7ffb0: i64 = TargetConstant<0> [ID=0]

Legally typed node: 0x2e7f9b0: i64 = Constant<48397984> [ID=0]

Legally typed node: 0x2e7fcb0: i64 = Constant<48717472> [ID=0]

Legally typed node: 0x2e7feb0: i64 = Constant<8971440> [ID=0]

Legally typed node: 0x2e7fab0: i32 = Register %vreg0 [ID=0]

Legally typed node: 0x2e5c478: ch = EntryToken [ID=0]

Legally typed node: 0x2e83b40: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=34] [ID=0]

Legally typed node: 0x2e7f8b0: ch,glue = callseq_start 0x2e5c478, 0x2e7ffb0 [ORD=38] [ID=0]

Legally typed node: 0x2ea9780: ch,glue = CopyToReg 0x2e7f8b0, 0x2e84940, 0x2e7fcb0 [ORD=38] [ID=0]

Legally typed node: 0x2e801b0: ch,glue = CopyToReg 0x2ea9780, 0x2e7f3b0, 0x2e7f9b0, 0x2ea9780:1 [ORD=38] [ID=0]

Legally typed node: 0x2e84340: ch,glue = X86ISD::CALL 0x2e801b0, 0x2e7feb0, 0x2e84940, 0x2e7f3b0, 0x2e84440, 0x2e801b0:1 [ORD=38] [ID=0]

Legally typed node: 0x2ea9880: ch,glue = callseq_end 0x2e84340, 0x2e7ffb0, 0x2e7ffb0, 0x2e84340:1 [ORD=38] [ID=0]

Legally typed node: 0x2e83d40: i64,ch,glue = CopyFromReg 0x2ea9880, 0x2e84840, 0x2ea9880:1 [ORD=38] [ID=0]

Legally typed node: 0x2e83c40: ch = store 0x2e83d40:1, 0x2e83b40, 0x2e7fdb0, 0x2e84040<ST4[%i.addr]> [ORD=40] [ID=0]

Legally typed node: 0x2ea9980: ch,glue = callseq_start 0x2e83c40, 0x2e7ffb0 [ORD=42] [ID=0]

Legally typed node: 0x2e84140: ch,glue = CopyToReg 0x2ea9980, 0x2e84940, 0x2e84740 [ORD=42] [ID=0]

Legally typed node: 0x2e7f6b0: ch,glue = CopyToReg 0x2e84140, 0x2ea9e80, 0x2e83b40, 0x2e84140:1 [ORD=42] [ID=0]

Legally typed node: 0x2e84540: ch,glue = CopyToReg 0x2e7f6b0, 0x2e84640, 0x2ea9a80, 0x2e7f6b0:1 [ORD=42] [ID=0]

Legally typed node: 0x2eaa080: ch,glue = X86ISD::CALL 0x2e84540, 0x2e7f5b0, 0x2e84940, 0x2ea9e80, 0x2e84640, 0x2e84440, 0x2e84540:1 [ORD=42] [ID=0]

Legally typed node: 0x2eaa8d0: ch,glue = callseq_end 0x2eaa080, 0x2e7ffb0, 0x2e7ffb0, 0x2eaa080:1 [ORD=42] [ID=0]

Legally typed node: 0x2ea9680: i32,ch,glue = CopyFromReg 0x2eaa8d0, 0x2e83f40, 0x2eaa8d0:1 [ORD=42] [ID=0]

Legally typed node: 0x2ea9c80: ch = X86ISD::RET_FLAG 0x2ea9680:1, 0x2e84240 [ORD=43] [ID=0]

Legally typed node: 0x7fff29e7ba10: ch = handlenode 0x2ea9c80 [ID=0]

Type-legalized selection DAG: BB#0 'func:entry'
SelectionDAG has 35 nodes:
  0x2e5c478: ch = EntryToken [ID=-3]

    0x2e5c478: <multiple use>
    0x2e7fab0: i32 = Register %vreg0 [ID=-3]

  0x2e83b40: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=34] [ID=-3]

  0x2e7ffb0: i64 = TargetConstant<0> [ID=-3]

  0x2e84940: i64 = Register %RDI [ID=-3]

      0x2e5c478: <multiple use>
      0x2e7ffb0: <multiple use>
    0x2e7f8b0: ch,glue = callseq_start 0x2e5c478, 0x2e7ffb0 [ORD=38] [ID=-3]

    0x2e84940: <multiple use>
    0x2e7fcb0: i64 = Constant<48717472> [ID=-3]

  0x2ea9780: ch,glue = CopyToReg 0x2e7f8b0, 0x2e84940, 0x2e7fcb0 [ORD=38] [ID=-3]

  0x2e7f3b0: i64 = Register %RSI [ID=-3]

    0x2ea9780: <multiple use>
    0x2e7f3b0: <multiple use>
    0x2e7f9b0: i64 = Constant<48397984> [ID=-3]

    0x2ea9780: <multiple use>
  0x2e801b0: ch,glue = CopyToReg 0x2ea9780, 0x2e7f3b0, 0x2e7f9b0, 0x2ea9780:1 [ORD=38] [ID=-3]

  0x2e84440: Untyped = RegisterMask [ID=-3]

    0x2e801b0: <multiple use>
    0x2e7feb0: i64 = Constant<8971440> [ID=-3]

    0x2e84940: <multiple use>
    0x2e7f3b0: <multiple use>
    0x2e84440: <multiple use>
    0x2e801b0: <multiple use>
  0x2e84340: ch,glue = X86ISD::CALL 0x2e801b0, 0x2e7feb0, 0x2e84940, 0x2e7f3b0, 0x2e84440, 0x2e801b0:1 [ORD=38] [ID=-3]

    0x2e84340: <multiple use>
    0x2e7ffb0: <multiple use>
    0x2e7ffb0: <multiple use>
    0x2e84340: <multiple use>
  0x2ea9880: ch,glue = callseq_end 0x2e84340, 0x2e7ffb0, 0x2e7ffb0, 0x2e84340:1 [ORD=38] [ID=-3]

          0x2ea9880: <multiple use>
          0x2e84840: i64 = Register %RAX [ID=-3]

          0x2ea9880: <multiple use>
        0x2e83d40: i64,ch,glue = CopyFromReg 0x2ea9880, 0x2e84840, 0x2ea9880:1 [ORD=38] [ID=-3]

        0x2e83b40: <multiple use>
        0x2e7fdb0: i64 = FrameIndex<0> [ID=-3]

        0x2e84040: i64 = undef [ID=-3]

      0x2e83c40: ch = store 0x2e83d40:1, 0x2e83b40, 0x2e7fdb0, 0x2e84040<ST4[%i.addr]> [ORD=40] [ID=-3]

      0x2e7ffb0: <multiple use>
    0x2ea9980: ch,glue = callseq_start 0x2e83c40, 0x2e7ffb0 [ORD=42] [ID=-3]

    0x2e84940: <multiple use>
    0x2e84740: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=42] [ID=-3]

  0x2e84140: ch,glue = CopyToReg 0x2ea9980, 0x2e84940, 0x2e84740 [ORD=42] [ID=-3]

  0x2ea9e80: i32 = Register %ESI [ID=-3]

    0x2e84140: <multiple use>
    0x2ea9e80: <multiple use>
    0x2e83b40: <multiple use>
    0x2e84140: <multiple use>
  0x2e7f6b0: ch,glue = CopyToReg 0x2e84140, 0x2ea9e80, 0x2e83b40, 0x2e84140:1 [ORD=42] [ID=-3]

  0x2e84640: i8 = Register %AL [ID=-3]

    0x2e7f6b0: <multiple use>
    0x2e84640: <multiple use>
    0x2ea9a80: i8 = Constant<0> [ID=-3]

    0x2e7f6b0: <multiple use>
  0x2e84540: ch,glue = CopyToReg 0x2e7f6b0, 0x2e84640, 0x2ea9a80, 0x2e7f6b0:1 [ORD=42] [ID=-3]

    0x2e84540: <multiple use>
    0x2e7f5b0: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=42] [ID=-3]

    0x2e84940: <multiple use>
    0x2ea9e80: <multiple use>
    0x2e84640: <multiple use>
    0x2e84440: <multiple use>
    0x2e84540: <multiple use>
  0x2eaa080: ch,glue = X86ISD::CALL 0x2e84540, 0x2e7f5b0, 0x2e84940, 0x2ea9e80, 0x2e84640, 0x2e84440, 0x2e84540:1 [ORD=42] [ID=-3]

    0x2eaa080: <multiple use>
    0x2e7ffb0: <multiple use>
    0x2e7ffb0: <multiple use>
    0x2eaa080: <multiple use>
  0x2eaa8d0: ch,glue = callseq_end 0x2eaa080, 0x2e7ffb0, 0x2e7ffb0, 0x2eaa080:1 [ORD=42] [ID=-3]

      0x2eaa8d0: <multiple use>
      0x2e83f40: i32 = Register %EAX [ID=-3]

      0x2eaa8d0: <multiple use>
    0x2ea9680: i32,ch,glue = CopyFromReg 0x2eaa8d0, 0x2e83f40, 0x2eaa8d0:1 [ORD=42] [ID=-3]

    0x2e84240: i16 = TargetConstant<0> [ID=-3]

  0x2ea9c80: ch = X86ISD::RET_FLAG 0x2ea9680:1, 0x2e84240 [ORD=43] [ID=-3]


Legalized selection DAG: BB#0 'func:entry'
SelectionDAG has 37 nodes:
  0x2e5c478: ch = EntryToken [ID=0]

  0x2e7ffb0: i64 = TargetConstant<0> [ID=5]

  0x2e84940: i64 = Register %RDI [ID=6]

  0x2e7f3b0: i64 = Register %RSI [ID=7]

  0x2e84440: Untyped = RegisterMask [ID=8]

  0x2ea9e80: i32 = Register %ESI [ID=15]

  0x2e84640: i8 = Register %AL [ID=16]

    0x2e5c478: <multiple use>
    0x2e7fab0: i32 = Register %vreg0 [ID=1]

  0x2e83b40: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=34] [ID=19]

      0x2e5c478: <multiple use>
      0x2e7ffb0: <multiple use>
    0x2e7f8b0: ch,glue = callseq_start 0x2e5c478, 0x2e7ffb0 [ORD=38] [ID=20]

    0x2e84940: <multiple use>
    0x2e7fcb0: i64 = Constant<48717472> [ID=3]

  0x2ea9780: ch,glue = CopyToReg 0x2e7f8b0, 0x2e84940, 0x2e7fcb0 [ORD=38] [ID=21]

    0x2ea9780: <multiple use>
    0x2e7f3b0: <multiple use>
    0x2e7f9b0: i64 = Constant<48397984> [ID=4]

    0x2ea9780: <multiple use>
  0x2e801b0: ch,glue = CopyToReg 0x2ea9780, 0x2e7f3b0, 0x2e7f9b0, 0x2ea9780:1 [ORD=38] [ID=22]

    0x2e801b0: <multiple use>
    0x2e7feb0: i64 = Constant<8971440> [ID=2]

    0x2e84940: <multiple use>
    0x2e7f3b0: <multiple use>
    0x2e84440: <multiple use>
    0x2e801b0: <multiple use>
  0x2e84340: ch,glue = X86ISD::CALL 0x2e801b0, 0x2e7feb0, 0x2e84940, 0x2e7f3b0, 0x2e84440, 0x2e801b0:1 [ORD=38] [ID=23]

    0x2e84340: <multiple use>
    0x2e7ffb0: <multiple use>
    0x2e7ffb0: <multiple use>
    0x2e84340: <multiple use>
  0x2ea9880: ch,glue = callseq_end 0x2e84340, 0x2e7ffb0, 0x2e7ffb0, 0x2e84340:1 [ORD=38] [ID=24]

          0x2ea9880: <multiple use>
          0x2e84840: i64 = Register %RAX [ID=9]

          0x2ea9880: <multiple use>
        0x2e83d40: i64,ch,glue = CopyFromReg 0x2ea9880, 0x2e84840, 0x2ea9880:1 [ORD=38] [ID=25]

        0x2e83b40: <multiple use>
        0x2e7fdb0: i64 = FrameIndex<0> [ID=10]

        0x2e84040: i64 = undef [ID=11]

      0x2e83c40: ch = store 0x2e83d40:1, 0x2e83b40, 0x2e7fdb0, 0x2e84040<ST4[%i.addr]> [ORD=40] [ID=26]

      0x2e7ffb0: <multiple use>
    0x2ea9980: ch,glue = callseq_start 0x2e83c40, 0x2e7ffb0 [ORD=42] [ID=27]

    0x2e84940: <multiple use>
      0x2e800b0: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=42]

    0x2e7fbb0: i64 = X86ISD::Wrapper 0x2e800b0 [ORD=42]

  0x2e84140: ch,glue = CopyToReg 0x2ea9980, 0x2e84940, 0x2e7fbb0 [ORD=42] [ID=28]

    0x2e84140: <multiple use>
    0x2ea9e80: <multiple use>
    0x2e83b40: <multiple use>
    0x2e84140: <multiple use>
  0x2e7f6b0: ch,glue = CopyToReg 0x2e84140, 0x2ea9e80, 0x2e83b40, 0x2e84140:1 [ORD=42] [ID=29]

    0x2e7f6b0: <multiple use>
    0x2e84640: <multiple use>
    0x2ea9a80: i8 = Constant<0> [ID=14]

    0x2e7f6b0: <multiple use>
  0x2e84540: ch,glue = CopyToReg 0x2e7f6b0, 0x2e84640, 0x2ea9a80, 0x2e7f6b0:1 [ORD=42] [ID=30]

    0x2e84540: <multiple use>
      0x2e84740: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=42]

    0x2e7f4b0: i64 = X86ISD::Wrapper 0x2e84740 [ORD=42]

    0x2e84940: <multiple use>
    0x2ea9e80: <multiple use>
    0x2e84640: <multiple use>
    0x2e84440: <multiple use>
    0x2e84540: <multiple use>
  0x2eaa080: ch,glue = X86ISD::CALL 0x2e84540, 0x2e7f4b0, 0x2e84940, 0x2ea9e80, 0x2e84640, 0x2e84440, 0x2e84540:1 [ORD=42] [ID=31]

    0x2eaa080: <multiple use>
    0x2e7ffb0: <multiple use>
    0x2e7ffb0: <multiple use>
    0x2eaa080: <multiple use>
  0x2eaa8d0: ch,glue = callseq_end 0x2eaa080, 0x2e7ffb0, 0x2e7ffb0, 0x2eaa080:1 [ORD=42] [ID=32]

      0x2eaa8d0: <multiple use>
      0x2e83f40: i32 = Register %EAX [ID=17]

      0x2eaa8d0: <multiple use>
    0x2ea9680: i32,ch,glue = CopyFromReg 0x2eaa8d0, 0x2e83f40, 0x2eaa8d0:1 [ORD=42] [ID=33]

    0x2e84240: i16 = TargetConstant<0> [ID=18]

  0x2ea9c80: ch = X86ISD::RET_FLAG 0x2ea9680:1, 0x2e84240 [ORD=43] [ID=34]


Optimized legalized selection DAG: BB#0 'func:entry'
SelectionDAG has 37 nodes:
  0x2e5c478: ch = EntryToken [ID=0]

  0x2e7ffb0: i64 = TargetConstant<0> [ID=5]

  0x2e84940: i64 = Register %RDI [ID=6]

  0x2e7f3b0: i64 = Register %RSI [ID=7]

  0x2e84440: Untyped = RegisterMask [ID=8]

  0x2ea9e80: i32 = Register %ESI [ID=15]

  0x2e84640: i8 = Register %AL [ID=16]

    0x2e5c478: <multiple use>
    0x2e7fab0: i32 = Register %vreg0 [ID=1]

  0x2e83b40: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=34] [ID=19]

      0x2e5c478: <multiple use>
      0x2e7ffb0: <multiple use>
    0x2e7f8b0: ch,glue = callseq_start 0x2e5c478, 0x2e7ffb0 [ORD=38] [ID=20]

    0x2e84940: <multiple use>
    0x2e7fcb0: i64 = Constant<48717472> [ID=3]

  0x2ea9780: ch,glue = CopyToReg 0x2e7f8b0, 0x2e84940, 0x2e7fcb0 [ORD=38] [ID=21]

    0x2ea9780: <multiple use>
    0x2e7f3b0: <multiple use>
    0x2e7f9b0: i64 = Constant<48397984> [ID=4]

    0x2ea9780: <multiple use>
  0x2e801b0: ch,glue = CopyToReg 0x2ea9780, 0x2e7f3b0, 0x2e7f9b0, 0x2ea9780:1 [ORD=38] [ID=22]

    0x2e801b0: <multiple use>
    0x2e7feb0: i64 = Constant<8971440> [ID=2]

    0x2e84940: <multiple use>
    0x2e7f3b0: <multiple use>
    0x2e84440: <multiple use>
    0x2e801b0: <multiple use>
  0x2e84340: ch,glue = X86ISD::CALL 0x2e801b0, 0x2e7feb0, 0x2e84940, 0x2e7f3b0, 0x2e84440, 0x2e801b0:1 [ORD=38] [ID=23]

    0x2e84340: <multiple use>
    0x2e7ffb0: <multiple use>
    0x2e7ffb0: <multiple use>
    0x2e84340: <multiple use>
  0x2ea9880: ch,glue = callseq_end 0x2e84340, 0x2e7ffb0, 0x2e7ffb0, 0x2e84340:1 [ORD=38] [ID=24]

          0x2ea9880: <multiple use>
          0x2e84840: i64 = Register %RAX [ID=9]

          0x2ea9880: <multiple use>
        0x2e83d40: i64,ch,glue = CopyFromReg 0x2ea9880, 0x2e84840, 0x2ea9880:1 [ORD=38] [ID=25]

        0x2e83b40: <multiple use>
        0x2e7fdb0: i64 = FrameIndex<0> [ID=10]

        0x2e84040: i64 = undef [ID=11]

      0x2e83c40: ch = store 0x2e83d40:1, 0x2e83b40, 0x2e7fdb0, 0x2e84040<ST4[%i.addr]> [ORD=40] [ID=26]

      0x2e7ffb0: <multiple use>
    0x2ea9980: ch,glue = callseq_start 0x2e83c40, 0x2e7ffb0 [ORD=42] [ID=27]

    0x2e84940: <multiple use>
      0x2e800b0: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=42]

    0x2e7fbb0: i64 = X86ISD::Wrapper 0x2e800b0 [ORD=42]

  0x2e84140: ch,glue = CopyToReg 0x2ea9980, 0x2e84940, 0x2e7fbb0 [ORD=42] [ID=28]

    0x2e84140: <multiple use>
    0x2ea9e80: <multiple use>
    0x2e83b40: <multiple use>
    0x2e84140: <multiple use>
  0x2e7f6b0: ch,glue = CopyToReg 0x2e84140, 0x2ea9e80, 0x2e83b40, 0x2e84140:1 [ORD=42] [ID=29]

    0x2e7f6b0: <multiple use>
    0x2e84640: <multiple use>
    0x2ea9a80: i8 = Constant<0> [ID=14]

    0x2e7f6b0: <multiple use>
  0x2e84540: ch,glue = CopyToReg 0x2e7f6b0, 0x2e84640, 0x2ea9a80, 0x2e7f6b0:1 [ORD=42] [ID=30]

    0x2e84540: <multiple use>
      0x2e84740: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=42]

    0x2e7f4b0: i64 = X86ISD::Wrapper 0x2e84740 [ORD=42]

    0x2e84940: <multiple use>
    0x2ea9e80: <multiple use>
    0x2e84640: <multiple use>
    0x2e84440: <multiple use>
    0x2e84540: <multiple use>
  0x2eaa080: ch,glue = X86ISD::CALL 0x2e84540, 0x2e7f4b0, 0x2e84940, 0x2ea9e80, 0x2e84640, 0x2e84440, 0x2e84540:1 [ORD=42] [ID=31]

    0x2eaa080: <multiple use>
    0x2e7ffb0: <multiple use>
    0x2e7ffb0: <multiple use>
    0x2eaa080: <multiple use>
  0x2eaa8d0: ch,glue = callseq_end 0x2eaa080, 0x2e7ffb0, 0x2e7ffb0, 0x2eaa080:1 [ORD=42] [ID=32]

      0x2eaa8d0: <multiple use>
      0x2e83f40: i32 = Register %EAX [ID=17]

      0x2eaa8d0: <multiple use>
    0x2ea9680: i32,ch,glue = CopyFromReg 0x2eaa8d0, 0x2e83f40, 0x2eaa8d0:1 [ORD=42] [ID=33]

    0x2e84240: i16 = TargetConstant<0> [ID=18]

  0x2ea9c80: ch = X86ISD::RET_FLAG 0x2ea9680:1, 0x2e84240 [ORD=43] [ID=34]


===== Instruction selection begins: BB#0 'entry'
Selecting: 0x2ea9c80: ch = X86ISD::RET_FLAG 0x2ea9680:1, 0x2e84240 [ORD=43] [ID=36]

ISEL: Starting pattern match on root node: 0x2ea9c80: ch = X86ISD::RET_FLAG 0x2ea9680:1, 0x2e84240 [ORD=43] [ID=36]

  Initial Opcode index to 93235
  Morphed node: 0x2ea9c80: ch = RET 0x2ea9680:1 [ORD=43]

ISEL: Match complete!
=> 0x2ea9c80: ch = RET 0x2ea9680:1 [ORD=43]

Selecting: 0x2ea9680: i32,ch,glue = CopyFromReg 0x2eaa8d0, 0x2e83f40, 0x2eaa8d0:1 [ORD=42] [ID=35]

=> 0x2ea9680: i32,ch,glue = CopyFromReg 0x2eaa8d0, 0x2e83f40, 0x2eaa8d0:1 [ORD=42]

Selecting: 0x2eaa8d0: ch,glue = callseq_end 0x2eaa080, 0x2e7ffb0, 0x2e7ffb0, 0x2eaa080:1 [ORD=42] [ID=34]

ISEL: Starting pattern match on root node: 0x2eaa8d0: ch,glue = callseq_end 0x2eaa080, 0x2e7ffb0, 0x2e7ffb0, 0x2eaa080:1 [ORD=42] [ID=34]

  Initial Opcode index to 92907
  Skipped scope entry (due to false predicate) at index 92925, continuing at 92937
  Morphed node: 0x2eaa8d0: i64,ch,glue = ADJCALLSTACKUP64 0x2e7ffb0, 0x2e7ffb0, 0x2eaa080, 0x2eaa080:1 [ORD=42]

ISEL: Match complete!
=> 0x2eaa8d0: i64,ch,glue = ADJCALLSTACKUP64 0x2e7ffb0, 0x2e7ffb0, 0x2eaa080, 0x2eaa080:1 [ORD=42]

Selecting: 0x2eaa080: ch,glue = X86ISD::CALL 0x2e84540, 0x2e7f4b0, 0x2e84940, 0x2ea9e80, 0x2e84640, 0x2e84440, 0x2e84540:1 [ORD=42] [ID=33]

ISEL: Starting pattern match on root node: 0x2eaa080: ch,glue = X86ISD::CALL 0x2e84540, 0x2e7f4b0, 0x2e84940, 0x2ea9e80, 0x2e84640, 0x2e84440, 0x2e84540:1 [ORD=42] [ID=33]

  Initial Opcode index to 69884
  Match failed at index 69890
  Continuing at 69951
  Match failed at index 69957
  Continuing at 70031
  Match failed at index 70032
  Continuing at 70044
  Morphed node: 0x2eaa080: ch,glue = CALL64r 0x2e7f4b0, 0x2e84940, 0x2ea9e80, 0x2e84640, 0x2e84440, 0x2e84540, 0x2e84540:1 [ORD=42]

ISEL: Match complete!
=> 0x2eaa080: ch,glue = CALL64r 0x2e7f4b0, 0x2e84940, 0x2ea9e80, 0x2e84640, 0x2e84440, 0x2e84540, 0x2e84540:1 [ORD=42]

Selecting: 0x2e84540: ch,glue = CopyToReg 0x2e7f6b0, 0x2e84640, 0x2ea9a80, 0x2e7f6b0:1 [ORD=42] [ID=32]

=> 0x2e84540: ch,glue = CopyToReg 0x2e7f6b0, 0x2e84640, 0x2ea9a80, 0x2e7f6b0:1 [ORD=42]

Selecting: 0x2e7f6b0: ch,glue = CopyToReg 0x2e84140, 0x2ea9e80, 0x2e83b40, 0x2e84140:1 [ORD=42] [ID=31]

=> 0x2e7f6b0: ch,glue = CopyToReg 0x2e84140, 0x2ea9e80, 0x2e83b40, 0x2e84140:1 [ORD=42]

Selecting: 0x2e84140: ch,glue = CopyToReg 0x2ea9980, 0x2e84940, 0x2e7fbb0 [ORD=42] [ID=30]

=> 0x2e84140: ch,glue = CopyToReg 0x2ea9980, 0x2e84940, 0x2e7fbb0 [ORD=42]

Selecting: 0x2ea9980: ch,glue = callseq_start 0x2e83c40, 0x2e7ffb0 [ORD=42] [ID=29]

ISEL: Starting pattern match on root node: 0x2ea9980: ch,glue = callseq_start 0x2e83c40, 0x2e7ffb0 [ORD=42] [ID=29]

  Initial Opcode index to 95380
  Skipped scope entry (due to false predicate) at index 95390, continuing at 95401
  Morphed node: 0x2ea9980: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7ffb0, 0x2e83c40 [ORD=42]

ISEL: Match complete!
=> 0x2ea9980: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7ffb0, 0x2e83c40 [ORD=42]

Selecting: 0x2e83c40: ch = store 0x2e83d40:1, 0x2e83b40, 0x2e7fdb0, 0x2e84040<ST4[%i.addr]> [ORD=40] [ID=28]

ISEL: Starting pattern match on root node: 0x2e83c40: ch = store 0x2e83d40:1, 0x2e83b40, 0x2e7fdb0, 0x2e84040<ST4[%i.addr]> [ORD=40] [ID=28]

  Initial Opcode index to 5
  Skipped scope entry (due to false predicate) at index 13, continuing at 58
  Skipped scope entry (due to false predicate) at index 59, continuing at 104
  Skipped scope entry (due to false predicate) at index 105, continuing at 188
  Skipped scope entry (due to false predicate) at index 189, continuing at 212
  Skipped scope entry (due to false predicate) at index 213, continuing at 236
  Skipped scope entry (due to false predicate) at index 237, continuing at 260
  Match failed at index 264
  Continuing at 284
  Match failed at index 285
  Continuing at 308
  Continuing at 309
  Match failed at index 313
  Continuing at 10708
  Match failed at index 10713
  Continuing at 11131
  Match failed at index 11135
  Continuing at 11509
  Match failed at index 11513
  Continuing at 11624
  Match failed at index 11628
  Continuing at 11859
  Skipped scope entry (due to false predicate) at index 11864, continuing at 11950
  Skipped scope entry (due to false predicate) at index 11951, continuing at 12064
  Skipped scope entry (due to false predicate) at index 12065, continuing at 12137
  Skipped scope entry (due to false predicate) at index 12138, continuing at 12161
  Skipped scope entry (due to false predicate) at index 12162, continuing at 12185
MatchAddress: X86ISelAddressMode 0x7fff29e7b560
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
  Morphed node: 0x2e83c40: ch = MOV32mr 0x2e7f5b0, 0x2e7f7b0, 0x2e84240, 0x2ea9b80, 0x2ea9d80, 0x2e83b40, 0x2e83d40:1<Mem:ST4[%i.addr]> [ORD=40]

ISEL: Match complete!
=> 0x2e83c40: ch = MOV32mr 0x2e7f5b0, 0x2e7f7b0, 0x2e84240, 0x2ea9b80, 0x2ea9d80, 0x2e83b40, 0x2e83d40:1<Mem:ST4[%i.addr]> [ORD=40]

Selecting: 0x2e83d40: i64,ch,glue = CopyFromReg 0x2ea9880, 0x2e84840, 0x2ea9880:1 [ORD=38] [ID=27]

=> 0x2e83d40: i64,ch,glue = CopyFromReg 0x2ea9880, 0x2e84840, 0x2ea9880:1 [ORD=38]

Selecting: 0x2ea9880: ch,glue = callseq_end 0x2e84340, 0x2e7ffb0, 0x2e7ffb0, 0x2e84340:1 [ORD=38] [ID=26]

ISEL: Starting pattern match on root node: 0x2ea9880: ch,glue = callseq_end 0x2e84340, 0x2e7ffb0, 0x2e7ffb0, 0x2e84340:1 [ORD=38] [ID=26]

  Initial Opcode index to 92907
  Skipped scope entry (due to false predicate) at index 92925, continuing at 92937
  Morphed node: 0x2ea9880: i64,ch,glue = ADJCALLSTACKUP64 0x2e7ffb0, 0x2e7ffb0, 0x2e84340, 0x2e84340:1 [ORD=38]

ISEL: Match complete!
=> 0x2ea9880: i64,ch,glue = ADJCALLSTACKUP64 0x2e7ffb0, 0x2e7ffb0, 0x2e84340, 0x2e84340:1 [ORD=38]

Selecting: 0x2e84340: ch,glue = X86ISD::CALL 0x2e801b0, 0x2e7feb0, 0x2e84940, 0x2e7f3b0, 0x2e84440, 0x2e801b0:1 [ORD=38] [ID=25]

ISEL: Starting pattern match on root node: 0x2e84340: ch,glue = X86ISD::CALL 0x2e801b0, 0x2e7feb0, 0x2e84940, 0x2e7f3b0, 0x2e84440, 0x2e801b0:1 [ORD=38] [ID=25]

  Initial Opcode index to 69884
  Match failed at index 69890
  Continuing at 69951
  OpcodeSwitch from 69957 to 70015
  Match failed at index 70015
  Continuing at 70031
  Match failed at index 70032
  Continuing at 70044
  Morphed node: 0x2e84340: ch,glue = CALL64r 0x2e7feb0, 0x2e84940, 0x2e7f3b0, 0x2e84440, 0x2e801b0, 0x2e801b0:1 [ORD=38]

ISEL: Match complete!
=> 0x2e84340: ch,glue = CALL64r 0x2e7feb0, 0x2e84940, 0x2e7f3b0, 0x2e84440, 0x2e801b0, 0x2e801b0:1 [ORD=38]

Selecting: 0x2e801b0: ch,glue = CopyToReg 0x2ea9780, 0x2e7f3b0, 0x2e7f9b0, 0x2ea9780:1 [ORD=38] [ID=24]

=> 0x2e801b0: ch,glue = CopyToReg 0x2ea9780, 0x2e7f3b0, 0x2e7f9b0, 0x2ea9780:1 [ORD=38]

Selecting: 0x2ea9780: ch,glue = CopyToReg 0x2e7f8b0, 0x2e84940, 0x2e7fcb0 [ORD=38] [ID=23]

=> 0x2ea9780: ch,glue = CopyToReg 0x2e7f8b0, 0x2e84940, 0x2e7fcb0 [ORD=38]

Selecting: 0x2e7f4b0: i64 = X86ISD::Wrapper 0x2e84740 [ORD=42] [ID=22]

ISEL: Starting pattern match on root node: 0x2e7f4b0: i64 = X86ISD::Wrapper 0x2e84740 [ORD=42] [ID=22]

  Initial Opcode index to 94787
  Match failed at index 94792
  Continuing at 94819
  OpcodeSwitch from 94824 to 94938
  TypeSwitch[i64] from 94939 to 94952
  Morphed node: 0x2e7f4b0: i64 = MOV64ri 0x2e84740 [ORD=42]

ISEL: Match complete!
=> 0x2e7f4b0: i64 = MOV64ri 0x2e84740 [ORD=42]

Selecting: 0x2e7fbb0: i64 = X86ISD::Wrapper 0x2e800b0 [ORD=42] [ID=21]

ISEL: Starting pattern match on root node: 0x2e7fbb0: i64 = X86ISD::Wrapper 0x2e800b0 [ORD=42] [ID=21]

  Initial Opcode index to 94787
  Match failed at index 94792
  Continuing at 94819
  OpcodeSwitch from 94824 to 94938
  TypeSwitch[i64] from 94939 to 94952
  Morphed node: 0x2e7fbb0: i64 = MOV64ri 0x2e800b0 [ORD=42]

ISEL: Match complete!
=> 0x2e7fbb0: i64 = MOV64ri 0x2e800b0 [ORD=42]

Selecting: 0x2e7f8b0: ch,glue = callseq_start 0x2e5c478, 0x2e7ffb0 [ORD=38] [ID=20]

ISEL: Starting pattern match on root node: 0x2e7f8b0: ch,glue = callseq_start 0x2e5c478, 0x2e7ffb0 [ORD=38] [ID=20]

  Initial Opcode index to 95380
  Skipped scope entry (due to false predicate) at index 95390, continuing at 95401
  Morphed node: 0x2e7f8b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7ffb0, 0x2e5c478 [ORD=38]

ISEL: Match complete!
=> 0x2e7f8b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7ffb0, 0x2e5c478 [ORD=38]

Selecting: 0x2e83b40: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=34] [ID=19]

=> 0x2e83b40: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=34]

Selecting: 0x2e84740: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=42] [ID=18]

=> 0x2e84740: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=42]

Selecting: 0x2e800b0: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=42] [ID=17]

=> 0x2e800b0: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=42]

Selecting: 0x2e83f40: i32 = Register %EAX [ID=15]

=> 0x2e83f40: i32 = Register %EAX

Selecting: 0x2e84640: i8 = Register %AL [ID=14]

=> 0x2e84640: i8 = Register %AL

Selecting: 0x2ea9e80: i32 = Register %ESI [ID=13]

=> 0x2ea9e80: i32 = Register %ESI

Selecting: 0x2ea9a80: i8 = Constant<0> [ID=12]

ISEL: Starting pattern match on root node: 0x2ea9a80: i8 = Constant<0> [ID=12]

  Initial Opcode index to 82786
  Match failed at index 82790
  Continuing at 82816
  Match failed at index 82818
  Continuing at 82847
  TypeSwitch[i8] from 82850 to 82863
  Created node: 0x2e7fdb0: i32,i32 = MOV32r0

  Morphed node: 0x2ea9a80: i8 = EXTRACT_SUBREG 0x2e7fdb0, 0x2e84040

ISEL: Match complete!
=> 0x2ea9a80: i8 = EXTRACT_SUBREG 0x2e7fdb0, 0x2e84040

Selecting: 0x2e84840: i64 = Register %RAX [ID=9]

=> 0x2e84840: i64 = Register %RAX

Selecting: 0x2e84440: Untyped = RegisterMask [ID=8]

=> 0x2e84440: Untyped = RegisterMask

Selecting: 0x2e7f3b0: i64 = Register %RSI [ID=7]

=> 0x2e7f3b0: i64 = Register %RSI

Selecting: 0x2e84940: i64 = Register %RDI [ID=6]

=> 0x2e84940: i64 = Register %RDI

Selecting: 0x2e7ffb0: i64 = TargetConstant<0> [ID=5]

=> 0x2e7ffb0: i64 = TargetConstant<0>

Selecting: 0x2e7f9b0: i64 = Constant<48397984> [ID=4]

ISEL: Starting pattern match on root node: 0x2e7f9b0: i64 = Constant<48397984> [ID=4]

  Initial Opcode index to 82786
  Skipped scope entry (due to false predicate) at index 82788, continuing at 82816
  Created node: 0x2e83e40: i32 = MOV32ri64 0x2ea9f80

  Morphed node: 0x2e7f9b0: i64 = SUBREG_TO_REG 0x2e7ffb0, 0x2e83e40, 0x2eaa180

ISEL: Match complete!
=> 0x2e7f9b0: i64 = SUBREG_TO_REG 0x2e7ffb0, 0x2e83e40, 0x2eaa180

Selecting: 0x2e7fcb0: i64 = Constant<48717472> [ID=3]

ISEL: Starting pattern match on root node: 0x2e7fcb0: i64 = Constant<48717472> [ID=3]

  Initial Opcode index to 82786
  Skipped scope entry (due to false predicate) at index 82788, continuing at 82816
  Created node: 0x2eaa380: i32 = MOV32ri64 0x2eaa280

  Morphed node: 0x2e7fcb0: i64 = SUBREG_TO_REG 0x2e7ffb0, 0x2eaa380, 0x2eaa180

ISEL: Match complete!
=> 0x2e7fcb0: i64 = SUBREG_TO_REG 0x2e7ffb0, 0x2eaa380, 0x2eaa180

Selecting: 0x2e7feb0: i64 = Constant<8971440> [ID=2]

ISEL: Starting pattern match on root node: 0x2e7feb0: i64 = Constant<8971440> [ID=2]

  Initial Opcode index to 82786
  Skipped scope entry (due to false predicate) at index 82788, continuing at 82816
  Created node: 0x2eaa9d0: i32 = MOV32ri64 0x2eaa480

  Morphed node: 0x2e7feb0: i64 = SUBREG_TO_REG 0x2e7ffb0, 0x2eaa9d0, 0x2eaa180

ISEL: Match complete!
=> 0x2e7feb0: i64 = SUBREG_TO_REG 0x2e7ffb0, 0x2eaa9d0, 0x2eaa180

Selecting: 0x2e7fab0: i32 = Register %vreg0 [ID=1]

=> 0x2e7fab0: i32 = Register %vreg0

Selecting: 0x2e5c478: ch = EntryToken [ID=0]

=> 0x2e5c478: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: BB#0 'func:entry'
SelectionDAG has 48 nodes:
  0x2e5c478: ch = EntryToken

  0x2e7ffb0: i64 = TargetConstant<0>

  0x2e84940: i64 = Register %RDI

  0x2e7f3b0: i64 = Register %RSI

  0x2e84440: Untyped = RegisterMask

  0x2ea9e80: i32 = Register %ESI

  0x2e84640: i8 = Register %AL

    0x2e5c478: <multiple use>
    0x2e7fab0: i32 = Register %vreg0

  0x2e83b40: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=34]

      0x2e7ffb0: <multiple use>
      0x2e5c478: <multiple use>
    0x2e7f8b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7ffb0, 0x2e5c478 [ORD=38]

    0x2e84940: <multiple use>
      0x2e7ffb0: <multiple use>
        0x2eaa280: i64 = TargetConstant<48717472>

      0x2eaa380: i32 = MOV32ri64 0x2eaa280

      0x2eaa180: <multiple use>
    0x2e7fcb0: i64 = SUBREG_TO_REG 0x2e7ffb0, 0x2eaa380, 0x2eaa180

  0x2ea9780: ch,glue = CopyToReg 0x2e7f8b0:1, 0x2e84940, 0x2e7fcb0 [ORD=38]

    0x2ea9780: <multiple use>
    0x2e7f3b0: <multiple use>
      0x2e7ffb0: <multiple use>
        0x2ea9f80: i64 = TargetConstant<48397984>

      0x2e83e40: i32 = MOV32ri64 0x2ea9f80

      0x2eaa180: <multiple use>
    0x2e7f9b0: i64 = SUBREG_TO_REG 0x2e7ffb0, 0x2e83e40, 0x2eaa180

    0x2ea9780: <multiple use>
  0x2e801b0: ch,glue = CopyToReg 0x2ea9780, 0x2e7f3b0, 0x2e7f9b0, 0x2ea9780:1 [ORD=38]

      0x2e7ffb0: <multiple use>
        0x2eaa480: i64 = TargetConstant<8971440>

      0x2eaa9d0: i32 = MOV32ri64 0x2eaa480

      0x2eaa180: <multiple use>
    0x2e7feb0: i64 = SUBREG_TO_REG 0x2e7ffb0, 0x2eaa9d0, 0x2eaa180

    0x2e84940: <multiple use>
    0x2e7f3b0: <multiple use>
    0x2e84440: <multiple use>
    0x2e801b0: <multiple use>
    0x2e801b0: <multiple use>
  0x2e84340: ch,glue = CALL64r 0x2e7feb0, 0x2e84940, 0x2e7f3b0, 0x2e84440, 0x2e801b0, 0x2e801b0:1 [ORD=38]

    0x2e7ffb0: <multiple use>
    0x2e7ffb0: <multiple use>
    0x2e84340: <multiple use>
    0x2e84340: <multiple use>
  0x2ea9880: i64,ch,glue = ADJCALLSTACKUP64 0x2e7ffb0, 0x2e7ffb0, 0x2e84340, 0x2e84340:1 [ORD=38]

      0x2e7ffb0: <multiple use>
        0x2e7f5b0: i64 = TargetFrameIndex<0>

        0x2e7f7b0: i8 = TargetConstant<1>

        0x2e84240: i64 = Register %noreg

        0x2ea9b80: i32 = TargetConstant<0>

        0x2ea9d80: i32 = Register %noreg

        0x2e83b40: <multiple use>
          0x2ea9880: <multiple use>
          0x2e84840: i64 = Register %RAX

          0x2ea9880: <multiple use>
        0x2e83d40: i64,ch,glue = CopyFromReg 0x2ea9880:1, 0x2e84840, 0x2ea9880:2 [ORD=38]

      0x2e83c40: ch = MOV32mr 0x2e7f5b0, 0x2e7f7b0, 0x2e84240, 0x2ea9b80, 0x2ea9d80, 0x2e83b40, 0x2e83d40:1<Mem:ST4[%i.addr]> [ORD=40]

    0x2ea9980: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7ffb0, 0x2e83c40 [ORD=42]

    0x2e84940: <multiple use>
      0x2e800b0: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=42]

    0x2e7fbb0: i64 = MOV64ri 0x2e800b0 [ORD=42]

  0x2e84140: ch,glue = CopyToReg 0x2ea9980:1, 0x2e84940, 0x2e7fbb0 [ORD=42]

    0x2e84140: <multiple use>
    0x2ea9e80: <multiple use>
    0x2e83b40: <multiple use>
    0x2e84140: <multiple use>
  0x2e7f6b0: ch,glue = CopyToReg 0x2e84140, 0x2ea9e80, 0x2e83b40, 0x2e84140:1 [ORD=42]

    0x2e7f6b0: <multiple use>
    0x2e84640: <multiple use>
      0x2e7fdb0: i32,i32 = MOV32r0

      0x2e84040: i32 = TargetConstant<1>

    0x2ea9a80: i8 = EXTRACT_SUBREG 0x2e7fdb0, 0x2e84040

    0x2e7f6b0: <multiple use>
  0x2e84540: ch,glue = CopyToReg 0x2e7f6b0, 0x2e84640, 0x2ea9a80, 0x2e7f6b0:1 [ORD=42]

      0x2e84740: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=42]

    0x2e7f4b0: i64 = MOV64ri 0x2e84740 [ORD=42]

    0x2e84940: <multiple use>
    0x2ea9e80: <multiple use>
    0x2e84640: <multiple use>
    0x2e84440: <multiple use>
    0x2e84540: <multiple use>
    0x2e84540: <multiple use>
  0x2eaa080: ch,glue = CALL64r 0x2e7f4b0, 0x2e84940, 0x2ea9e80, 0x2e84640, 0x2e84440, 0x2e84540, 0x2e84540:1 [ORD=42]

    0x2e7ffb0: <multiple use>
    0x2e7ffb0: <multiple use>
    0x2eaa080: <multiple use>
    0x2eaa080: <multiple use>
  0x2eaa8d0: i64,ch,glue = ADJCALLSTACKUP64 0x2e7ffb0, 0x2e7ffb0, 0x2eaa080, 0x2eaa080:1 [ORD=42]

  0x2eaa180: i32 = TargetConstant<4>

      0x2eaa8d0: <multiple use>
      0x2e83f40: i32 = Register %EAX

      0x2eaa8d0: <multiple use>
    0x2ea9680: i32,ch,glue = CopyFromReg 0x2eaa8d0:1, 0x2e83f40, 0x2eaa8d0:2 [ORD=42]

  0x2ea9c80: ch = RET 0x2ea9680:1 [ORD=43]


********** List Scheduling BB#0 'entry' **********
SU(0): 0x2ea9c80: ch = RET 0x2ea9680:1 [ORD=43] [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 0
  Predecessors:
   ch  SU(1): Latency=1

SU(1): 0x2ea9680: i32,ch,glue = CopyFromReg 0x2eaa8d0:1, 0x2e83f40, 0x2eaa8d0:2 [ORD=42] [ID=1]

    0x2e84140: ch,glue = CopyToReg 0x2ea9980:1, 0x2e84940, 0x2e7fbb0 [ORD=42] [ID=1]

    0x2e7f6b0: ch,glue = CopyToReg 0x2e84140, 0x2ea9e80, 0x2e83b40, 0x2e84140:1 [ORD=42] [ID=1]

    0x2e84540: ch,glue = CopyToReg 0x2e7f6b0, 0x2e84640, 0x2ea9a80, 0x2e7f6b0:1 [ORD=42] [ID=1]

    0x2eaa080: ch,glue = CALL64r 0x2e7f4b0, 0x2e84940, 0x2ea9e80, 0x2e84640, 0x2e84440, 0x2e84540, 0x2e84540:1 [ORD=42] [ID=1]

    0x2eaa8d0: i64,ch,glue = ADJCALLSTACKUP64 0x2e7ffb0, 0x2e7ffb0, 0x2eaa080, 0x2eaa080:1 [ORD=42] [ID=1]

  # preds left       : 5
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 1
  Predecessors:
   val SU(16): Latency=1
   val SU(2): Latency=1
   val SU(4): Latency=1
   ch  SU(6): Latency=1
   val SU(5): Latency=1
  Successors:
   ch  SU(0): Latency=1

SU(2): 0x2ea9a80: i8 = EXTRACT_SUBREG 0x2e7fdb0, 0x2e84040 [ID=2]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
   val SU(3): Latency=1
  Successors:
   val SU(1): Latency=1

SU(3): 0x2e7fdb0: i32,i32 = MOV32r0 [ID=3]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
   val SU(2): Latency=1

SU(4): 0x2e83b40: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=34] [ID=4]

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
   val SU(1): Latency=1
   val SU(7): Latency=1

SU(5): 0x2e7fbb0: i64 = MOV64ri 0x2e800b0 [ORD=42] [ID=5]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
   val SU(1): Latency=1

SU(6): 0x2ea9980: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7ffb0, 0x2e83c40 [ORD=42] [ID=6]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 2
  Predecessors:
   ch  SU(7): Latency=1
  Successors:
   ch  SU(1): Latency=1

SU(7): 0x2e83c40: ch = MOV32mr 0x2e7f5b0, 0x2e7f7b0, 0x2e84240, 0x2ea9b80, 0x2ea9d80, 0x2e83b40, 0x2e83d40:1<Mem:ST4[%i.addr]> [ORD=40] [ID=7]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 3
  Predecessors:
   val SU(4): Latency=1
   ch  SU(8): Latency=1
  Successors:
   ch  SU(6): Latency=1

SU(8): 0x2e83d40: i64,ch,glue = CopyFromReg 0x2ea9880:1, 0x2e84840, 0x2ea9880:2 [ORD=38] [ID=8]

    0x2ea9780: ch,glue = CopyToReg 0x2e7f8b0:1, 0x2e84940, 0x2e7fcb0 [ORD=38] [ID=8]

    0x2e801b0: ch,glue = CopyToReg 0x2ea9780, 0x2e7f3b0, 0x2e7f9b0, 0x2ea9780:1 [ORD=38] [ID=8]

    0x2e84340: ch,glue = CALL64r 0x2e7feb0, 0x2e84940, 0x2e7f3b0, 0x2e84440, 0x2e801b0, 0x2e801b0:1 [ORD=38] [ID=8]

    0x2ea9880: i64,ch,glue = ADJCALLSTACKUP64 0x2e7ffb0, 0x2e7ffb0, 0x2e84340, 0x2e84340:1 [ORD=38] [ID=8]

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 4
  Predecessors:
   val SU(14): Latency=1
   val SU(9): Latency=1
   ch  SU(13): Latency=1
   val SU(11): Latency=1
  Successors:
   ch  SU(7): Latency=1

SU(9): 0x2e7f9b0: i64 = SUBREG_TO_REG 0x2e7ffb0, 0x2e83e40, 0x2eaa180 [ID=9]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
   val SU(10): Latency=1
  Successors:
   val SU(8): Latency=1

SU(10): 0x2e83e40: i32 = MOV32ri64 0x2ea9f80 [ID=10]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
   val SU(9): Latency=1

SU(11): 0x2e7fcb0: i64 = SUBREG_TO_REG 0x2e7ffb0, 0x2eaa380, 0x2eaa180 [ID=11]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
   val SU(12): Latency=1
  Successors:
   val SU(8): Latency=1

SU(12): 0x2eaa380: i32 = MOV32ri64 0x2eaa280 [ID=12]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
   val SU(11): Latency=1

SU(13): 0x2e7f8b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7ffb0, 0x2e5c478 [ORD=38] [ID=13]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
   ch  SU(8): Latency=1

SU(14): 0x2e7feb0: i64 = SUBREG_TO_REG 0x2e7ffb0, 0x2eaa9d0, 0x2eaa180 [ID=14]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
   val SU(15): Latency=1
  Successors:
   val SU(8): Latency=1

SU(15): 0x2eaa9d0: i32 = MOV32ri64 0x2eaa480 [ID=15]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
   val SU(14): Latency=1

SU(16): 0x2e7f4b0: i64 = MOV64ri 0x2e84740 [ORD=42] [ID=16]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
   val SU(1): Latency=1


Examining Available:
Height 0: SU(0): 0x2ea9c80: ch = RET 0x2ea9680:1 [ORD=43] [ID=0]


*** Scheduling [0]: SU(0): 0x2ea9c80: ch = RET 0x2ea9680:1 [ORD=43] [ID=0]


Examining Available:
Height 1: SU(1): 0x2ea9680: i32,ch,glue = CopyFromReg 0x2eaa8d0:1, 0x2e83f40, 0x2eaa8d0:2 [ORD=42] [ID=1]

    0x2e84140: ch,glue = CopyToReg 0x2ea9980:1, 0x2e84940, 0x2e7fbb0 [ORD=42] [ID=1]

    0x2e7f6b0: ch,glue = CopyToReg 0x2e84140, 0x2ea9e80, 0x2e83b40, 0x2e84140:1 [ORD=42] [ID=1]

    0x2e84540: ch,glue = CopyToReg 0x2e7f6b0, 0x2e84640, 0x2ea9a80, 0x2e7f6b0:1 [ORD=42] [ID=1]

    0x2eaa080: ch,glue = CALL64r 0x2e7f4b0, 0x2e84940, 0x2ea9e80, 0x2e84640, 0x2e84440, 0x2e84540, 0x2e84540:1 [ORD=42] [ID=1]

    0x2eaa8d0: i64,ch,glue = ADJCALLSTACKUP64 0x2e7ffb0, 0x2e7ffb0, 0x2eaa080, 0x2eaa080:1 [ORD=42] [ID=1]


*** Scheduling [1]: SU(1): 0x2ea9680: i32,ch,glue = CopyFromReg 0x2eaa8d0:1, 0x2e83f40, 0x2eaa8d0:2 [ORD=42] [ID=1]

    0x2e84140: ch,glue = CopyToReg 0x2ea9980:1, 0x2e84940, 0x2e7fbb0 [ORD=42] [ID=1]

    0x2e7f6b0: ch,glue = CopyToReg 0x2e84140, 0x2ea9e80, 0x2e83b40, 0x2e84140:1 [ORD=42] [ID=1]

    0x2e84540: ch,glue = CopyToReg 0x2e7f6b0, 0x2e84640, 0x2ea9a80, 0x2e7f6b0:1 [ORD=42] [ID=1]

    0x2eaa080: ch,glue = CALL64r 0x2e7f4b0, 0x2e84940, 0x2ea9e80, 0x2e84640, 0x2e84440, 0x2e84540, 0x2e84540:1 [ORD=42] [ID=1]

    0x2eaa8d0: i64,ch,glue = ADJCALLSTACKUP64 0x2e7ffb0, 0x2e7ffb0, 0x2eaa080, 0x2eaa080:1 [ORD=42] [ID=1]


Examining Available:
Height 2: SU(2): 0x2ea9a80: i8 = EXTRACT_SUBREG 0x2e7fdb0, 0x2e84040 [ID=2]

Height 2: SU(16): 0x2e7f4b0: i64 = MOV64ri 0x2e84740 [ORD=42] [ID=16]

Height 2: SU(5): 0x2e7fbb0: i64 = MOV64ri 0x2e800b0 [ORD=42] [ID=5]

Height 2: SU(6): 0x2ea9980: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7ffb0, 0x2e83c40 [ORD=42] [ID=6]


*** Scheduling [2]: SU(2): 0x2ea9a80: i8 = EXTRACT_SUBREG 0x2e7fdb0, 0x2e84040 [ID=2]


Examining Available:
Height 3: SU(3): 0x2e7fdb0: i32,i32 = MOV32r0 [ID=3]

Height 2: SU(16): 0x2e7f4b0: i64 = MOV64ri 0x2e84740 [ORD=42] [ID=16]

Height 2: SU(5): 0x2e7fbb0: i64 = MOV64ri 0x2e800b0 [ORD=42] [ID=5]

Height 2: SU(6): 0x2ea9980: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7ffb0, 0x2e83c40 [ORD=42] [ID=6]


*** Scheduling [3]: SU(3): 0x2e7fdb0: i32,i32 = MOV32r0 [ID=3]


Examining Available:
Height 2: SU(16): 0x2e7f4b0: i64 = MOV64ri 0x2e84740 [ORD=42] [ID=16]

Height 2: SU(5): 0x2e7fbb0: i64 = MOV64ri 0x2e800b0 [ORD=42] [ID=5]

Height 2: SU(6): 0x2ea9980: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7ffb0, 0x2e83c40 [ORD=42] [ID=6]


*** Scheduling [4]: SU(16): 0x2e7f4b0: i64 = MOV64ri 0x2e84740 [ORD=42] [ID=16]


Examining Available:
Height 2: SU(5): 0x2e7fbb0: i64 = MOV64ri 0x2e800b0 [ORD=42] [ID=5]

Height 2: SU(6): 0x2ea9980: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7ffb0, 0x2e83c40 [ORD=42] [ID=6]


*** Scheduling [5]: SU(5): 0x2e7fbb0: i64 = MOV64ri 0x2e800b0 [ORD=42] [ID=5]


Examining Available:
Height 2: SU(6): 0x2ea9980: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7ffb0, 0x2e83c40 [ORD=42] [ID=6]


*** Scheduling [6]: SU(6): 0x2ea9980: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7ffb0, 0x2e83c40 [ORD=42] [ID=6]


Examining Available:
Height 7: SU(7): 0x2e83c40: ch = MOV32mr 0x2e7f5b0, 0x2e7f7b0, 0x2e84240, 0x2ea9b80, 0x2ea9d80, 0x2e83b40, 0x2e83d40:1<Mem:ST4[%i.addr]> [ORD=40] [ID=7]


*** Scheduling [7]: SU(7): 0x2e83c40: ch = MOV32mr 0x2e7f5b0, 0x2e7f7b0, 0x2e84240, 0x2ea9b80, 0x2ea9d80, 0x2e83b40, 0x2e83d40:1<Mem:ST4[%i.addr]> [ORD=40] [ID=7]


Examining Available:
Height 8: SU(8): 0x2e83d40: i64,ch,glue = CopyFromReg 0x2ea9880:1, 0x2e84840, 0x2ea9880:2 [ORD=38] [ID=8]

    0x2ea9780: ch,glue = CopyToReg 0x2e7f8b0:1, 0x2e84940, 0x2e7fcb0 [ORD=38] [ID=8]

    0x2e801b0: ch,glue = CopyToReg 0x2ea9780, 0x2e7f3b0, 0x2e7f9b0, 0x2ea9780:1 [ORD=38] [ID=8]

    0x2e84340: ch,glue = CALL64r 0x2e7feb0, 0x2e84940, 0x2e7f3b0, 0x2e84440, 0x2e801b0, 0x2e801b0:1 [ORD=38] [ID=8]

    0x2ea9880: i64,ch,glue = ADJCALLSTACKUP64 0x2e7ffb0, 0x2e7ffb0, 0x2e84340, 0x2e84340:1 [ORD=38] [ID=8]

Height 8: SU(4): 0x2e83b40: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=34] [ID=4]


*** Scheduling [8]: SU(8): 0x2e83d40: i64,ch,glue = CopyFromReg 0x2ea9880:1, 0x2e84840, 0x2ea9880:2 [ORD=38] [ID=8]

    0x2ea9780: ch,glue = CopyToReg 0x2e7f8b0:1, 0x2e84940, 0x2e7fcb0 [ORD=38] [ID=8]

    0x2e801b0: ch,glue = CopyToReg 0x2ea9780, 0x2e7f3b0, 0x2e7f9b0, 0x2ea9780:1 [ORD=38] [ID=8]

    0x2e84340: ch,glue = CALL64r 0x2e7feb0, 0x2e84940, 0x2e7f3b0, 0x2e84440, 0x2e801b0, 0x2e801b0:1 [ORD=38] [ID=8]

    0x2ea9880: i64,ch,glue = ADJCALLSTACKUP64 0x2e7ffb0, 0x2e7ffb0, 0x2e84340, 0x2e84340:1 [ORD=38] [ID=8]


Examining Available:
Height 9: SU(14): 0x2e7feb0: i64 = SUBREG_TO_REG 0x2e7ffb0, 0x2eaa9d0, 0x2eaa180 [ID=14]

Height 9: SU(9): 0x2e7f9b0: i64 = SUBREG_TO_REG 0x2e7ffb0, 0x2e83e40, 0x2eaa180 [ID=9]

Height 9: SU(11): 0x2e7fcb0: i64 = SUBREG_TO_REG 0x2e7ffb0, 0x2eaa380, 0x2eaa180 [ID=11]

Height 9: SU(13): 0x2e7f8b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7ffb0, 0x2e5c478 [ORD=38] [ID=13]

Height 8: SU(4): 0x2e83b40: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=34] [ID=4]


*** Scheduling [9]: SU(14): 0x2e7feb0: i64 = SUBREG_TO_REG 0x2e7ffb0, 0x2eaa9d0, 0x2eaa180 [ID=14]


Examining Available:
Height 10: SU(15): 0x2eaa9d0: i32 = MOV32ri64 0x2eaa480 [ID=15]

Height 9: SU(9): 0x2e7f9b0: i64 = SUBREG_TO_REG 0x2e7ffb0, 0x2e83e40, 0x2eaa180 [ID=9]

Height 9: SU(11): 0x2e7fcb0: i64 = SUBREG_TO_REG 0x2e7ffb0, 0x2eaa380, 0x2eaa180 [ID=11]

Height 9: SU(13): 0x2e7f8b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7ffb0, 0x2e5c478 [ORD=38] [ID=13]

Height 8: SU(4): 0x2e83b40: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=34] [ID=4]


*** Scheduling [10]: SU(15): 0x2eaa9d0: i32 = MOV32ri64 0x2eaa480 [ID=15]


Examining Available:
Height 9: SU(9): 0x2e7f9b0: i64 = SUBREG_TO_REG 0x2e7ffb0, 0x2e83e40, 0x2eaa180 [ID=9]

Height 9: SU(11): 0x2e7fcb0: i64 = SUBREG_TO_REG 0x2e7ffb0, 0x2eaa380, 0x2eaa180 [ID=11]

Height 9: SU(13): 0x2e7f8b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7ffb0, 0x2e5c478 [ORD=38] [ID=13]

Height 8: SU(4): 0x2e83b40: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=34] [ID=4]


*** Scheduling [11]: SU(9): 0x2e7f9b0: i64 = SUBREG_TO_REG 0x2e7ffb0, 0x2e83e40, 0x2eaa180 [ID=9]


Examining Available:
Height 12: SU(10): 0x2e83e40: i32 = MOV32ri64 0x2ea9f80 [ID=10]

Height 9: SU(11): 0x2e7fcb0: i64 = SUBREG_TO_REG 0x2e7ffb0, 0x2eaa380, 0x2eaa180 [ID=11]

Height 9: SU(13): 0x2e7f8b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7ffb0, 0x2e5c478 [ORD=38] [ID=13]

Height 8: SU(4): 0x2e83b40: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=34] [ID=4]


*** Scheduling [12]: SU(10): 0x2e83e40: i32 = MOV32ri64 0x2ea9f80 [ID=10]


Examining Available:
Height 9: SU(11): 0x2e7fcb0: i64 = SUBREG_TO_REG 0x2e7ffb0, 0x2eaa380, 0x2eaa180 [ID=11]

Height 9: SU(13): 0x2e7f8b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7ffb0, 0x2e5c478 [ORD=38] [ID=13]

Height 8: SU(4): 0x2e83b40: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=34] [ID=4]


*** Scheduling [13]: SU(11): 0x2e7fcb0: i64 = SUBREG_TO_REG 0x2e7ffb0, 0x2eaa380, 0x2eaa180 [ID=11]


Examining Available:
Height 14: SU(12): 0x2eaa380: i32 = MOV32ri64 0x2eaa280 [ID=12]

Height 9: SU(13): 0x2e7f8b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7ffb0, 0x2e5c478 [ORD=38] [ID=13]

Height 8: SU(4): 0x2e83b40: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=34] [ID=4]


*** Scheduling [14]: SU(12): 0x2eaa380: i32 = MOV32ri64 0x2eaa280 [ID=12]


Examining Available:
Height 9: SU(13): 0x2e7f8b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7ffb0, 0x2e5c478 [ORD=38] [ID=13]

Height 8: SU(4): 0x2e83b40: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=34] [ID=4]


*** Scheduling [15]: SU(13): 0x2e7f8b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7ffb0, 0x2e5c478 [ORD=38] [ID=13]


Examining Available:
Height 8: SU(4): 0x2e83b40: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=34] [ID=4]


*** Scheduling [16]: SU(4): 0x2e83b40: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=34] [ID=4]

*** Final schedule ***
SU(4): 0x2e83b40: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=34] [ID=4]

SU(13): 0x2e7f8b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7ffb0, 0x2e5c478 [ORD=38] [ID=13]

SU(12): 0x2eaa380: i32 = MOV32ri64 0x2eaa280 [ID=12]

SU(11): 0x2e7fcb0: i64 = SUBREG_TO_REG 0x2e7ffb0, 0x2eaa380, 0x2eaa180 [ID=11]

SU(10): 0x2e83e40: i32 = MOV32ri64 0x2ea9f80 [ID=10]

SU(9): 0x2e7f9b0: i64 = SUBREG_TO_REG 0x2e7ffb0, 0x2e83e40, 0x2eaa180 [ID=9]

SU(15): 0x2eaa9d0: i32 = MOV32ri64 0x2eaa480 [ID=15]

SU(14): 0x2e7feb0: i64 = SUBREG_TO_REG 0x2e7ffb0, 0x2eaa9d0, 0x2eaa180 [ID=14]

SU(8): 0x2e83d40: i64,ch,glue = CopyFromReg 0x2ea9880:1, 0x2e84840, 0x2ea9880:2 [ORD=38] [ID=8]

    0x2ea9780: ch,glue = CopyToReg 0x2e7f8b0:1, 0x2e84940, 0x2e7fcb0 [ORD=38] [ID=8]

    0x2e801b0: ch,glue = CopyToReg 0x2ea9780, 0x2e7f3b0, 0x2e7f9b0, 0x2ea9780:1 [ORD=38] [ID=8]

    0x2e84340: ch,glue = CALL64r 0x2e7feb0, 0x2e84940, 0x2e7f3b0, 0x2e84440, 0x2e801b0, 0x2e801b0:1 [ORD=38] [ID=8]

    0x2ea9880: i64,ch,glue = ADJCALLSTACKUP64 0x2e7ffb0, 0x2e7ffb0, 0x2e84340, 0x2e84340:1 [ORD=38] [ID=8]

SU(7): 0x2e83c40: ch = MOV32mr 0x2e7f5b0, 0x2e7f7b0, 0x2e84240, 0x2ea9b80, 0x2ea9d80, 0x2e83b40, 0x2e83d40:1<Mem:ST4[%i.addr]> [ORD=40] [ID=7]

SU(6): 0x2ea9980: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7ffb0, 0x2e83c40 [ORD=42] [ID=6]

SU(5): 0x2e7fbb0: i64 = MOV64ri 0x2e800b0 [ORD=42] [ID=5]

SU(16): 0x2e7f4b0: i64 = MOV64ri 0x2e84740 [ORD=42] [ID=16]

SU(3): 0x2e7fdb0: i32,i32 = MOV32r0 [ID=3]

SU(2): 0x2ea9a80: i8 = EXTRACT_SUBREG 0x2e7fdb0, 0x2e84040 [ID=2]

SU(1): 0x2ea9680: i32,ch,glue = CopyFromReg 0x2eaa8d0:1, 0x2e83f40, 0x2eaa8d0:2 [ORD=42] [ID=1]

    0x2e84140: ch,glue = CopyToReg 0x2ea9980:1, 0x2e84940, 0x2e7fbb0 [ORD=42] [ID=1]

    0x2e7f6b0: ch,glue = CopyToReg 0x2e84140, 0x2ea9e80, 0x2e83b40, 0x2e84140:1 [ORD=42] [ID=1]

    0x2e84540: ch,glue = CopyToReg 0x2e7f6b0, 0x2e84640, 0x2ea9a80, 0x2e7f6b0:1 [ORD=42] [ID=1]

    0x2eaa080: ch,glue = CALL64r 0x2e7f4b0, 0x2e84940, 0x2ea9e80, 0x2e84640, 0x2e84440, 0x2e84540, 0x2e84540:1 [ORD=42] [ID=1]

    0x2eaa8d0: i64,ch,glue = ADJCALLSTACKUP64 0x2e7ffb0, 0x2e7ffb0, 0x2eaa080, 0x2eaa080:1 [ORD=42] [ID=1]

SU(0): 0x2ea9c80: ch = RET 0x2ea9680:1 [ORD=43] [ID=0]


Total amount of phi nodes to update: 0
# Machine code for function func: SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
48B		%vreg1<def> = MOV32ri64 48717472; GR32:%vreg1
64B		%vreg2<def> = SUBREG_TO_REG 0, %vreg1<kill>, 4; GR64:%vreg2 GR32:%vreg1
80B		%vreg3<def> = MOV32ri64 48397984; GR32:%vreg3
96B		%vreg4<def> = SUBREG_TO_REG 0, %vreg3<kill>, 4; GR64:%vreg4 GR32:%vreg3
112B		%vreg5<def> = MOV32ri64 8971440; GR32:%vreg5
128B		%vreg6<def> = SUBREG_TO_REG 0, %vreg5<kill>, 4; GR64:%vreg6 GR32:%vreg5
144B		%RDI<def> = COPY %vreg2; GR64:%vreg2
160B		%RSI<def> = COPY %vreg4; GR64:%vreg4
176B		CALL64r %vreg6<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def>; GR64:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		%vreg7<def> = COPY %RAX; GR64:%vreg7
224B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
240B		ADJCALLSTACKDOWN64 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg8<def> = MOV64ri <ga:@.str>; GR64:%vreg8
272B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
288B		%vreg10<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
304B		%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
320B		%RDI<def> = COPY %vreg8; GR64:%vreg8
336B		%ESI<def> = COPY %vreg0; GR32:%vreg0
352B		%AL<def> = COPY %vreg11; GR8:%vreg11
368B		CALL64r %vreg9<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def>; GR64:%vreg9
384B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
400B		%vreg12<def> = COPY %EAX; GR32:%vreg12
416B		RET

# End machine code for function func.

********** Stack Coloring **********
********** Function: func
Found 0 markers and 1 slots
Slot structure:
Slot #0 - 4 bytes.
Total Stack size: 4 bytes

Will not try to merge slots.
Removed 0 markers.
DeadMachineInstructionElim: DELETING: %vreg12<def> = COPY %EAX; GR32:%vreg12
DeadMachineInstructionElim: DELETING: %vreg7<def> = COPY %RAX; GR64:%vreg7
******** Pre-regalloc Machine LICM: func ********
Entering: entry
Exiting: entry
******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: func
********** PROCESS IMPLICIT DEFS **********
********** Function: func
********** REWRITING TWO-ADDR INSTRS **********
********** Function: func
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI<kill>; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
48B		%vreg1<def> = MOV32ri64 48717472; GR32:%vreg1
64B		%vreg2<def> = SUBREG_TO_REG 0, %vreg1<kill>, 4; GR64:%vreg2 GR32:%vreg1
80B		%vreg3<def> = MOV32ri64 48397984; GR32:%vreg3
96B		%vreg4<def> = SUBREG_TO_REG 0, %vreg3<kill>, 4; GR64:%vreg4 GR32:%vreg3
112B		%vreg5<def> = MOV32ri64 8971440; GR32:%vreg5
128B		%vreg6<def> = SUBREG_TO_REG 0, %vreg5<kill>, 4; GR64:%vreg6 GR32:%vreg5
144B		%RDI<def> = COPY %vreg2<kill>; GR64:%vreg2
160B		%RSI<def> = COPY %vreg4<kill>; GR64:%vreg4
176B		CALL64r %vreg6<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use,kill>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
240B		%vreg8<def> = MOV64ri <ga:@.str>; GR64:%vreg8
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
272B		%vreg10<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
288B		%vreg11<def> = COPY %vreg10:sub_8bit<kill>; GR8:%vreg11 GR32:%vreg10
304B		%RDI<def> = COPY %vreg8<kill>; GR64:%vreg8
320B		%ESI<def> = COPY %vreg0<kill>; GR32:%vreg0
336B		%AL<def> = COPY %vreg11<kill>; GR8:%vreg11
352B		CALL64r %vreg9<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use,kill>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

Computing live-in reg-units in ABI blocks.
0B	BB#0 DIL#0
Created 1 new intervals.
********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
%vreg0 [16r,320r:0)  0@16r
%vreg1 [48r,64r:0)  0@48r
%vreg2 [64r,144r:0)  0@64r
%vreg3 [80r,96r:0)  0@80r
%vreg4 [96r,160r:0)  0@96r
%vreg5 [112r,128r:0)  0@112r
%vreg6 [128r,176r:0)  0@128r
%vreg8 [240r,304r:0)  0@240r
%vreg9 [256r,352r:0)  0@256r
%vreg10 [272r,288r:0)  0@272r
%vreg11 [288r,336r:0)  0@288r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
48B		%vreg1<def> = MOV32ri64 48717472; GR32:%vreg1
64B		%vreg2<def> = SUBREG_TO_REG 0, %vreg1, 4; GR64:%vreg2 GR32:%vreg1
80B		%vreg3<def> = MOV32ri64 48397984; GR32:%vreg3
96B		%vreg4<def> = SUBREG_TO_REG 0, %vreg3, 4; GR64:%vreg4 GR32:%vreg3
112B		%vreg5<def> = MOV32ri64 8971440; GR32:%vreg5
128B		%vreg6<def> = SUBREG_TO_REG 0, %vreg5, 4; GR64:%vreg6 GR32:%vreg5
144B		%RDI<def> = COPY %vreg2; GR64:%vreg2
160B		%RSI<def> = COPY %vreg4; GR64:%vreg4
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
240B		%vreg8<def> = MOV64ri <ga:@.str>; GR64:%vreg8
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
272B		%vreg10<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
288B		%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
304B		%RDI<def> = COPY %vreg8; GR64:%vreg8
320B		%ESI<def> = COPY %vreg0; GR32:%vreg0
336B		%AL<def> = COPY %vreg11; GR8:%vreg11
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

********** SIMPLE REGISTER COALESCING **********
********** Function: func
********** JOINING INTERVALS ***********
entry:
16B	%vreg0<def> = COPY %EDI; GR32:%vreg0
	Considering merging %vreg0 with %EDI
	Can only merge into reserved registers.
64B	%vreg2<def> = SUBREG_TO_REG 0, %vreg1, 4; GR64:%vreg2 GR32:%vreg1
	Considering merging to GR64_with_sub_8bit with %vreg1 in %vreg2:sub_32bit
		RHS = %vreg1 [48r,64r:0)  0@48r
		LHS = %vreg2 [64r,144r:0)  0@64r
		merge %vreg2:0@64r into %vreg1:0@48r --> @48r
		erased:	64r	%vreg2<def> = SUBREG_TO_REG 0, %vreg1, 4; GR64:%vreg2 GR32:%vreg1
		updated: 48B	%vreg2:sub_32bit<def,read-undef> = MOV32ri64 48717472; GR64_with_sub_8bit:%vreg2
	Joined. Result = %vreg2 [48r,144r:0)  0@48r
96B	%vreg4<def> = SUBREG_TO_REG 0, %vreg3, 4; GR64:%vreg4 GR32:%vreg3
	Considering merging to GR64_with_sub_8bit with %vreg3 in %vreg4:sub_32bit
		RHS = %vreg3 [80r,96r:0)  0@80r
		LHS = %vreg4 [96r,160r:0)  0@96r
		merge %vreg4:0@96r into %vreg3:0@80r --> @80r
		erased:	96r	%vreg4<def> = SUBREG_TO_REG 0, %vreg3, 4; GR64:%vreg4 GR32:%vreg3
		updated: 80B	%vreg4:sub_32bit<def,read-undef> = MOV32ri64 48397984; GR64_with_sub_8bit:%vreg4
	Joined. Result = %vreg4 [80r,160r:0)  0@80r
128B	%vreg6<def> = SUBREG_TO_REG 0, %vreg5, 4; GR64:%vreg6 GR32:%vreg5
	Considering merging to GR64_with_sub_8bit with %vreg5 in %vreg6:sub_32bit
		RHS = %vreg5 [112r,128r:0)  0@112r
		LHS = %vreg6 [128r,176r:0)  0@128r
		merge %vreg6:0@128r into %vreg5:0@112r --> @112r
		erased:	128r	%vreg6<def> = SUBREG_TO_REG 0, %vreg5, 4; GR64:%vreg6 GR32:%vreg5
		updated: 112B	%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
	Joined. Result = %vreg6 [112r,176r:0)  0@112r
144B	%RDI<def> = COPY %vreg2; GR64_with_sub_8bit:%vreg2
	Considering merging %vreg2 with %RDI
	Can only merge into reserved registers.
Remat: %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
Shrink: %vreg2 [48r,144r:0)  0@48r
All defs dead: 48r	%vreg2:sub_32bit<def,read-undef,dead> = MOV32ri64 48717472; GR64_with_sub_8bit:%vreg2
Shrunk: %vreg2 [48r,48d:0)  0@48r
Deleting dead def 48r	%vreg2:sub_32bit<def,read-undef,dead> = MOV32ri64 48717472; GR64_with_sub_8bit:%vreg2
160B	%RSI<def> = COPY %vreg4; GR64_with_sub_8bit:%vreg4
	Considering merging %vreg4 with %RSI
	Can only merge into reserved registers.
Remat: %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
Shrink: %vreg4 [80r,160r:0)  0@80r
All defs dead: 80r	%vreg4:sub_32bit<def,read-undef,dead> = MOV32ri64 48397984; GR64_with_sub_8bit:%vreg4
Shrunk: %vreg4 [80r,80d:0)  0@80r
Deleting dead def 80r	%vreg4:sub_32bit<def,read-undef,dead> = MOV32ri64 48397984; GR64_with_sub_8bit:%vreg4
304B	%RDI<def> = COPY %vreg8; GR64:%vreg8
	Considering merging %vreg8 with %RDI
	Can only merge into reserved registers.
Remat: %RDI<def> = MOV64ri <ga:@.str>
Shrink: %vreg8 [240r,304r:0)  0@240r
All defs dead: 240r	%vreg8<def,dead> = MOV64ri <ga:@.str>; GR64:%vreg8
Shrunk: %vreg8 [240r,240d:0)  0@240r
Deleting dead def 240r	%vreg8<def,dead> = MOV64ri <ga:@.str>; GR64:%vreg8
320B	%ESI<def> = COPY %vreg0; GR32:%vreg0
	Considering merging %vreg0 with %ESI
	Can only merge into reserved registers.
336B	%AL<def> = COPY %vreg11; GR8:%vreg11
	Considering merging %vreg11 with %AL
	Can only merge into reserved registers.
288B	%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
	Considering merging to GR32 with %vreg11 in %vreg10:sub_8bit
		RHS = %vreg11 [288r,336r:0)  0@288r
		LHS = %vreg10 [272r,288r:0)  0@272r
		merge %vreg11:0@288r into %vreg10:0@272r --> @272r
		erased:	288r	%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
		updated: 336B	%AL<def> = COPY %vreg10:sub_8bit; GR32:%vreg10
	Joined. Result = %vreg10 [272r,336r:0)  0@272r
320B	%ESI<def> = COPY %vreg0; GR32:%vreg0
	Considering merging %vreg0 with %ESI
	Can only merge into reserved registers.
336B	%AL<def> = COPY %vreg10:sub_8bit; GR32:%vreg10
	Considering merging %vreg10 with %EAX
	Can only merge into reserved registers.
Remat: %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
Shrink: %vreg10 [272r,336r:0)  0@272r
All defs dead: 272r	%vreg10<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
Shrunk: %vreg10 [272r,272d:0)  0@272r
Deleting dead def 272r	%vreg10<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
320B	%ESI<def> = COPY %vreg0; GR32:%vreg0
	Considering merging %vreg0 with %ESI
	Can only merge into reserved registers.
Trying to inflate 0 regs.
********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
%vreg0 [16r,320r:0)  0@16r
%vreg6 [112r,176r:0)  0@112r
%vreg9 [256r,352r:0)  0@256r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
320B		%ESI<def> = COPY %vreg0; GR32:%vreg0
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

Before MISsched:
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

BB#0: derived from LLVM BB %entry
    Live Ins: %EDI
	%vreg0<def> = COPY %EDI; GR32:%vreg0
	ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
	%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
	%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
	CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
	ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
	ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
	%RDI<def> = MOV64ri <ga:@.str>
	%ESI<def> = COPY %vreg0; GR32:%vreg0
	%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
	CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
	ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	RET

# End machine code for function func.

********** MI Scheduling **********
func:BB#0 entry
  From: %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
    To: CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
 RegionInstrs: 4 Remaining: 9
Disabled scoreboard hazard recognizer
Disabled scoreboard hazard recognizer
SU(0):   %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   val SU(4294967295): Latency=1 Reg=%vreg9

SU(1):   %RDI<def> = MOV64ri <ga:@.str>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

SU(2):   %ESI<def> = COPY %vreg0; GR32:%vreg0
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
   ch  SU(4294967295) *: Latency=0

SU(3):   %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

Critical Path: 1
BotQ.A: 0 3 2 1 
  SU(0) ORDER                              
  SU(3) ORDER                              
  SU(2) PREG-COPY                         
Pick Bot PREG-COPY
Scheduling SU(2) %ESI<def> = COPY %vreg0; GR32:%vreg0
handleMove 320B -> 344B: %ESI<def> = COPY %vreg0; GR32:%vreg0
     SIL:	[160r,176r:0)[344r,352r:1)  0@160r 1@344r
        -->	[160r,176r:0)[344r,352r:1)  0@160r 1@344r
     %vreg0:	[16r,320r:0)  0@16r
        -->	[16r,344r:0)  0@16r
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
BotQ.A: 0 3 1 
  SU(0) ORDER                              
  SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
  Ready @1c
  BotQ.A BotLatency SU(3) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
BotQ.A: 0 1 
  SU(0) ORDER                              
  SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %RDI<def> = MOV64ri <ga:@.str>
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
Scheduling SU(0) %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
*** Final schedule for BB#0 ***
SU(0):   %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
SU(1):   %RDI<def> = MOV64ri <ga:@.str>
SU(3):   %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
SU(2):   %ESI<def> = COPY %vreg0; GR32:%vreg0

********** MI Scheduling **********
func:BB#0 entry
  From: %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
    To: CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
 RegionInstrs: 3 Remaining: 2
SU(0):   %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   val SU(4294967295): Latency=1 Reg=%vreg6

SU(1):   %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

SU(2):   %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

Critical Path: 1
BotQ.A: 0 2 1 
  SU(0) ORDER                              
  SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
  Ready @1c
  SBPort015 +1x4u
  *** Critical resource SBPort015: 0c
  SBPortAny +1x2u
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
BotQ.A: 0 1 
  SU(0) ORDER                              
  SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
Scheduling SU(0) %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 3
  Executed: 1c
  Critical: 1c, 3 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
*** Final schedule for BB#0 ***
SU(0):   %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
SU(1):   %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
SU(2):   %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>

********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
SIL [160r,176r:0)[344r,352r:1)  0@160r 1@344r
%vreg0 [16r,344r:0)  0@16r
%vreg6 [112r,176r:0)  0@112r
%vreg9 [256r,352r:0)  0@256r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
344B		%ESI<def> = COPY %vreg0; GR32:%vreg0
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

RPO[BB#0 derived from LLVM BB entry] = 1
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#0 derived from LLVM BB entry)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0.0
Frequency(BB#0 derived from LLVM BB entry) = 1.0
LoopExitProb[BB#0 derived from LLVM BB entry] = 16383 / 16384 = 99.9939% from 1 - 0.0 / 1.0.
********** COMPUTING LIVE DEBUG VARIABLES: func **********
********** DEBUG VARIABLES **********
********** GREEDY REGISTER ALLOCATION **********
********** Function: func
********** Compute Spill Weights **********
********** Function: func
********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
SIL [160r,176r:0)[344r,352r:1)  0@160r 1@344r
%vreg0 [16r,344r:0)  0@16r
%vreg6 [112r,176r:0)  0@112r
%vreg9 [256r,352r:0)  0@256r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
344B		%ESI<def> = COPY %vreg0; GR32:%vreg0
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.


selectOrSplit GR32:%vreg0 [16r,344r:0)  0@16r
hints: %EDI
missed hint %EDI
assigning %vreg0 to %EBX: BH BL

selectOrSplit GR64_with_sub_8bit:%vreg6 [112r,176r:0)  0@112r
assigning %vreg6 to %RAX: AH AL

selectOrSplit GR64:%vreg9 [256r,352r:0)  0@256r
assigning %vreg9 to %RCX: CH CL
********** REWRITE VIRTUAL REGISTERS **********
********** Function: func
********** REGISTER MAP **********
[%vreg0 -> %EBX] GR32
[%vreg6 -> %RAX] GR64_with_sub_8bit
[%vreg9 -> %RCX] GR64

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
344B		%ESI<def> = COPY %vreg0<kill>; GR32:%vreg0
352B		CALL64r %vreg9<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET
> %EBX<def> = COPY %EDI
> ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> %EAX<def> = MOV32ri64 8971440, %RAX<imp-def>
> %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
> %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
> CALL64r %RAX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>
> ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %EBX; mem:ST4[%i.addr]
> ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> %RCX<def> = MOV64ri <ga:@printf>
> %RDI<def> = MOV64ri <ga:@.str>
> %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
> %ESI<def> = COPY %EBX<kill>
> CALL64r %RCX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def,dead>
> ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> RET
********** EMITTING LIVE DEBUG VARIABLES **********
********** Stack Slot Coloring **********
********** Function: func
******** Post-regalloc Machine LICM: func ********

Setting up live-ins for BB#0 derived from entry.
Block has no FP live-ins.

FPInst:	RET
Stack contents:
Inserted instructions:
	RET
Stack contents:
alloc FI(0) at SP[-28]
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: func
real copy:   %EBX<def> = COPY %EDI
replaced by: %EBX<def> = MOV32rr %EDI
real copy:   %ESI<def> = COPY %EBX<kill>
replaced by: %ESI<def> = MOV32rr %EBX<kill>
RPO[BB#0 derived from LLVM BB entry] = 1
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#0 derived from LLVM BB entry)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0.0
Frequency(BB#0 derived from LLVM BB entry) = 1.0
LoopExitProb[BB#0 derived from LLVM BB entry] = 16383 / 16384 = 99.9939% from 1 - 0.0 / 1.0.
********** FIX EXECUTION DEPENDENCIES: VR128 **********
BB#0: entry
JITTing function 'func'
JIT: Starting CodeGen of Function func
JIT: Emitting BB0 at [0x7f7e4367b100]
PUSH64r %RBP<kill>, %RSP<imp-def>, %RSP<imp-use>; flags: FrameSetup
PROLOG_LABEL <MCSym=.Ltmp9>
%RBP<def> = MOV64rr %RSP; flags: FrameSetup
PROLOG_LABEL <MCSym=.Ltmp10>
PUSH64r %RBX<kill>, %RSP<imp-def>, %RSP<imp-use>; flags: FrameSetup
PUSH64r %RAX<undef>, %RSP<imp-def>, %RSP<imp-use>; flags: FrameSetup
PROLOG_LABEL <MCSym=.Ltmp11>
%EBX<def> = MOV32rr %EDI
%EAX<def> = MOV32ri64 8971440, %RAX<imp-def>
%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
CALL64r %RAX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>
MOV32mr %RBP, 1, %noreg, -12, %noreg, %EBX; mem:ST4[%i.addr]
%RCX<def> = MOV64ri <ga:@printf>
%RDI<def> = MOV64ri <ga:@.str>
%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
%ESI<def> = MOV32rr %EBX<kill>
CALL64r %RCX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def,dead>
%RSP<def,tied1> = ADD64ri8 %RSP<tied0>, 8, %EFLAGS<imp-def,dead>
%RBX<def> = POP64r %RSP<imp-def>, %RSP<imp-use>
%RBP<def> = POP64r %RSP<imp-def>, %RSP<imp-use>
RET
JIT: Finished CodeGen of [0x7f7e4367b100] Function: func: 61 bytes of text, 2 relocations
JIT: Binary code:
JIT: 0: 2291377285 2511378083 136228176184 941601910 
JIT: 16: 1601902231 2552226126 24493137208 24324018572 
JIT: 32: 05350132 1917200 6710217616 00127126 
JIT: 48: 22213719249 13172209255 93918196 195
Inside Func callback func
JIT: Map 'func' to [0x0]
CGP: Found      local addrmode: [Base:%i.addr]
CGP: Found      local addrmode: [Base:%i.addr]
Computing probabilities for entry



=== func
Initial selection DAG: BB#0 'func:entry'
SelectionDAG has 37 nodes:
  0x2e5c478: ch = EntryToken

  0x2e83e40: i64 = TargetConstant<0>

  0x2e84040: i64 = Register %RDI

      0x2e5c478: <multiple use>
      0x2e83e40: <multiple use>
    0x2ea9f80: ch,glue = callseq_start 0x2e5c478, 0x2e83e40 [ORD=47]

    0x2e84040: <multiple use>
    0x2eaa280: i64 = Constant<48717472>

  0x2e7fdb0: ch,glue = CopyToReg 0x2ea9f80, 0x2e84040, 0x2eaa280 [ORD=47]

  0x2ea9d80: i64 = Register %RSI

    0x2e7fdb0: <multiple use>
    0x2ea9d80: <multiple use>
    0x2eaa180: i64 = Constant<48397984>

    0x2e7fdb0: <multiple use>
  0x2ea9b80: ch,glue = CopyToReg 0x2e7fdb0, 0x2ea9d80, 0x2eaa180, 0x2e7fdb0:1 [ORD=47]

  0x2e7f7b0: Untyped = RegisterMask

    0x2ea9b80: <multiple use>
    0x2eaa380: i64 = Constant<8971440>

    0x2e84040: <multiple use>
    0x2ea9d80: <multiple use>
    0x2e7f7b0: <multiple use>
    0x2ea9b80: <multiple use>
  0x2e7f5b0: ch,glue = X86ISD::CALL 0x2ea9b80, 0x2eaa380, 0x2e84040, 0x2ea9d80, 0x2e7f7b0, 0x2ea9b80:1 [ORD=47]

    0x2e7f5b0: <multiple use>
    0x2e83e40: <multiple use>
    0x2e83e40: <multiple use>
    0x2e7f5b0: <multiple use>
  0x2e84240: ch,glue = callseq_end 0x2e7f5b0, 0x2e83e40, 0x2e83e40, 0x2e7f5b0:1 [ORD=47]

  0x2eaa8d0: i64 = FrameIndex<0>

  0x2eaa080: i64 = Constant<0>

  0x2e84540: i64 = undef

        0x2e84240: <multiple use>
        0x2ea9c80: i64 = Register %RAX

        0x2e84240: <multiple use>
      0x2ea9680: i64,ch,glue = CopyFromReg 0x2e84240, 0x2ea9c80, 0x2e84240:1 [ORD=47]

        0x2e5c478: <multiple use>
        0x2eaa9d0: i32 = Register %vreg0

      0x2eaa480: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=43]

      0x2eaa8d0: <multiple use>
      0x2e84540: <multiple use>
    0x2e7f6b0: ch = store 0x2ea9680:1, 0x2eaa480, 0x2eaa8d0, 0x2e84540<ST4[%i.addr]> [ORD=49]

    0x2eaa8d0: <multiple use>
    0x2e84540: <multiple use>
  0x2e84140: i32,ch = load 0x2e7f6b0, 0x2eaa8d0, 0x2e84540<LD4[%i.addr]> [ORD=50]

      0x2e84140: <multiple use>
      0x2e83e40: <multiple use>
    0x2e83d40: ch,glue = callseq_start 0x2e84140:1, 0x2e83e40 [ORD=51]

    0x2e84040: <multiple use>
    0x2e83c40: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=51]

  0x2e84340: ch,glue = CopyToReg 0x2e83d40, 0x2e84040, 0x2e83c40 [ORD=51]

  0x2e801b0: i32 = Register %ESI

    0x2e84340: <multiple use>
    0x2e801b0: <multiple use>
    0x2e84140: <multiple use>
    0x2e84340: <multiple use>
  0x2ea9780: ch,glue = CopyToReg 0x2e84340, 0x2e801b0, 0x2e84140, 0x2e84340:1 [ORD=51]

  0x2e7f4b0: i8 = Register %AL

    0x2ea9780: <multiple use>
    0x2e7f4b0: <multiple use>
    0x2ea9880: i8 = Constant<0>

    0x2ea9780: <multiple use>
  0x2e7fbb0: ch,glue = CopyToReg 0x2ea9780, 0x2e7f4b0, 0x2ea9880, 0x2ea9780:1 [ORD=51]

    0x2e7fbb0: <multiple use>
    0x2ea9980: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=51]

    0x2e84040: <multiple use>
    0x2e801b0: <multiple use>
    0x2e7f4b0: <multiple use>
    0x2e7f7b0: <multiple use>
    0x2e7fbb0: <multiple use>
  0x2e7f8b0: ch,glue = X86ISD::CALL 0x2e7fbb0, 0x2ea9980, 0x2e84040, 0x2e801b0, 0x2e7f4b0, 0x2e7f7b0, 0x2e7fbb0:1 [ORD=51]

    0x2e7f8b0: <multiple use>
    0x2e83e40: <multiple use>
    0x2e83e40: <multiple use>
    0x2e7f8b0: <multiple use>
  0x2e83b40: ch,glue = callseq_end 0x2e7f8b0, 0x2e83e40, 0x2e83e40, 0x2e7f8b0:1 [ORD=51]

      0x2e83b40: <multiple use>
      0x2e84740: i32 = Register %EAX

      0x2e83b40: <multiple use>
    0x2e800b0: i32,ch,glue = CopyFromReg 0x2e83b40, 0x2e84740, 0x2e83b40:1 [ORD=51]

    0x2e83f40: i16 = TargetConstant<0>

  0x2e84640: ch = X86ISD::RET_FLAG 0x2e800b0:1, 0x2e83f40 [ORD=52]



Replacing.1 0x2e84140: i32,ch = load 0x2e7f6b0, 0x2eaa8d0, 0x2e84540<LD4[%i.addr]> [ORD=50]

With: 0x2eaa480: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=43]
 and 1 other values
Optimized lowered selection DAG: BB#0 'func:entry'
SelectionDAG has 35 nodes:
  0x2e5c478: ch = EntryToken

    0x2e5c478: <multiple use>
    0x2eaa9d0: i32 = Register %vreg0

  0x2eaa480: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=43]

  0x2e83e40: i64 = TargetConstant<0>

  0x2e84040: i64 = Register %RDI

      0x2e5c478: <multiple use>
      0x2e83e40: <multiple use>
    0x2ea9f80: ch,glue = callseq_start 0x2e5c478, 0x2e83e40 [ORD=47]

    0x2e84040: <multiple use>
    0x2eaa280: i64 = Constant<48717472>

  0x2e7fdb0: ch,glue = CopyToReg 0x2ea9f80, 0x2e84040, 0x2eaa280 [ORD=47]

  0x2ea9d80: i64 = Register %RSI

    0x2e7fdb0: <multiple use>
    0x2ea9d80: <multiple use>
    0x2eaa180: i64 = Constant<48397984>

    0x2e7fdb0: <multiple use>
  0x2ea9b80: ch,glue = CopyToReg 0x2e7fdb0, 0x2ea9d80, 0x2eaa180, 0x2e7fdb0:1 [ORD=47]

  0x2e7f7b0: Untyped = RegisterMask

    0x2ea9b80: <multiple use>
    0x2eaa380: i64 = Constant<8971440>

    0x2e84040: <multiple use>
    0x2ea9d80: <multiple use>
    0x2e7f7b0: <multiple use>
    0x2ea9b80: <multiple use>
  0x2e7f5b0: ch,glue = X86ISD::CALL 0x2ea9b80, 0x2eaa380, 0x2e84040, 0x2ea9d80, 0x2e7f7b0, 0x2ea9b80:1 [ORD=47]

    0x2e7f5b0: <multiple use>
    0x2e83e40: <multiple use>
    0x2e83e40: <multiple use>
    0x2e7f5b0: <multiple use>
  0x2e84240: ch,glue = callseq_end 0x2e7f5b0, 0x2e83e40, 0x2e83e40, 0x2e7f5b0:1 [ORD=47]

          0x2e84240: <multiple use>
          0x2ea9c80: i64 = Register %RAX

          0x2e84240: <multiple use>
        0x2ea9680: i64,ch,glue = CopyFromReg 0x2e84240, 0x2ea9c80, 0x2e84240:1 [ORD=47]

        0x2eaa480: <multiple use>
        0x2eaa8d0: i64 = FrameIndex<0>

        0x2e84540: i64 = undef

      0x2e7f6b0: ch = store 0x2ea9680:1, 0x2eaa480, 0x2eaa8d0, 0x2e84540<ST4[%i.addr]> [ORD=49]

      0x2e83e40: <multiple use>
    0x2e83d40: ch,glue = callseq_start 0x2e7f6b0, 0x2e83e40 [ORD=51]

    0x2e84040: <multiple use>
    0x2e83c40: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=51]

  0x2e84340: ch,glue = CopyToReg 0x2e83d40, 0x2e84040, 0x2e83c40 [ORD=51]

  0x2e801b0: i32 = Register %ESI

    0x2e84340: <multiple use>
    0x2e801b0: <multiple use>
    0x2eaa480: <multiple use>
    0x2e84340: <multiple use>
  0x2ea9780: ch,glue = CopyToReg 0x2e84340, 0x2e801b0, 0x2eaa480, 0x2e84340:1 [ORD=51]

  0x2e7f4b0: i8 = Register %AL

    0x2ea9780: <multiple use>
    0x2e7f4b0: <multiple use>
    0x2ea9880: i8 = Constant<0>

    0x2ea9780: <multiple use>
  0x2e7fbb0: ch,glue = CopyToReg 0x2ea9780, 0x2e7f4b0, 0x2ea9880, 0x2ea9780:1 [ORD=51]

    0x2e7fbb0: <multiple use>
    0x2ea9980: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=51]

    0x2e84040: <multiple use>
    0x2e801b0: <multiple use>
    0x2e7f4b0: <multiple use>
    0x2e7f7b0: <multiple use>
    0x2e7fbb0: <multiple use>
  0x2e7f8b0: ch,glue = X86ISD::CALL 0x2e7fbb0, 0x2ea9980, 0x2e84040, 0x2e801b0, 0x2e7f4b0, 0x2e7f7b0, 0x2e7fbb0:1 [ORD=51]

    0x2e7f8b0: <multiple use>
    0x2e83e40: <multiple use>
    0x2e83e40: <multiple use>
    0x2e7f8b0: <multiple use>
  0x2e83b40: ch,glue = callseq_end 0x2e7f8b0, 0x2e83e40, 0x2e83e40, 0x2e7f8b0:1 [ORD=51]

      0x2e83b40: <multiple use>
      0x2e84740: i32 = Register %EAX

      0x2e83b40: <multiple use>
    0x2e800b0: i32,ch,glue = CopyFromReg 0x2e83b40, 0x2e84740, 0x2e83b40:1 [ORD=51]

    0x2e83f40: i16 = TargetConstant<0>

  0x2e84640: ch = X86ISD::RET_FLAG 0x2e800b0:1, 0x2e83f40 [ORD=52]


Legally typed node: 0x2e83f40: i16 = TargetConstant<0> [ID=0]

Legally typed node: 0x2e84740: i32 = Register %EAX [ID=0]

Legally typed node: 0x2e7f4b0: i8 = Register %AL [ID=0]

Legally typed node: 0x2e801b0: i32 = Register %ESI [ID=0]

Legally typed node: 0x2ea9880: i8 = Constant<0> [ID=0]

Legally typed node: 0x2e83c40: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=51] [ID=0]

Legally typed node: 0x2ea9980: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=51] [ID=0]

Legally typed node: 0x2e84540: i64 = undef [ID=0]

Legally typed node: 0x2eaa8d0: i64 = FrameIndex<0> [ID=0]

Legally typed node: 0x2ea9c80: i64 = Register %RAX [ID=0]

Legally typed node: 0x2e7f7b0: Untyped = RegisterMask [ID=0]

Legally typed node: 0x2ea9d80: i64 = Register %RSI [ID=0]

Legally typed node: 0x2e84040: i64 = Register %RDI [ID=0]

Legally typed node: 0x2e83e40: i64 = TargetConstant<0> [ID=0]

Legally typed node: 0x2eaa180: i64 = Constant<48397984> [ID=0]

Legally typed node: 0x2eaa280: i64 = Constant<48717472> [ID=0]

Legally typed node: 0x2eaa380: i64 = Constant<8971440> [ID=0]

Legally typed node: 0x2eaa9d0: i32 = Register %vreg0 [ID=0]

Legally typed node: 0x2e5c478: ch = EntryToken [ID=0]

Legally typed node: 0x2eaa480: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=43] [ID=0]

Legally typed node: 0x2ea9f80: ch,glue = callseq_start 0x2e5c478, 0x2e83e40 [ORD=47] [ID=0]

Legally typed node: 0x2e7fdb0: ch,glue = CopyToReg 0x2ea9f80, 0x2e84040, 0x2eaa280 [ORD=47] [ID=0]

Legally typed node: 0x2ea9b80: ch,glue = CopyToReg 0x2e7fdb0, 0x2ea9d80, 0x2eaa180, 0x2e7fdb0:1 [ORD=47] [ID=0]

Legally typed node: 0x2e7f5b0: ch,glue = X86ISD::CALL 0x2ea9b80, 0x2eaa380, 0x2e84040, 0x2ea9d80, 0x2e7f7b0, 0x2ea9b80:1 [ORD=47] [ID=0]

Legally typed node: 0x2e84240: ch,glue = callseq_end 0x2e7f5b0, 0x2e83e40, 0x2e83e40, 0x2e7f5b0:1 [ORD=47] [ID=0]

Legally typed node: 0x2ea9680: i64,ch,glue = CopyFromReg 0x2e84240, 0x2ea9c80, 0x2e84240:1 [ORD=47] [ID=0]

Legally typed node: 0x2e7f6b0: ch = store 0x2ea9680:1, 0x2eaa480, 0x2eaa8d0, 0x2e84540<ST4[%i.addr]> [ORD=49] [ID=0]

Legally typed node: 0x2e83d40: ch,glue = callseq_start 0x2e7f6b0, 0x2e83e40 [ORD=51] [ID=0]

Legally typed node: 0x2e84340: ch,glue = CopyToReg 0x2e83d40, 0x2e84040, 0x2e83c40 [ORD=51] [ID=0]

Legally typed node: 0x2ea9780: ch,glue = CopyToReg 0x2e84340, 0x2e801b0, 0x2eaa480, 0x2e84340:1 [ORD=51] [ID=0]

Legally typed node: 0x2e7fbb0: ch,glue = CopyToReg 0x2ea9780, 0x2e7f4b0, 0x2ea9880, 0x2ea9780:1 [ORD=51] [ID=0]

Legally typed node: 0x2e7f8b0: ch,glue = X86ISD::CALL 0x2e7fbb0, 0x2ea9980, 0x2e84040, 0x2e801b0, 0x2e7f4b0, 0x2e7f7b0, 0x2e7fbb0:1 [ORD=51] [ID=0]

Legally typed node: 0x2e83b40: ch,glue = callseq_end 0x2e7f8b0, 0x2e83e40, 0x2e83e40, 0x2e7f8b0:1 [ORD=51] [ID=0]

Legally typed node: 0x2e800b0: i32,ch,glue = CopyFromReg 0x2e83b40, 0x2e84740, 0x2e83b40:1 [ORD=51] [ID=0]

Legally typed node: 0x2e84640: ch = X86ISD::RET_FLAG 0x2e800b0:1, 0x2e83f40 [ORD=52] [ID=0]

Legally typed node: 0x7fff29e7ba10: ch = handlenode 0x2e84640 [ID=0]

Type-legalized selection DAG: BB#0 'func:entry'
SelectionDAG has 35 nodes:
  0x2e5c478: ch = EntryToken [ID=-3]

    0x2e5c478: <multiple use>
    0x2eaa9d0: i32 = Register %vreg0 [ID=-3]

  0x2eaa480: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=43] [ID=-3]

  0x2e83e40: i64 = TargetConstant<0> [ID=-3]

  0x2e84040: i64 = Register %RDI [ID=-3]

      0x2e5c478: <multiple use>
      0x2e83e40: <multiple use>
    0x2ea9f80: ch,glue = callseq_start 0x2e5c478, 0x2e83e40 [ORD=47] [ID=-3]

    0x2e84040: <multiple use>
    0x2eaa280: i64 = Constant<48717472> [ID=-3]

  0x2e7fdb0: ch,glue = CopyToReg 0x2ea9f80, 0x2e84040, 0x2eaa280 [ORD=47] [ID=-3]

  0x2ea9d80: i64 = Register %RSI [ID=-3]

    0x2e7fdb0: <multiple use>
    0x2ea9d80: <multiple use>
    0x2eaa180: i64 = Constant<48397984> [ID=-3]

    0x2e7fdb0: <multiple use>
  0x2ea9b80: ch,glue = CopyToReg 0x2e7fdb0, 0x2ea9d80, 0x2eaa180, 0x2e7fdb0:1 [ORD=47] [ID=-3]

  0x2e7f7b0: Untyped = RegisterMask [ID=-3]

    0x2ea9b80: <multiple use>
    0x2eaa380: i64 = Constant<8971440> [ID=-3]

    0x2e84040: <multiple use>
    0x2ea9d80: <multiple use>
    0x2e7f7b0: <multiple use>
    0x2ea9b80: <multiple use>
  0x2e7f5b0: ch,glue = X86ISD::CALL 0x2ea9b80, 0x2eaa380, 0x2e84040, 0x2ea9d80, 0x2e7f7b0, 0x2ea9b80:1 [ORD=47] [ID=-3]

    0x2e7f5b0: <multiple use>
    0x2e83e40: <multiple use>
    0x2e83e40: <multiple use>
    0x2e7f5b0: <multiple use>
  0x2e84240: ch,glue = callseq_end 0x2e7f5b0, 0x2e83e40, 0x2e83e40, 0x2e7f5b0:1 [ORD=47] [ID=-3]

          0x2e84240: <multiple use>
          0x2ea9c80: i64 = Register %RAX [ID=-3]

          0x2e84240: <multiple use>
        0x2ea9680: i64,ch,glue = CopyFromReg 0x2e84240, 0x2ea9c80, 0x2e84240:1 [ORD=47] [ID=-3]

        0x2eaa480: <multiple use>
        0x2eaa8d0: i64 = FrameIndex<0> [ID=-3]

        0x2e84540: i64 = undef [ID=-3]

      0x2e7f6b0: ch = store 0x2ea9680:1, 0x2eaa480, 0x2eaa8d0, 0x2e84540<ST4[%i.addr]> [ORD=49] [ID=-3]

      0x2e83e40: <multiple use>
    0x2e83d40: ch,glue = callseq_start 0x2e7f6b0, 0x2e83e40 [ORD=51] [ID=-3]

    0x2e84040: <multiple use>
    0x2e83c40: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=51] [ID=-3]

  0x2e84340: ch,glue = CopyToReg 0x2e83d40, 0x2e84040, 0x2e83c40 [ORD=51] [ID=-3]

  0x2e801b0: i32 = Register %ESI [ID=-3]

    0x2e84340: <multiple use>
    0x2e801b0: <multiple use>
    0x2eaa480: <multiple use>
    0x2e84340: <multiple use>
  0x2ea9780: ch,glue = CopyToReg 0x2e84340, 0x2e801b0, 0x2eaa480, 0x2e84340:1 [ORD=51] [ID=-3]

  0x2e7f4b0: i8 = Register %AL [ID=-3]

    0x2ea9780: <multiple use>
    0x2e7f4b0: <multiple use>
    0x2ea9880: i8 = Constant<0> [ID=-3]

    0x2ea9780: <multiple use>
  0x2e7fbb0: ch,glue = CopyToReg 0x2ea9780, 0x2e7f4b0, 0x2ea9880, 0x2ea9780:1 [ORD=51] [ID=-3]

    0x2e7fbb0: <multiple use>
    0x2ea9980: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=51] [ID=-3]

    0x2e84040: <multiple use>
    0x2e801b0: <multiple use>
    0x2e7f4b0: <multiple use>
    0x2e7f7b0: <multiple use>
    0x2e7fbb0: <multiple use>
  0x2e7f8b0: ch,glue = X86ISD::CALL 0x2e7fbb0, 0x2ea9980, 0x2e84040, 0x2e801b0, 0x2e7f4b0, 0x2e7f7b0, 0x2e7fbb0:1 [ORD=51] [ID=-3]

    0x2e7f8b0: <multiple use>
    0x2e83e40: <multiple use>
    0x2e83e40: <multiple use>
    0x2e7f8b0: <multiple use>
  0x2e83b40: ch,glue = callseq_end 0x2e7f8b0, 0x2e83e40, 0x2e83e40, 0x2e7f8b0:1 [ORD=51] [ID=-3]

      0x2e83b40: <multiple use>
      0x2e84740: i32 = Register %EAX [ID=-3]

      0x2e83b40: <multiple use>
    0x2e800b0: i32,ch,glue = CopyFromReg 0x2e83b40, 0x2e84740, 0x2e83b40:1 [ORD=51] [ID=-3]

    0x2e83f40: i16 = TargetConstant<0> [ID=-3]

  0x2e84640: ch = X86ISD::RET_FLAG 0x2e800b0:1, 0x2e83f40 [ORD=52] [ID=-3]


Legalized selection DAG: BB#0 'func:entry'
SelectionDAG has 37 nodes:
  0x2e5c478: ch = EntryToken [ID=0]

  0x2e83e40: i64 = TargetConstant<0> [ID=5]

  0x2e84040: i64 = Register %RDI [ID=6]

  0x2ea9d80: i64 = Register %RSI [ID=7]

  0x2e7f7b0: Untyped = RegisterMask [ID=8]

  0x2e801b0: i32 = Register %ESI [ID=15]

  0x2e7f4b0: i8 = Register %AL [ID=16]

    0x2e5c478: <multiple use>
    0x2eaa9d0: i32 = Register %vreg0 [ID=1]

  0x2eaa480: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=43] [ID=19]

      0x2e5c478: <multiple use>
      0x2e83e40: <multiple use>
    0x2ea9f80: ch,glue = callseq_start 0x2e5c478, 0x2e83e40 [ORD=47] [ID=20]

    0x2e84040: <multiple use>
    0x2eaa280: i64 = Constant<48717472> [ID=3]

  0x2e7fdb0: ch,glue = CopyToReg 0x2ea9f80, 0x2e84040, 0x2eaa280 [ORD=47] [ID=21]

    0x2e7fdb0: <multiple use>
    0x2ea9d80: <multiple use>
    0x2eaa180: i64 = Constant<48397984> [ID=4]

    0x2e7fdb0: <multiple use>
  0x2ea9b80: ch,glue = CopyToReg 0x2e7fdb0, 0x2ea9d80, 0x2eaa180, 0x2e7fdb0:1 [ORD=47] [ID=22]

    0x2ea9b80: <multiple use>
    0x2eaa380: i64 = Constant<8971440> [ID=2]

    0x2e84040: <multiple use>
    0x2ea9d80: <multiple use>
    0x2e7f7b0: <multiple use>
    0x2ea9b80: <multiple use>
  0x2e7f5b0: ch,glue = X86ISD::CALL 0x2ea9b80, 0x2eaa380, 0x2e84040, 0x2ea9d80, 0x2e7f7b0, 0x2ea9b80:1 [ORD=47] [ID=23]

    0x2e7f5b0: <multiple use>
    0x2e83e40: <multiple use>
    0x2e83e40: <multiple use>
    0x2e7f5b0: <multiple use>
  0x2e84240: ch,glue = callseq_end 0x2e7f5b0, 0x2e83e40, 0x2e83e40, 0x2e7f5b0:1 [ORD=47] [ID=24]

          0x2e84240: <multiple use>
          0x2ea9c80: i64 = Register %RAX [ID=9]

          0x2e84240: <multiple use>
        0x2ea9680: i64,ch,glue = CopyFromReg 0x2e84240, 0x2ea9c80, 0x2e84240:1 [ORD=47] [ID=25]

        0x2eaa480: <multiple use>
        0x2eaa8d0: i64 = FrameIndex<0> [ID=10]

        0x2e84540: i64 = undef [ID=11]

      0x2e7f6b0: ch = store 0x2ea9680:1, 0x2eaa480, 0x2eaa8d0, 0x2e84540<ST4[%i.addr]> [ORD=49] [ID=26]

      0x2e83e40: <multiple use>
    0x2e83d40: ch,glue = callseq_start 0x2e7f6b0, 0x2e83e40 [ORD=51] [ID=27]

    0x2e84040: <multiple use>
      0x2eaa080: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=51]

    0x2e84140: i64 = X86ISD::Wrapper 0x2eaa080 [ORD=51]

  0x2e84340: ch,glue = CopyToReg 0x2e83d40, 0x2e84040, 0x2e84140 [ORD=51] [ID=28]

    0x2e84340: <multiple use>
    0x2e801b0: <multiple use>
    0x2eaa480: <multiple use>
    0x2e84340: <multiple use>
  0x2ea9780: ch,glue = CopyToReg 0x2e84340, 0x2e801b0, 0x2eaa480, 0x2e84340:1 [ORD=51] [ID=29]

    0x2ea9780: <multiple use>
    0x2e7f4b0: <multiple use>
    0x2ea9880: i8 = Constant<0> [ID=14]

    0x2ea9780: <multiple use>
  0x2e7fbb0: ch,glue = CopyToReg 0x2ea9780, 0x2e7f4b0, 0x2ea9880, 0x2ea9780:1 [ORD=51] [ID=30]

    0x2e7fbb0: <multiple use>
      0x2e83c40: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=51]

    0x2ea9e80: i64 = X86ISD::Wrapper 0x2e83c40 [ORD=51]

    0x2e84040: <multiple use>
    0x2e801b0: <multiple use>
    0x2e7f4b0: <multiple use>
    0x2e7f7b0: <multiple use>
    0x2e7fbb0: <multiple use>
  0x2e7f8b0: ch,glue = X86ISD::CALL 0x2e7fbb0, 0x2ea9e80, 0x2e84040, 0x2e801b0, 0x2e7f4b0, 0x2e7f7b0, 0x2e7fbb0:1 [ORD=51] [ID=31]

    0x2e7f8b0: <multiple use>
    0x2e83e40: <multiple use>
    0x2e83e40: <multiple use>
    0x2e7f8b0: <multiple use>
  0x2e83b40: ch,glue = callseq_end 0x2e7f8b0, 0x2e83e40, 0x2e83e40, 0x2e7f8b0:1 [ORD=51] [ID=32]

      0x2e83b40: <multiple use>
      0x2e84740: i32 = Register %EAX [ID=17]

      0x2e83b40: <multiple use>
    0x2e800b0: i32,ch,glue = CopyFromReg 0x2e83b40, 0x2e84740, 0x2e83b40:1 [ORD=51] [ID=33]

    0x2e83f40: i16 = TargetConstant<0> [ID=18]

  0x2e84640: ch = X86ISD::RET_FLAG 0x2e800b0:1, 0x2e83f40 [ORD=52] [ID=34]


Optimized legalized selection DAG: BB#0 'func:entry'
SelectionDAG has 37 nodes:
  0x2e5c478: ch = EntryToken [ID=0]

  0x2e83e40: i64 = TargetConstant<0> [ID=5]

  0x2e84040: i64 = Register %RDI [ID=6]

  0x2ea9d80: i64 = Register %RSI [ID=7]

  0x2e7f7b0: Untyped = RegisterMask [ID=8]

  0x2e801b0: i32 = Register %ESI [ID=15]

  0x2e7f4b0: i8 = Register %AL [ID=16]

    0x2e5c478: <multiple use>
    0x2eaa9d0: i32 = Register %vreg0 [ID=1]

  0x2eaa480: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=43] [ID=19]

      0x2e5c478: <multiple use>
      0x2e83e40: <multiple use>
    0x2ea9f80: ch,glue = callseq_start 0x2e5c478, 0x2e83e40 [ORD=47] [ID=20]

    0x2e84040: <multiple use>
    0x2eaa280: i64 = Constant<48717472> [ID=3]

  0x2e7fdb0: ch,glue = CopyToReg 0x2ea9f80, 0x2e84040, 0x2eaa280 [ORD=47] [ID=21]

    0x2e7fdb0: <multiple use>
    0x2ea9d80: <multiple use>
    0x2eaa180: i64 = Constant<48397984> [ID=4]

    0x2e7fdb0: <multiple use>
  0x2ea9b80: ch,glue = CopyToReg 0x2e7fdb0, 0x2ea9d80, 0x2eaa180, 0x2e7fdb0:1 [ORD=47] [ID=22]

    0x2ea9b80: <multiple use>
    0x2eaa380: i64 = Constant<8971440> [ID=2]

    0x2e84040: <multiple use>
    0x2ea9d80: <multiple use>
    0x2e7f7b0: <multiple use>
    0x2ea9b80: <multiple use>
  0x2e7f5b0: ch,glue = X86ISD::CALL 0x2ea9b80, 0x2eaa380, 0x2e84040, 0x2ea9d80, 0x2e7f7b0, 0x2ea9b80:1 [ORD=47] [ID=23]

    0x2e7f5b0: <multiple use>
    0x2e83e40: <multiple use>
    0x2e83e40: <multiple use>
    0x2e7f5b0: <multiple use>
  0x2e84240: ch,glue = callseq_end 0x2e7f5b0, 0x2e83e40, 0x2e83e40, 0x2e7f5b0:1 [ORD=47] [ID=24]

          0x2e84240: <multiple use>
          0x2ea9c80: i64 = Register %RAX [ID=9]

          0x2e84240: <multiple use>
        0x2ea9680: i64,ch,glue = CopyFromReg 0x2e84240, 0x2ea9c80, 0x2e84240:1 [ORD=47] [ID=25]

        0x2eaa480: <multiple use>
        0x2eaa8d0: i64 = FrameIndex<0> [ID=10]

        0x2e84540: i64 = undef [ID=11]

      0x2e7f6b0: ch = store 0x2ea9680:1, 0x2eaa480, 0x2eaa8d0, 0x2e84540<ST4[%i.addr]> [ORD=49] [ID=26]

      0x2e83e40: <multiple use>
    0x2e83d40: ch,glue = callseq_start 0x2e7f6b0, 0x2e83e40 [ORD=51] [ID=27]

    0x2e84040: <multiple use>
      0x2eaa080: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=51]

    0x2e84140: i64 = X86ISD::Wrapper 0x2eaa080 [ORD=51]

  0x2e84340: ch,glue = CopyToReg 0x2e83d40, 0x2e84040, 0x2e84140 [ORD=51] [ID=28]

    0x2e84340: <multiple use>
    0x2e801b0: <multiple use>
    0x2eaa480: <multiple use>
    0x2e84340: <multiple use>
  0x2ea9780: ch,glue = CopyToReg 0x2e84340, 0x2e801b0, 0x2eaa480, 0x2e84340:1 [ORD=51] [ID=29]

    0x2ea9780: <multiple use>
    0x2e7f4b0: <multiple use>
    0x2ea9880: i8 = Constant<0> [ID=14]

    0x2ea9780: <multiple use>
  0x2e7fbb0: ch,glue = CopyToReg 0x2ea9780, 0x2e7f4b0, 0x2ea9880, 0x2ea9780:1 [ORD=51] [ID=30]

    0x2e7fbb0: <multiple use>
      0x2e83c40: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=51]

    0x2ea9e80: i64 = X86ISD::Wrapper 0x2e83c40 [ORD=51]

    0x2e84040: <multiple use>
    0x2e801b0: <multiple use>
    0x2e7f4b0: <multiple use>
    0x2e7f7b0: <multiple use>
    0x2e7fbb0: <multiple use>
  0x2e7f8b0: ch,glue = X86ISD::CALL 0x2e7fbb0, 0x2ea9e80, 0x2e84040, 0x2e801b0, 0x2e7f4b0, 0x2e7f7b0, 0x2e7fbb0:1 [ORD=51] [ID=31]

    0x2e7f8b0: <multiple use>
    0x2e83e40: <multiple use>
    0x2e83e40: <multiple use>
    0x2e7f8b0: <multiple use>
  0x2e83b40: ch,glue = callseq_end 0x2e7f8b0, 0x2e83e40, 0x2e83e40, 0x2e7f8b0:1 [ORD=51] [ID=32]

      0x2e83b40: <multiple use>
      0x2e84740: i32 = Register %EAX [ID=17]

      0x2e83b40: <multiple use>
    0x2e800b0: i32,ch,glue = CopyFromReg 0x2e83b40, 0x2e84740, 0x2e83b40:1 [ORD=51] [ID=33]

    0x2e83f40: i16 = TargetConstant<0> [ID=18]

  0x2e84640: ch = X86ISD::RET_FLAG 0x2e800b0:1, 0x2e83f40 [ORD=52] [ID=34]


===== Instruction selection begins: BB#0 'entry'
Selecting: 0x2e84640: ch = X86ISD::RET_FLAG 0x2e800b0:1, 0x2e83f40 [ORD=52] [ID=36]

ISEL: Starting pattern match on root node: 0x2e84640: ch = X86ISD::RET_FLAG 0x2e800b0:1, 0x2e83f40 [ORD=52] [ID=36]

  Initial Opcode index to 93235
  Morphed node: 0x2e84640: ch = RET 0x2e800b0:1 [ORD=52]

ISEL: Match complete!
=> 0x2e84640: ch = RET 0x2e800b0:1 [ORD=52]

Selecting: 0x2e800b0: i32,ch,glue = CopyFromReg 0x2e83b40, 0x2e84740, 0x2e83b40:1 [ORD=51] [ID=35]

=> 0x2e800b0: i32,ch,glue = CopyFromReg 0x2e83b40, 0x2e84740, 0x2e83b40:1 [ORD=51]

Selecting: 0x2e83b40: ch,glue = callseq_end 0x2e7f8b0, 0x2e83e40, 0x2e83e40, 0x2e7f8b0:1 [ORD=51] [ID=34]

ISEL: Starting pattern match on root node: 0x2e83b40: ch,glue = callseq_end 0x2e7f8b0, 0x2e83e40, 0x2e83e40, 0x2e7f8b0:1 [ORD=51] [ID=34]

  Initial Opcode index to 92907
  Skipped scope entry (due to false predicate) at index 92925, continuing at 92937
  Morphed node: 0x2e83b40: i64,ch,glue = ADJCALLSTACKUP64 0x2e83e40, 0x2e83e40, 0x2e7f8b0, 0x2e7f8b0:1 [ORD=51]

ISEL: Match complete!
=> 0x2e83b40: i64,ch,glue = ADJCALLSTACKUP64 0x2e83e40, 0x2e83e40, 0x2e7f8b0, 0x2e7f8b0:1 [ORD=51]

Selecting: 0x2e7f8b0: ch,glue = X86ISD::CALL 0x2e7fbb0, 0x2ea9e80, 0x2e84040, 0x2e801b0, 0x2e7f4b0, 0x2e7f7b0, 0x2e7fbb0:1 [ORD=51] [ID=33]

ISEL: Starting pattern match on root node: 0x2e7f8b0: ch,glue = X86ISD::CALL 0x2e7fbb0, 0x2ea9e80, 0x2e84040, 0x2e801b0, 0x2e7f4b0, 0x2e7f7b0, 0x2e7fbb0:1 [ORD=51] [ID=33]

  Initial Opcode index to 69884
  Match failed at index 69890
  Continuing at 69951
  Match failed at index 69957
  Continuing at 70031
  Match failed at index 70032
  Continuing at 70044
  Morphed node: 0x2e7f8b0: ch,glue = CALL64r 0x2ea9e80, 0x2e84040, 0x2e801b0, 0x2e7f4b0, 0x2e7f7b0, 0x2e7fbb0, 0x2e7fbb0:1 [ORD=51]

ISEL: Match complete!
=> 0x2e7f8b0: ch,glue = CALL64r 0x2ea9e80, 0x2e84040, 0x2e801b0, 0x2e7f4b0, 0x2e7f7b0, 0x2e7fbb0, 0x2e7fbb0:1 [ORD=51]

Selecting: 0x2e7fbb0: ch,glue = CopyToReg 0x2ea9780, 0x2e7f4b0, 0x2ea9880, 0x2ea9780:1 [ORD=51] [ID=32]

=> 0x2e7fbb0: ch,glue = CopyToReg 0x2ea9780, 0x2e7f4b0, 0x2ea9880, 0x2ea9780:1 [ORD=51]

Selecting: 0x2ea9780: ch,glue = CopyToReg 0x2e84340, 0x2e801b0, 0x2eaa480, 0x2e84340:1 [ORD=51] [ID=31]

=> 0x2ea9780: ch,glue = CopyToReg 0x2e84340, 0x2e801b0, 0x2eaa480, 0x2e84340:1 [ORD=51]

Selecting: 0x2e84340: ch,glue = CopyToReg 0x2e83d40, 0x2e84040, 0x2e84140 [ORD=51] [ID=30]

=> 0x2e84340: ch,glue = CopyToReg 0x2e83d40, 0x2e84040, 0x2e84140 [ORD=51]

Selecting: 0x2e83d40: ch,glue = callseq_start 0x2e7f6b0, 0x2e83e40 [ORD=51] [ID=29]

ISEL: Starting pattern match on root node: 0x2e83d40: ch,glue = callseq_start 0x2e7f6b0, 0x2e83e40 [ORD=51] [ID=29]

  Initial Opcode index to 95380
  Skipped scope entry (due to false predicate) at index 95390, continuing at 95401
  Morphed node: 0x2e83d40: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e83e40, 0x2e7f6b0 [ORD=51]

ISEL: Match complete!
=> 0x2e83d40: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e83e40, 0x2e7f6b0 [ORD=51]

Selecting: 0x2e7f6b0: ch = store 0x2ea9680:1, 0x2eaa480, 0x2eaa8d0, 0x2e84540<ST4[%i.addr]> [ORD=49] [ID=28]

ISEL: Starting pattern match on root node: 0x2e7f6b0: ch = store 0x2ea9680:1, 0x2eaa480, 0x2eaa8d0, 0x2e84540<ST4[%i.addr]> [ORD=49] [ID=28]

  Initial Opcode index to 5
  Skipped scope entry (due to false predicate) at index 13, continuing at 58
  Skipped scope entry (due to false predicate) at index 59, continuing at 104
  Skipped scope entry (due to false predicate) at index 105, continuing at 188
  Skipped scope entry (due to false predicate) at index 189, continuing at 212
  Skipped scope entry (due to false predicate) at index 213, continuing at 236
  Skipped scope entry (due to false predicate) at index 237, continuing at 260
  Match failed at index 264
  Continuing at 284
  Match failed at index 285
  Continuing at 308
  Continuing at 309
  Match failed at index 313
  Continuing at 10708
  Match failed at index 10713
  Continuing at 11131
  Match failed at index 11135
  Continuing at 11509
  Match failed at index 11513
  Continuing at 11624
  Match failed at index 11628
  Continuing at 11859
  Skipped scope entry (due to false predicate) at index 11864, continuing at 11950
  Skipped scope entry (due to false predicate) at index 11951, continuing at 12064
  Skipped scope entry (due to false predicate) at index 12065, continuing at 12137
  Skipped scope entry (due to false predicate) at index 12138, continuing at 12161
  Skipped scope entry (due to false predicate) at index 12162, continuing at 12185
MatchAddress: X86ISelAddressMode 0x7fff29e7b560
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
  Morphed node: 0x2e7f6b0: ch = MOV32mr 0x2ea9980, 0x2ea9a80, 0x2e83f40, 0x2e84840, 0x2e84440, 0x2eaa480, 0x2ea9680:1<Mem:ST4[%i.addr]> [ORD=49]

ISEL: Match complete!
=> 0x2e7f6b0: ch = MOV32mr 0x2ea9980, 0x2ea9a80, 0x2e83f40, 0x2e84840, 0x2e84440, 0x2eaa480, 0x2ea9680:1<Mem:ST4[%i.addr]> [ORD=49]

Selecting: 0x2ea9680: i64,ch,glue = CopyFromReg 0x2e84240, 0x2ea9c80, 0x2e84240:1 [ORD=47] [ID=27]

=> 0x2ea9680: i64,ch,glue = CopyFromReg 0x2e84240, 0x2ea9c80, 0x2e84240:1 [ORD=47]

Selecting: 0x2e84240: ch,glue = callseq_end 0x2e7f5b0, 0x2e83e40, 0x2e83e40, 0x2e7f5b0:1 [ORD=47] [ID=26]

ISEL: Starting pattern match on root node: 0x2e84240: ch,glue = callseq_end 0x2e7f5b0, 0x2e83e40, 0x2e83e40, 0x2e7f5b0:1 [ORD=47] [ID=26]

  Initial Opcode index to 92907
  Skipped scope entry (due to false predicate) at index 92925, continuing at 92937
  Morphed node: 0x2e84240: i64,ch,glue = ADJCALLSTACKUP64 0x2e83e40, 0x2e83e40, 0x2e7f5b0, 0x2e7f5b0:1 [ORD=47]

ISEL: Match complete!
=> 0x2e84240: i64,ch,glue = ADJCALLSTACKUP64 0x2e83e40, 0x2e83e40, 0x2e7f5b0, 0x2e7f5b0:1 [ORD=47]

Selecting: 0x2e7f5b0: ch,glue = X86ISD::CALL 0x2ea9b80, 0x2eaa380, 0x2e84040, 0x2ea9d80, 0x2e7f7b0, 0x2ea9b80:1 [ORD=47] [ID=25]

ISEL: Starting pattern match on root node: 0x2e7f5b0: ch,glue = X86ISD::CALL 0x2ea9b80, 0x2eaa380, 0x2e84040, 0x2ea9d80, 0x2e7f7b0, 0x2ea9b80:1 [ORD=47] [ID=25]

  Initial Opcode index to 69884
  Match failed at index 69890
  Continuing at 69951
  OpcodeSwitch from 69957 to 70015
  Match failed at index 70015
  Continuing at 70031
  Match failed at index 70032
  Continuing at 70044
  Morphed node: 0x2e7f5b0: ch,glue = CALL64r 0x2eaa380, 0x2e84040, 0x2ea9d80, 0x2e7f7b0, 0x2ea9b80, 0x2ea9b80:1 [ORD=47]

ISEL: Match complete!
=> 0x2e7f5b0: ch,glue = CALL64r 0x2eaa380, 0x2e84040, 0x2ea9d80, 0x2e7f7b0, 0x2ea9b80, 0x2ea9b80:1 [ORD=47]

Selecting: 0x2ea9b80: ch,glue = CopyToReg 0x2e7fdb0, 0x2ea9d80, 0x2eaa180, 0x2e7fdb0:1 [ORD=47] [ID=24]

=> 0x2ea9b80: ch,glue = CopyToReg 0x2e7fdb0, 0x2ea9d80, 0x2eaa180, 0x2e7fdb0:1 [ORD=47]

Selecting: 0x2e7fdb0: ch,glue = CopyToReg 0x2ea9f80, 0x2e84040, 0x2eaa280 [ORD=47] [ID=23]

=> 0x2e7fdb0: ch,glue = CopyToReg 0x2ea9f80, 0x2e84040, 0x2eaa280 [ORD=47]

Selecting: 0x2ea9e80: i64 = X86ISD::Wrapper 0x2e83c40 [ORD=51] [ID=22]

ISEL: Starting pattern match on root node: 0x2ea9e80: i64 = X86ISD::Wrapper 0x2e83c40 [ORD=51] [ID=22]

  Initial Opcode index to 94787
  Match failed at index 94792
  Continuing at 94819
  OpcodeSwitch from 94824 to 94938
  TypeSwitch[i64] from 94939 to 94952
  Morphed node: 0x2ea9e80: i64 = MOV64ri 0x2e83c40 [ORD=51]

ISEL: Match complete!
=> 0x2ea9e80: i64 = MOV64ri 0x2e83c40 [ORD=51]

Selecting: 0x2e84140: i64 = X86ISD::Wrapper 0x2eaa080 [ORD=51] [ID=21]

ISEL: Starting pattern match on root node: 0x2e84140: i64 = X86ISD::Wrapper 0x2eaa080 [ORD=51] [ID=21]

  Initial Opcode index to 94787
  Match failed at index 94792
  Continuing at 94819
  OpcodeSwitch from 94824 to 94938
  TypeSwitch[i64] from 94939 to 94952
  Morphed node: 0x2e84140: i64 = MOV64ri 0x2eaa080 [ORD=51]

ISEL: Match complete!
=> 0x2e84140: i64 = MOV64ri 0x2eaa080 [ORD=51]

Selecting: 0x2ea9f80: ch,glue = callseq_start 0x2e5c478, 0x2e83e40 [ORD=47] [ID=20]

ISEL: Starting pattern match on root node: 0x2ea9f80: ch,glue = callseq_start 0x2e5c478, 0x2e83e40 [ORD=47] [ID=20]

  Initial Opcode index to 95380
  Skipped scope entry (due to false predicate) at index 95390, continuing at 95401
  Morphed node: 0x2ea9f80: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e83e40, 0x2e5c478 [ORD=47]

ISEL: Match complete!
=> 0x2ea9f80: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e83e40, 0x2e5c478 [ORD=47]

Selecting: 0x2eaa480: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=43] [ID=19]

=> 0x2eaa480: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=43]

Selecting: 0x2e83c40: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=51] [ID=18]

=> 0x2e83c40: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=51]

Selecting: 0x2eaa080: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=51] [ID=17]

=> 0x2eaa080: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=51]

Selecting: 0x2e84740: i32 = Register %EAX [ID=15]

=> 0x2e84740: i32 = Register %EAX

Selecting: 0x2e7f4b0: i8 = Register %AL [ID=14]

=> 0x2e7f4b0: i8 = Register %AL

Selecting: 0x2e801b0: i32 = Register %ESI [ID=13]

=> 0x2e801b0: i32 = Register %ESI

Selecting: 0x2ea9880: i8 = Constant<0> [ID=12]

ISEL: Starting pattern match on root node: 0x2ea9880: i8 = Constant<0> [ID=12]

  Initial Opcode index to 82786
  Match failed at index 82790
  Continuing at 82816
  Match failed at index 82818
  Continuing at 82847
  TypeSwitch[i8] from 82850 to 82863
  Created node: 0x2eaa8d0: i32,i32 = MOV32r0

  Morphed node: 0x2ea9880: i8 = EXTRACT_SUBREG 0x2eaa8d0, 0x2e84540

ISEL: Match complete!
=> 0x2ea9880: i8 = EXTRACT_SUBREG 0x2eaa8d0, 0x2e84540

Selecting: 0x2ea9c80: i64 = Register %RAX [ID=9]

=> 0x2ea9c80: i64 = Register %RAX

Selecting: 0x2e7f7b0: Untyped = RegisterMask [ID=8]

=> 0x2e7f7b0: Untyped = RegisterMask

Selecting: 0x2ea9d80: i64 = Register %RSI [ID=7]

=> 0x2ea9d80: i64 = Register %RSI

Selecting: 0x2e84040: i64 = Register %RDI [ID=6]

=> 0x2e84040: i64 = Register %RDI

Selecting: 0x2e83e40: i64 = TargetConstant<0> [ID=5]

=> 0x2e83e40: i64 = TargetConstant<0>

Selecting: 0x2eaa180: i64 = Constant<48397984> [ID=4]

ISEL: Starting pattern match on root node: 0x2eaa180: i64 = Constant<48397984> [ID=4]

  Initial Opcode index to 82786
  Skipped scope entry (due to false predicate) at index 82788, continuing at 82816
  Created node: 0x2e84940: i32 = MOV32ri64 0x2e7f3b0

  Morphed node: 0x2eaa180: i64 = SUBREG_TO_REG 0x2e83e40, 0x2e84940, 0x2e7ffb0

ISEL: Match complete!
=> 0x2eaa180: i64 = SUBREG_TO_REG 0x2e83e40, 0x2e84940, 0x2e7ffb0

Selecting: 0x2eaa280: i64 = Constant<48717472> [ID=3]

ISEL: Starting pattern match on root node: 0x2eaa280: i64 = Constant<48717472> [ID=3]

  Initial Opcode index to 82786
  Skipped scope entry (due to false predicate) at index 82788, continuing at 82816
  Created node: 0x2e7fcb0: i32 = MOV32ri64 0x2e7f9b0

  Morphed node: 0x2eaa280: i64 = SUBREG_TO_REG 0x2e83e40, 0x2e7fcb0, 0x2e7ffb0

ISEL: Match complete!
=> 0x2eaa280: i64 = SUBREG_TO_REG 0x2e83e40, 0x2e7fcb0, 0x2e7ffb0

Selecting: 0x2eaa380: i64 = Constant<8971440> [ID=2]

ISEL: Starting pattern match on root node: 0x2eaa380: i64 = Constant<8971440> [ID=2]

  Initial Opcode index to 82786
  Skipped scope entry (due to false predicate) at index 82788, continuing at 82816
  Created node: 0x2e7fab0: i32 = MOV32ri64 0x2e7feb0

  Morphed node: 0x2eaa380: i64 = SUBREG_TO_REG 0x2e83e40, 0x2e7fab0, 0x2e7ffb0

ISEL: Match complete!
=> 0x2eaa380: i64 = SUBREG_TO_REG 0x2e83e40, 0x2e7fab0, 0x2e7ffb0

Selecting: 0x2eaa9d0: i32 = Register %vreg0 [ID=1]

=> 0x2eaa9d0: i32 = Register %vreg0

Selecting: 0x2e5c478: ch = EntryToken [ID=0]

=> 0x2e5c478: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: BB#0 'func:entry'
SelectionDAG has 48 nodes:
  0x2e5c478: ch = EntryToken

  0x2e83e40: i64 = TargetConstant<0>

  0x2e84040: i64 = Register %RDI

  0x2ea9d80: i64 = Register %RSI

  0x2e7f7b0: Untyped = RegisterMask

  0x2e801b0: i32 = Register %ESI

  0x2e7f4b0: i8 = Register %AL

    0x2e5c478: <multiple use>
    0x2eaa9d0: i32 = Register %vreg0

  0x2eaa480: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=43]

      0x2e83e40: <multiple use>
      0x2e5c478: <multiple use>
    0x2ea9f80: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e83e40, 0x2e5c478 [ORD=47]

    0x2e84040: <multiple use>
      0x2e83e40: <multiple use>
        0x2e7f9b0: i64 = TargetConstant<48717472>

      0x2e7fcb0: i32 = MOV32ri64 0x2e7f9b0

      0x2e7ffb0: <multiple use>
    0x2eaa280: i64 = SUBREG_TO_REG 0x2e83e40, 0x2e7fcb0, 0x2e7ffb0

  0x2e7fdb0: ch,glue = CopyToReg 0x2ea9f80:1, 0x2e84040, 0x2eaa280 [ORD=47]

    0x2e7fdb0: <multiple use>
    0x2ea9d80: <multiple use>
      0x2e83e40: <multiple use>
        0x2e7f3b0: i64 = TargetConstant<48397984>

      0x2e84940: i32 = MOV32ri64 0x2e7f3b0

      0x2e7ffb0: <multiple use>
    0x2eaa180: i64 = SUBREG_TO_REG 0x2e83e40, 0x2e84940, 0x2e7ffb0

    0x2e7fdb0: <multiple use>
  0x2ea9b80: ch,glue = CopyToReg 0x2e7fdb0, 0x2ea9d80, 0x2eaa180, 0x2e7fdb0:1 [ORD=47]

      0x2e83e40: <multiple use>
        0x2e7feb0: i64 = TargetConstant<8971440>

      0x2e7fab0: i32 = MOV32ri64 0x2e7feb0

      0x2e7ffb0: <multiple use>
    0x2eaa380: i64 = SUBREG_TO_REG 0x2e83e40, 0x2e7fab0, 0x2e7ffb0

    0x2e84040: <multiple use>
    0x2ea9d80: <multiple use>
    0x2e7f7b0: <multiple use>
    0x2ea9b80: <multiple use>
    0x2ea9b80: <multiple use>
  0x2e7f5b0: ch,glue = CALL64r 0x2eaa380, 0x2e84040, 0x2ea9d80, 0x2e7f7b0, 0x2ea9b80, 0x2ea9b80:1 [ORD=47]

    0x2e83e40: <multiple use>
    0x2e83e40: <multiple use>
    0x2e7f5b0: <multiple use>
    0x2e7f5b0: <multiple use>
  0x2e84240: i64,ch,glue = ADJCALLSTACKUP64 0x2e83e40, 0x2e83e40, 0x2e7f5b0, 0x2e7f5b0:1 [ORD=47]

      0x2e83e40: <multiple use>
        0x2ea9980: i64 = TargetFrameIndex<0>

        0x2ea9a80: i8 = TargetConstant<1>

        0x2e83f40: i64 = Register %noreg

        0x2e84840: i32 = TargetConstant<0>

        0x2e84440: i32 = Register %noreg

        0x2eaa480: <multiple use>
          0x2e84240: <multiple use>
          0x2ea9c80: i64 = Register %RAX

          0x2e84240: <multiple use>
        0x2ea9680: i64,ch,glue = CopyFromReg 0x2e84240:1, 0x2ea9c80, 0x2e84240:2 [ORD=47]

      0x2e7f6b0: ch = MOV32mr 0x2ea9980, 0x2ea9a80, 0x2e83f40, 0x2e84840, 0x2e84440, 0x2eaa480, 0x2ea9680:1<Mem:ST4[%i.addr]> [ORD=49]

    0x2e83d40: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e83e40, 0x2e7f6b0 [ORD=51]

    0x2e84040: <multiple use>
      0x2eaa080: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=51]

    0x2e84140: i64 = MOV64ri 0x2eaa080 [ORD=51]

  0x2e84340: ch,glue = CopyToReg 0x2e83d40:1, 0x2e84040, 0x2e84140 [ORD=51]

    0x2e84340: <multiple use>
    0x2e801b0: <multiple use>
    0x2eaa480: <multiple use>
    0x2e84340: <multiple use>
  0x2ea9780: ch,glue = CopyToReg 0x2e84340, 0x2e801b0, 0x2eaa480, 0x2e84340:1 [ORD=51]

    0x2ea9780: <multiple use>
    0x2e7f4b0: <multiple use>
      0x2eaa8d0: i32,i32 = MOV32r0

      0x2e84540: i32 = TargetConstant<1>

    0x2ea9880: i8 = EXTRACT_SUBREG 0x2eaa8d0, 0x2e84540

    0x2ea9780: <multiple use>
  0x2e7fbb0: ch,glue = CopyToReg 0x2ea9780, 0x2e7f4b0, 0x2ea9880, 0x2ea9780:1 [ORD=51]

      0x2e83c40: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=51]

    0x2ea9e80: i64 = MOV64ri 0x2e83c40 [ORD=51]

    0x2e84040: <multiple use>
    0x2e801b0: <multiple use>
    0x2e7f4b0: <multiple use>
    0x2e7f7b0: <multiple use>
    0x2e7fbb0: <multiple use>
    0x2e7fbb0: <multiple use>
  0x2e7f8b0: ch,glue = CALL64r 0x2ea9e80, 0x2e84040, 0x2e801b0, 0x2e7f4b0, 0x2e7f7b0, 0x2e7fbb0, 0x2e7fbb0:1 [ORD=51]

    0x2e83e40: <multiple use>
    0x2e83e40: <multiple use>
    0x2e7f8b0: <multiple use>
    0x2e7f8b0: <multiple use>
  0x2e83b40: i64,ch,glue = ADJCALLSTACKUP64 0x2e83e40, 0x2e83e40, 0x2e7f8b0, 0x2e7f8b0:1 [ORD=51]

  0x2e7ffb0: i32 = TargetConstant<4>

      0x2e83b40: <multiple use>
      0x2e84740: i32 = Register %EAX

      0x2e83b40: <multiple use>
    0x2e800b0: i32,ch,glue = CopyFromReg 0x2e83b40:1, 0x2e84740, 0x2e83b40:2 [ORD=51]

  0x2e84640: ch = RET 0x2e800b0:1 [ORD=52]


********** List Scheduling BB#0 'entry' **********
SU(0): 0x2e84640: ch = RET 0x2e800b0:1 [ORD=52] [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 0
  Predecessors:
   ch  SU(1): Latency=1

SU(1): 0x2e800b0: i32,ch,glue = CopyFromReg 0x2e83b40:1, 0x2e84740, 0x2e83b40:2 [ORD=51] [ID=1]

    0x2e84340: ch,glue = CopyToReg 0x2e83d40:1, 0x2e84040, 0x2e84140 [ORD=51] [ID=1]

    0x2ea9780: ch,glue = CopyToReg 0x2e84340, 0x2e801b0, 0x2eaa480, 0x2e84340:1 [ORD=51] [ID=1]

    0x2e7fbb0: ch,glue = CopyToReg 0x2ea9780, 0x2e7f4b0, 0x2ea9880, 0x2ea9780:1 [ORD=51] [ID=1]

    0x2e7f8b0: ch,glue = CALL64r 0x2ea9e80, 0x2e84040, 0x2e801b0, 0x2e7f4b0, 0x2e7f7b0, 0x2e7fbb0, 0x2e7fbb0:1 [ORD=51] [ID=1]

    0x2e83b40: i64,ch,glue = ADJCALLSTACKUP64 0x2e83e40, 0x2e83e40, 0x2e7f8b0, 0x2e7f8b0:1 [ORD=51] [ID=1]

  # preds left       : 5
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 1
  Predecessors:
   val SU(16): Latency=1
   val SU(2): Latency=1
   val SU(4): Latency=1
   ch  SU(6): Latency=1
   val SU(5): Latency=1
  Successors:
   ch  SU(0): Latency=1

SU(2): 0x2ea9880: i8 = EXTRACT_SUBREG 0x2eaa8d0, 0x2e84540 [ID=2]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
   val SU(3): Latency=1
  Successors:
   val SU(1): Latency=1

SU(3): 0x2eaa8d0: i32,i32 = MOV32r0 [ID=3]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
   val SU(2): Latency=1

SU(4): 0x2eaa480: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=43] [ID=4]

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
   val SU(1): Latency=1
   val SU(7): Latency=1

SU(5): 0x2e84140: i64 = MOV64ri 0x2eaa080 [ORD=51] [ID=5]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
   val SU(1): Latency=1

SU(6): 0x2e83d40: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e83e40, 0x2e7f6b0 [ORD=51] [ID=6]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 2
  Predecessors:
   ch  SU(7): Latency=1
  Successors:
   ch  SU(1): Latency=1

SU(7): 0x2e7f6b0: ch = MOV32mr 0x2ea9980, 0x2ea9a80, 0x2e83f40, 0x2e84840, 0x2e84440, 0x2eaa480, 0x2ea9680:1<Mem:ST4[%i.addr]> [ORD=49] [ID=7]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 3
  Predecessors:
   val SU(4): Latency=1
   ch  SU(8): Latency=1
  Successors:
   ch  SU(6): Latency=1

SU(8): 0x2ea9680: i64,ch,glue = CopyFromReg 0x2e84240:1, 0x2ea9c80, 0x2e84240:2 [ORD=47] [ID=8]

    0x2e7fdb0: ch,glue = CopyToReg 0x2ea9f80:1, 0x2e84040, 0x2eaa280 [ORD=47] [ID=8]

    0x2ea9b80: ch,glue = CopyToReg 0x2e7fdb0, 0x2ea9d80, 0x2eaa180, 0x2e7fdb0:1 [ORD=47] [ID=8]

    0x2e7f5b0: ch,glue = CALL64r 0x2eaa380, 0x2e84040, 0x2ea9d80, 0x2e7f7b0, 0x2ea9b80, 0x2ea9b80:1 [ORD=47] [ID=8]

    0x2e84240: i64,ch,glue = ADJCALLSTACKUP64 0x2e83e40, 0x2e83e40, 0x2e7f5b0, 0x2e7f5b0:1 [ORD=47] [ID=8]

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 4
  Predecessors:
   val SU(14): Latency=1
   val SU(9): Latency=1
   ch  SU(13): Latency=1
   val SU(11): Latency=1
  Successors:
   ch  SU(7): Latency=1

SU(9): 0x2eaa180: i64 = SUBREG_TO_REG 0x2e83e40, 0x2e84940, 0x2e7ffb0 [ID=9]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
   val SU(10): Latency=1
  Successors:
   val SU(8): Latency=1

SU(10): 0x2e84940: i32 = MOV32ri64 0x2e7f3b0 [ID=10]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
   val SU(9): Latency=1

SU(11): 0x2eaa280: i64 = SUBREG_TO_REG 0x2e83e40, 0x2e7fcb0, 0x2e7ffb0 [ID=11]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
   val SU(12): Latency=1
  Successors:
   val SU(8): Latency=1

SU(12): 0x2e7fcb0: i32 = MOV32ri64 0x2e7f9b0 [ID=12]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
   val SU(11): Latency=1

SU(13): 0x2ea9f80: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e83e40, 0x2e5c478 [ORD=47] [ID=13]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
   ch  SU(8): Latency=1

SU(14): 0x2eaa380: i64 = SUBREG_TO_REG 0x2e83e40, 0x2e7fab0, 0x2e7ffb0 [ID=14]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
   val SU(15): Latency=1
  Successors:
   val SU(8): Latency=1

SU(15): 0x2e7fab0: i32 = MOV32ri64 0x2e7feb0 [ID=15]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
   val SU(14): Latency=1

SU(16): 0x2ea9e80: i64 = MOV64ri 0x2e83c40 [ORD=51] [ID=16]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
   val SU(1): Latency=1


Examining Available:
Height 0: SU(0): 0x2e84640: ch = RET 0x2e800b0:1 [ORD=52] [ID=0]


*** Scheduling [0]: SU(0): 0x2e84640: ch = RET 0x2e800b0:1 [ORD=52] [ID=0]


Examining Available:
Height 1: SU(1): 0x2e800b0: i32,ch,glue = CopyFromReg 0x2e83b40:1, 0x2e84740, 0x2e83b40:2 [ORD=51] [ID=1]

    0x2e84340: ch,glue = CopyToReg 0x2e83d40:1, 0x2e84040, 0x2e84140 [ORD=51] [ID=1]

    0x2ea9780: ch,glue = CopyToReg 0x2e84340, 0x2e801b0, 0x2eaa480, 0x2e84340:1 [ORD=51] [ID=1]

    0x2e7fbb0: ch,glue = CopyToReg 0x2ea9780, 0x2e7f4b0, 0x2ea9880, 0x2ea9780:1 [ORD=51] [ID=1]

    0x2e7f8b0: ch,glue = CALL64r 0x2ea9e80, 0x2e84040, 0x2e801b0, 0x2e7f4b0, 0x2e7f7b0, 0x2e7fbb0, 0x2e7fbb0:1 [ORD=51] [ID=1]

    0x2e83b40: i64,ch,glue = ADJCALLSTACKUP64 0x2e83e40, 0x2e83e40, 0x2e7f8b0, 0x2e7f8b0:1 [ORD=51] [ID=1]


*** Scheduling [1]: SU(1): 0x2e800b0: i32,ch,glue = CopyFromReg 0x2e83b40:1, 0x2e84740, 0x2e83b40:2 [ORD=51] [ID=1]

    0x2e84340: ch,glue = CopyToReg 0x2e83d40:1, 0x2e84040, 0x2e84140 [ORD=51] [ID=1]

    0x2ea9780: ch,glue = CopyToReg 0x2e84340, 0x2e801b0, 0x2eaa480, 0x2e84340:1 [ORD=51] [ID=1]

    0x2e7fbb0: ch,glue = CopyToReg 0x2ea9780, 0x2e7f4b0, 0x2ea9880, 0x2ea9780:1 [ORD=51] [ID=1]

    0x2e7f8b0: ch,glue = CALL64r 0x2ea9e80, 0x2e84040, 0x2e801b0, 0x2e7f4b0, 0x2e7f7b0, 0x2e7fbb0, 0x2e7fbb0:1 [ORD=51] [ID=1]

    0x2e83b40: i64,ch,glue = ADJCALLSTACKUP64 0x2e83e40, 0x2e83e40, 0x2e7f8b0, 0x2e7f8b0:1 [ORD=51] [ID=1]


Examining Available:
Height 2: SU(2): 0x2ea9880: i8 = EXTRACT_SUBREG 0x2eaa8d0, 0x2e84540 [ID=2]

Height 2: SU(16): 0x2ea9e80: i64 = MOV64ri 0x2e83c40 [ORD=51] [ID=16]

Height 2: SU(5): 0x2e84140: i64 = MOV64ri 0x2eaa080 [ORD=51] [ID=5]

Height 2: SU(6): 0x2e83d40: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e83e40, 0x2e7f6b0 [ORD=51] [ID=6]


*** Scheduling [2]: SU(2): 0x2ea9880: i8 = EXTRACT_SUBREG 0x2eaa8d0, 0x2e84540 [ID=2]


Examining Available:
Height 3: SU(3): 0x2eaa8d0: i32,i32 = MOV32r0 [ID=3]

Height 2: SU(16): 0x2ea9e80: i64 = MOV64ri 0x2e83c40 [ORD=51] [ID=16]

Height 2: SU(5): 0x2e84140: i64 = MOV64ri 0x2eaa080 [ORD=51] [ID=5]

Height 2: SU(6): 0x2e83d40: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e83e40, 0x2e7f6b0 [ORD=51] [ID=6]


*** Scheduling [3]: SU(3): 0x2eaa8d0: i32,i32 = MOV32r0 [ID=3]


Examining Available:
Height 2: SU(16): 0x2ea9e80: i64 = MOV64ri 0x2e83c40 [ORD=51] [ID=16]

Height 2: SU(5): 0x2e84140: i64 = MOV64ri 0x2eaa080 [ORD=51] [ID=5]

Height 2: SU(6): 0x2e83d40: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e83e40, 0x2e7f6b0 [ORD=51] [ID=6]


*** Scheduling [4]: SU(16): 0x2ea9e80: i64 = MOV64ri 0x2e83c40 [ORD=51] [ID=16]


Examining Available:
Height 2: SU(5): 0x2e84140: i64 = MOV64ri 0x2eaa080 [ORD=51] [ID=5]

Height 2: SU(6): 0x2e83d40: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e83e40, 0x2e7f6b0 [ORD=51] [ID=6]


*** Scheduling [5]: SU(5): 0x2e84140: i64 = MOV64ri 0x2eaa080 [ORD=51] [ID=5]


Examining Available:
Height 2: SU(6): 0x2e83d40: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e83e40, 0x2e7f6b0 [ORD=51] [ID=6]


*** Scheduling [6]: SU(6): 0x2e83d40: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e83e40, 0x2e7f6b0 [ORD=51] [ID=6]


Examining Available:
Height 7: SU(7): 0x2e7f6b0: ch = MOV32mr 0x2ea9980, 0x2ea9a80, 0x2e83f40, 0x2e84840, 0x2e84440, 0x2eaa480, 0x2ea9680:1<Mem:ST4[%i.addr]> [ORD=49] [ID=7]


*** Scheduling [7]: SU(7): 0x2e7f6b0: ch = MOV32mr 0x2ea9980, 0x2ea9a80, 0x2e83f40, 0x2e84840, 0x2e84440, 0x2eaa480, 0x2ea9680:1<Mem:ST4[%i.addr]> [ORD=49] [ID=7]


Examining Available:
Height 8: SU(8): 0x2ea9680: i64,ch,glue = CopyFromReg 0x2e84240:1, 0x2ea9c80, 0x2e84240:2 [ORD=47] [ID=8]

    0x2e7fdb0: ch,glue = CopyToReg 0x2ea9f80:1, 0x2e84040, 0x2eaa280 [ORD=47] [ID=8]

    0x2ea9b80: ch,glue = CopyToReg 0x2e7fdb0, 0x2ea9d80, 0x2eaa180, 0x2e7fdb0:1 [ORD=47] [ID=8]

    0x2e7f5b0: ch,glue = CALL64r 0x2eaa380, 0x2e84040, 0x2ea9d80, 0x2e7f7b0, 0x2ea9b80, 0x2ea9b80:1 [ORD=47] [ID=8]

    0x2e84240: i64,ch,glue = ADJCALLSTACKUP64 0x2e83e40, 0x2e83e40, 0x2e7f5b0, 0x2e7f5b0:1 [ORD=47] [ID=8]

Height 8: SU(4): 0x2eaa480: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=43] [ID=4]


*** Scheduling [8]: SU(8): 0x2ea9680: i64,ch,glue = CopyFromReg 0x2e84240:1, 0x2ea9c80, 0x2e84240:2 [ORD=47] [ID=8]

    0x2e7fdb0: ch,glue = CopyToReg 0x2ea9f80:1, 0x2e84040, 0x2eaa280 [ORD=47] [ID=8]

    0x2ea9b80: ch,glue = CopyToReg 0x2e7fdb0, 0x2ea9d80, 0x2eaa180, 0x2e7fdb0:1 [ORD=47] [ID=8]

    0x2e7f5b0: ch,glue = CALL64r 0x2eaa380, 0x2e84040, 0x2ea9d80, 0x2e7f7b0, 0x2ea9b80, 0x2ea9b80:1 [ORD=47] [ID=8]

    0x2e84240: i64,ch,glue = ADJCALLSTACKUP64 0x2e83e40, 0x2e83e40, 0x2e7f5b0, 0x2e7f5b0:1 [ORD=47] [ID=8]


Examining Available:
Height 9: SU(14): 0x2eaa380: i64 = SUBREG_TO_REG 0x2e83e40, 0x2e7fab0, 0x2e7ffb0 [ID=14]

Height 9: SU(9): 0x2eaa180: i64 = SUBREG_TO_REG 0x2e83e40, 0x2e84940, 0x2e7ffb0 [ID=9]

Height 9: SU(11): 0x2eaa280: i64 = SUBREG_TO_REG 0x2e83e40, 0x2e7fcb0, 0x2e7ffb0 [ID=11]

Height 9: SU(13): 0x2ea9f80: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e83e40, 0x2e5c478 [ORD=47] [ID=13]

Height 8: SU(4): 0x2eaa480: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=43] [ID=4]


*** Scheduling [9]: SU(14): 0x2eaa380: i64 = SUBREG_TO_REG 0x2e83e40, 0x2e7fab0, 0x2e7ffb0 [ID=14]


Examining Available:
Height 10: SU(15): 0x2e7fab0: i32 = MOV32ri64 0x2e7feb0 [ID=15]

Height 9: SU(9): 0x2eaa180: i64 = SUBREG_TO_REG 0x2e83e40, 0x2e84940, 0x2e7ffb0 [ID=9]

Height 9: SU(11): 0x2eaa280: i64 = SUBREG_TO_REG 0x2e83e40, 0x2e7fcb0, 0x2e7ffb0 [ID=11]

Height 9: SU(13): 0x2ea9f80: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e83e40, 0x2e5c478 [ORD=47] [ID=13]

Height 8: SU(4): 0x2eaa480: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=43] [ID=4]


*** Scheduling [10]: SU(15): 0x2e7fab0: i32 = MOV32ri64 0x2e7feb0 [ID=15]


Examining Available:
Height 9: SU(9): 0x2eaa180: i64 = SUBREG_TO_REG 0x2e83e40, 0x2e84940, 0x2e7ffb0 [ID=9]

Height 9: SU(11): 0x2eaa280: i64 = SUBREG_TO_REG 0x2e83e40, 0x2e7fcb0, 0x2e7ffb0 [ID=11]

Height 9: SU(13): 0x2ea9f80: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e83e40, 0x2e5c478 [ORD=47] [ID=13]

Height 8: SU(4): 0x2eaa480: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=43] [ID=4]


*** Scheduling [11]: SU(9): 0x2eaa180: i64 = SUBREG_TO_REG 0x2e83e40, 0x2e84940, 0x2e7ffb0 [ID=9]


Examining Available:
Height 12: SU(10): 0x2e84940: i32 = MOV32ri64 0x2e7f3b0 [ID=10]

Height 9: SU(11): 0x2eaa280: i64 = SUBREG_TO_REG 0x2e83e40, 0x2e7fcb0, 0x2e7ffb0 [ID=11]

Height 9: SU(13): 0x2ea9f80: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e83e40, 0x2e5c478 [ORD=47] [ID=13]

Height 8: SU(4): 0x2eaa480: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=43] [ID=4]


*** Scheduling [12]: SU(10): 0x2e84940: i32 = MOV32ri64 0x2e7f3b0 [ID=10]


Examining Available:
Height 9: SU(11): 0x2eaa280: i64 = SUBREG_TO_REG 0x2e83e40, 0x2e7fcb0, 0x2e7ffb0 [ID=11]

Height 9: SU(13): 0x2ea9f80: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e83e40, 0x2e5c478 [ORD=47] [ID=13]

Height 8: SU(4): 0x2eaa480: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=43] [ID=4]


*** Scheduling [13]: SU(11): 0x2eaa280: i64 = SUBREG_TO_REG 0x2e83e40, 0x2e7fcb0, 0x2e7ffb0 [ID=11]


Examining Available:
Height 14: SU(12): 0x2e7fcb0: i32 = MOV32ri64 0x2e7f9b0 [ID=12]

Height 9: SU(13): 0x2ea9f80: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e83e40, 0x2e5c478 [ORD=47] [ID=13]

Height 8: SU(4): 0x2eaa480: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=43] [ID=4]


*** Scheduling [14]: SU(12): 0x2e7fcb0: i32 = MOV32ri64 0x2e7f9b0 [ID=12]


Examining Available:
Height 9: SU(13): 0x2ea9f80: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e83e40, 0x2e5c478 [ORD=47] [ID=13]

Height 8: SU(4): 0x2eaa480: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=43] [ID=4]


*** Scheduling [15]: SU(13): 0x2ea9f80: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e83e40, 0x2e5c478 [ORD=47] [ID=13]


Examining Available:
Height 8: SU(4): 0x2eaa480: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=43] [ID=4]


*** Scheduling [16]: SU(4): 0x2eaa480: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=43] [ID=4]

*** Final schedule ***
SU(4): 0x2eaa480: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=43] [ID=4]

SU(13): 0x2ea9f80: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e83e40, 0x2e5c478 [ORD=47] [ID=13]

SU(12): 0x2e7fcb0: i32 = MOV32ri64 0x2e7f9b0 [ID=12]

SU(11): 0x2eaa280: i64 = SUBREG_TO_REG 0x2e83e40, 0x2e7fcb0, 0x2e7ffb0 [ID=11]

SU(10): 0x2e84940: i32 = MOV32ri64 0x2e7f3b0 [ID=10]

SU(9): 0x2eaa180: i64 = SUBREG_TO_REG 0x2e83e40, 0x2e84940, 0x2e7ffb0 [ID=9]

SU(15): 0x2e7fab0: i32 = MOV32ri64 0x2e7feb0 [ID=15]

SU(14): 0x2eaa380: i64 = SUBREG_TO_REG 0x2e83e40, 0x2e7fab0, 0x2e7ffb0 [ID=14]

SU(8): 0x2ea9680: i64,ch,glue = CopyFromReg 0x2e84240:1, 0x2ea9c80, 0x2e84240:2 [ORD=47] [ID=8]

    0x2e7fdb0: ch,glue = CopyToReg 0x2ea9f80:1, 0x2e84040, 0x2eaa280 [ORD=47] [ID=8]

    0x2ea9b80: ch,glue = CopyToReg 0x2e7fdb0, 0x2ea9d80, 0x2eaa180, 0x2e7fdb0:1 [ORD=47] [ID=8]

    0x2e7f5b0: ch,glue = CALL64r 0x2eaa380, 0x2e84040, 0x2ea9d80, 0x2e7f7b0, 0x2ea9b80, 0x2ea9b80:1 [ORD=47] [ID=8]

    0x2e84240: i64,ch,glue = ADJCALLSTACKUP64 0x2e83e40, 0x2e83e40, 0x2e7f5b0, 0x2e7f5b0:1 [ORD=47] [ID=8]

SU(7): 0x2e7f6b0: ch = MOV32mr 0x2ea9980, 0x2ea9a80, 0x2e83f40, 0x2e84840, 0x2e84440, 0x2eaa480, 0x2ea9680:1<Mem:ST4[%i.addr]> [ORD=49] [ID=7]

SU(6): 0x2e83d40: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e83e40, 0x2e7f6b0 [ORD=51] [ID=6]

SU(5): 0x2e84140: i64 = MOV64ri 0x2eaa080 [ORD=51] [ID=5]

SU(16): 0x2ea9e80: i64 = MOV64ri 0x2e83c40 [ORD=51] [ID=16]

SU(3): 0x2eaa8d0: i32,i32 = MOV32r0 [ID=3]

SU(2): 0x2ea9880: i8 = EXTRACT_SUBREG 0x2eaa8d0, 0x2e84540 [ID=2]

SU(1): 0x2e800b0: i32,ch,glue = CopyFromReg 0x2e83b40:1, 0x2e84740, 0x2e83b40:2 [ORD=51] [ID=1]

    0x2e84340: ch,glue = CopyToReg 0x2e83d40:1, 0x2e84040, 0x2e84140 [ORD=51] [ID=1]

    0x2ea9780: ch,glue = CopyToReg 0x2e84340, 0x2e801b0, 0x2eaa480, 0x2e84340:1 [ORD=51] [ID=1]

    0x2e7fbb0: ch,glue = CopyToReg 0x2ea9780, 0x2e7f4b0, 0x2ea9880, 0x2ea9780:1 [ORD=51] [ID=1]

    0x2e7f8b0: ch,glue = CALL64r 0x2ea9e80, 0x2e84040, 0x2e801b0, 0x2e7f4b0, 0x2e7f7b0, 0x2e7fbb0, 0x2e7fbb0:1 [ORD=51] [ID=1]

    0x2e83b40: i64,ch,glue = ADJCALLSTACKUP64 0x2e83e40, 0x2e83e40, 0x2e7f8b0, 0x2e7f8b0:1 [ORD=51] [ID=1]

SU(0): 0x2e84640: ch = RET 0x2e800b0:1 [ORD=52] [ID=0]


Total amount of phi nodes to update: 0
# Machine code for function func: SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
48B		%vreg1<def> = MOV32ri64 48717472; GR32:%vreg1
64B		%vreg2<def> = SUBREG_TO_REG 0, %vreg1<kill>, 4; GR64:%vreg2 GR32:%vreg1
80B		%vreg3<def> = MOV32ri64 48397984; GR32:%vreg3
96B		%vreg4<def> = SUBREG_TO_REG 0, %vreg3<kill>, 4; GR64:%vreg4 GR32:%vreg3
112B		%vreg5<def> = MOV32ri64 8971440; GR32:%vreg5
128B		%vreg6<def> = SUBREG_TO_REG 0, %vreg5<kill>, 4; GR64:%vreg6 GR32:%vreg5
144B		%RDI<def> = COPY %vreg2; GR64:%vreg2
160B		%RSI<def> = COPY %vreg4; GR64:%vreg4
176B		CALL64r %vreg6<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def>; GR64:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		%vreg7<def> = COPY %RAX; GR64:%vreg7
224B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
240B		ADJCALLSTACKDOWN64 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg8<def> = MOV64ri <ga:@.str>; GR64:%vreg8
272B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
288B		%vreg10<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
304B		%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
320B		%RDI<def> = COPY %vreg8; GR64:%vreg8
336B		%ESI<def> = COPY %vreg0; GR32:%vreg0
352B		%AL<def> = COPY %vreg11; GR8:%vreg11
368B		CALL64r %vreg9<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def>; GR64:%vreg9
384B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
400B		%vreg12<def> = COPY %EAX; GR32:%vreg12
416B		RET

# End machine code for function func.

********** Stack Coloring **********
********** Function: func
Found 0 markers and 1 slots
Slot structure:
Slot #0 - 4 bytes.
Total Stack size: 4 bytes

Will not try to merge slots.
Removed 0 markers.
DeadMachineInstructionElim: DELETING: %vreg12<def> = COPY %EAX; GR32:%vreg12
DeadMachineInstructionElim: DELETING: %vreg7<def> = COPY %RAX; GR64:%vreg7
******** Pre-regalloc Machine LICM: func ********
Entering: entry
Exiting: entry
******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: func
********** PROCESS IMPLICIT DEFS **********
********** Function: func
********** REWRITING TWO-ADDR INSTRS **********
********** Function: func
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI<kill>; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
48B		%vreg1<def> = MOV32ri64 48717472; GR32:%vreg1
64B		%vreg2<def> = SUBREG_TO_REG 0, %vreg1<kill>, 4; GR64:%vreg2 GR32:%vreg1
80B		%vreg3<def> = MOV32ri64 48397984; GR32:%vreg3
96B		%vreg4<def> = SUBREG_TO_REG 0, %vreg3<kill>, 4; GR64:%vreg4 GR32:%vreg3
112B		%vreg5<def> = MOV32ri64 8971440; GR32:%vreg5
128B		%vreg6<def> = SUBREG_TO_REG 0, %vreg5<kill>, 4; GR64:%vreg6 GR32:%vreg5
144B		%RDI<def> = COPY %vreg2<kill>; GR64:%vreg2
160B		%RSI<def> = COPY %vreg4<kill>; GR64:%vreg4
176B		CALL64r %vreg6<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use,kill>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
240B		%vreg8<def> = MOV64ri <ga:@.str>; GR64:%vreg8
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
272B		%vreg10<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
288B		%vreg11<def> = COPY %vreg10:sub_8bit<kill>; GR8:%vreg11 GR32:%vreg10
304B		%RDI<def> = COPY %vreg8<kill>; GR64:%vreg8
320B		%ESI<def> = COPY %vreg0<kill>; GR32:%vreg0
336B		%AL<def> = COPY %vreg11<kill>; GR8:%vreg11
352B		CALL64r %vreg9<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use,kill>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

Computing live-in reg-units in ABI blocks.
0B	BB#0 DIL#0
Created 1 new intervals.
********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
%vreg0 [16r,320r:0)  0@16r
%vreg1 [48r,64r:0)  0@48r
%vreg2 [64r,144r:0)  0@64r
%vreg3 [80r,96r:0)  0@80r
%vreg4 [96r,160r:0)  0@96r
%vreg5 [112r,128r:0)  0@112r
%vreg6 [128r,176r:0)  0@128r
%vreg8 [240r,304r:0)  0@240r
%vreg9 [256r,352r:0)  0@256r
%vreg10 [272r,288r:0)  0@272r
%vreg11 [288r,336r:0)  0@288r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
48B		%vreg1<def> = MOV32ri64 48717472; GR32:%vreg1
64B		%vreg2<def> = SUBREG_TO_REG 0, %vreg1, 4; GR64:%vreg2 GR32:%vreg1
80B		%vreg3<def> = MOV32ri64 48397984; GR32:%vreg3
96B		%vreg4<def> = SUBREG_TO_REG 0, %vreg3, 4; GR64:%vreg4 GR32:%vreg3
112B		%vreg5<def> = MOV32ri64 8971440; GR32:%vreg5
128B		%vreg6<def> = SUBREG_TO_REG 0, %vreg5, 4; GR64:%vreg6 GR32:%vreg5
144B		%RDI<def> = COPY %vreg2; GR64:%vreg2
160B		%RSI<def> = COPY %vreg4; GR64:%vreg4
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
240B		%vreg8<def> = MOV64ri <ga:@.str>; GR64:%vreg8
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
272B		%vreg10<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
288B		%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
304B		%RDI<def> = COPY %vreg8; GR64:%vreg8
320B		%ESI<def> = COPY %vreg0; GR32:%vreg0
336B		%AL<def> = COPY %vreg11; GR8:%vreg11
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

********** SIMPLE REGISTER COALESCING **********
********** Function: func
********** JOINING INTERVALS ***********
entry:
16B	%vreg0<def> = COPY %EDI; GR32:%vreg0
	Considering merging %vreg0 with %EDI
	Can only merge into reserved registers.
64B	%vreg2<def> = SUBREG_TO_REG 0, %vreg1, 4; GR64:%vreg2 GR32:%vreg1
	Considering merging to GR64_with_sub_8bit with %vreg1 in %vreg2:sub_32bit
		RHS = %vreg1 [48r,64r:0)  0@48r
		LHS = %vreg2 [64r,144r:0)  0@64r
		merge %vreg2:0@64r into %vreg1:0@48r --> @48r
		erased:	64r	%vreg2<def> = SUBREG_TO_REG 0, %vreg1, 4; GR64:%vreg2 GR32:%vreg1
		updated: 48B	%vreg2:sub_32bit<def,read-undef> = MOV32ri64 48717472; GR64_with_sub_8bit:%vreg2
	Joined. Result = %vreg2 [48r,144r:0)  0@48r
96B	%vreg4<def> = SUBREG_TO_REG 0, %vreg3, 4; GR64:%vreg4 GR32:%vreg3
	Considering merging to GR64_with_sub_8bit with %vreg3 in %vreg4:sub_32bit
		RHS = %vreg3 [80r,96r:0)  0@80r
		LHS = %vreg4 [96r,160r:0)  0@96r
		merge %vreg4:0@96r into %vreg3:0@80r --> @80r
		erased:	96r	%vreg4<def> = SUBREG_TO_REG 0, %vreg3, 4; GR64:%vreg4 GR32:%vreg3
		updated: 80B	%vreg4:sub_32bit<def,read-undef> = MOV32ri64 48397984; GR64_with_sub_8bit:%vreg4
	Joined. Result = %vreg4 [80r,160r:0)  0@80r
128B	%vreg6<def> = SUBREG_TO_REG 0, %vreg5, 4; GR64:%vreg6 GR32:%vreg5
	Considering merging to GR64_with_sub_8bit with %vreg5 in %vreg6:sub_32bit
		RHS = %vreg5 [112r,128r:0)  0@112r
		LHS = %vreg6 [128r,176r:0)  0@128r
		merge %vreg6:0@128r into %vreg5:0@112r --> @112r
		erased:	128r	%vreg6<def> = SUBREG_TO_REG 0, %vreg5, 4; GR64:%vreg6 GR32:%vreg5
		updated: 112B	%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
	Joined. Result = %vreg6 [112r,176r:0)  0@112r
144B	%RDI<def> = COPY %vreg2; GR64_with_sub_8bit:%vreg2
	Considering merging %vreg2 with %RDI
	Can only merge into reserved registers.
Remat: %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
Shrink: %vreg2 [48r,144r:0)  0@48r
All defs dead: 48r	%vreg2:sub_32bit<def,read-undef,dead> = MOV32ri64 48717472; GR64_with_sub_8bit:%vreg2
Shrunk: %vreg2 [48r,48d:0)  0@48r
Deleting dead def 48r	%vreg2:sub_32bit<def,read-undef,dead> = MOV32ri64 48717472; GR64_with_sub_8bit:%vreg2
160B	%RSI<def> = COPY %vreg4; GR64_with_sub_8bit:%vreg4
	Considering merging %vreg4 with %RSI
	Can only merge into reserved registers.
Remat: %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
Shrink: %vreg4 [80r,160r:0)  0@80r
All defs dead: 80r	%vreg4:sub_32bit<def,read-undef,dead> = MOV32ri64 48397984; GR64_with_sub_8bit:%vreg4
Shrunk: %vreg4 [80r,80d:0)  0@80r
Deleting dead def 80r	%vreg4:sub_32bit<def,read-undef,dead> = MOV32ri64 48397984; GR64_with_sub_8bit:%vreg4
304B	%RDI<def> = COPY %vreg8; GR64:%vreg8
	Considering merging %vreg8 with %RDI
	Can only merge into reserved registers.
Remat: %RDI<def> = MOV64ri <ga:@.str>
Shrink: %vreg8 [240r,304r:0)  0@240r
All defs dead: 240r	%vreg8<def,dead> = MOV64ri <ga:@.str>; GR64:%vreg8
Shrunk: %vreg8 [240r,240d:0)  0@240r
Deleting dead def 240r	%vreg8<def,dead> = MOV64ri <ga:@.str>; GR64:%vreg8
320B	%ESI<def> = COPY %vreg0; GR32:%vreg0
	Considering merging %vreg0 with %ESI
	Can only merge into reserved registers.
336B	%AL<def> = COPY %vreg11; GR8:%vreg11
	Considering merging %vreg11 with %AL
	Can only merge into reserved registers.
288B	%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
	Considering merging to GR32 with %vreg11 in %vreg10:sub_8bit
		RHS = %vreg11 [288r,336r:0)  0@288r
		LHS = %vreg10 [272r,288r:0)  0@272r
		merge %vreg11:0@288r into %vreg10:0@272r --> @272r
		erased:	288r	%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
		updated: 336B	%AL<def> = COPY %vreg10:sub_8bit; GR32:%vreg10
	Joined. Result = %vreg10 [272r,336r:0)  0@272r
320B	%ESI<def> = COPY %vreg0; GR32:%vreg0
	Considering merging %vreg0 with %ESI
	Can only merge into reserved registers.
336B	%AL<def> = COPY %vreg10:sub_8bit; GR32:%vreg10
	Considering merging %vreg10 with %EAX
	Can only merge into reserved registers.
Remat: %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
Shrink: %vreg10 [272r,336r:0)  0@272r
All defs dead: 272r	%vreg10<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
Shrunk: %vreg10 [272r,272d:0)  0@272r
Deleting dead def 272r	%vreg10<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
320B	%ESI<def> = COPY %vreg0; GR32:%vreg0
	Considering merging %vreg0 with %ESI
	Can only merge into reserved registers.
Trying to inflate 0 regs.
********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
%vreg0 [16r,320r:0)  0@16r
%vreg6 [112r,176r:0)  0@112r
%vreg9 [256r,352r:0)  0@256r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
320B		%ESI<def> = COPY %vreg0; GR32:%vreg0
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

Before MISsched:
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

BB#0: derived from LLVM BB %entry
    Live Ins: %EDI
	%vreg0<def> = COPY %EDI; GR32:%vreg0
	ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
	%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
	%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
	CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
	ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
	ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
	%RDI<def> = MOV64ri <ga:@.str>
	%ESI<def> = COPY %vreg0; GR32:%vreg0
	%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
	CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
	ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	RET

# End machine code for function func.

********** MI Scheduling **********
func:BB#0 entry
  From: %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
    To: CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
 RegionInstrs: 4 Remaining: 9
Disabled scoreboard hazard recognizer
Disabled scoreboard hazard recognizer
SU(0):   %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   val SU(4294967295): Latency=1 Reg=%vreg9

SU(1):   %RDI<def> = MOV64ri <ga:@.str>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

SU(2):   %ESI<def> = COPY %vreg0; GR32:%vreg0
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
   ch  SU(4294967295) *: Latency=0

SU(3):   %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

Critical Path: 1
BotQ.A: 0 3 2 1 
  SU(0) ORDER                              
  SU(3) ORDER                              
  SU(2) PREG-COPY                         
Pick Bot PREG-COPY
Scheduling SU(2) %ESI<def> = COPY %vreg0; GR32:%vreg0
handleMove 320B -> 344B: %ESI<def> = COPY %vreg0; GR32:%vreg0
     SIL:	[160r,176r:0)[344r,352r:1)  0@160r 1@344r
        -->	[160r,176r:0)[344r,352r:1)  0@160r 1@344r
     %vreg0:	[16r,320r:0)  0@16r
        -->	[16r,344r:0)  0@16r
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
BotQ.A: 0 3 1 
  SU(0) ORDER                              
  SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
  Ready @1c
  BotQ.A BotLatency SU(3) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
BotQ.A: 0 1 
  SU(0) ORDER                              
  SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %RDI<def> = MOV64ri <ga:@.str>
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
Scheduling SU(0) %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
*** Final schedule for BB#0 ***
SU(0):   %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
SU(1):   %RDI<def> = MOV64ri <ga:@.str>
SU(3):   %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
SU(2):   %ESI<def> = COPY %vreg0; GR32:%vreg0

********** MI Scheduling **********
func:BB#0 entry
  From: %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
    To: CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
 RegionInstrs: 3 Remaining: 2
SU(0):   %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   val SU(4294967295): Latency=1 Reg=%vreg6

SU(1):   %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

SU(2):   %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

Critical Path: 1
BotQ.A: 0 2 1 
  SU(0) ORDER                              
  SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
  Ready @1c
  SBPort015 +1x4u
  *** Critical resource SBPort015: 0c
  SBPortAny +1x2u
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
BotQ.A: 0 1 
  SU(0) ORDER                              
  SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
Scheduling SU(0) %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 3
  Executed: 1c
  Critical: 1c, 3 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
*** Final schedule for BB#0 ***
SU(0):   %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
SU(1):   %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
SU(2):   %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>

********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
SIL [160r,176r:0)[344r,352r:1)  0@160r 1@344r
%vreg0 [16r,344r:0)  0@16r
%vreg6 [112r,176r:0)  0@112r
%vreg9 [256r,352r:0)  0@256r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
344B		%ESI<def> = COPY %vreg0; GR32:%vreg0
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

RPO[BB#0 derived from LLVM BB entry] = 1
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#0 derived from LLVM BB entry)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0.0
Frequency(BB#0 derived from LLVM BB entry) = 1.0
LoopExitProb[BB#0 derived from LLVM BB entry] = 16383 / 16384 = 99.9939% from 1 - 0.0 / 1.0.
********** COMPUTING LIVE DEBUG VARIABLES: func **********
********** DEBUG VARIABLES **********
********** GREEDY REGISTER ALLOCATION **********
********** Function: func
********** Compute Spill Weights **********
********** Function: func
********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
SIL [160r,176r:0)[344r,352r:1)  0@160r 1@344r
%vreg0 [16r,344r:0)  0@16r
%vreg6 [112r,176r:0)  0@112r
%vreg9 [256r,352r:0)  0@256r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
344B		%ESI<def> = COPY %vreg0; GR32:%vreg0
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.


selectOrSplit GR32:%vreg0 [16r,344r:0)  0@16r
hints: %EDI
missed hint %EDI
assigning %vreg0 to %EBX: BH BL

selectOrSplit GR64_with_sub_8bit:%vreg6 [112r,176r:0)  0@112r
assigning %vreg6 to %RAX: AH AL

selectOrSplit GR64:%vreg9 [256r,352r:0)  0@256r
assigning %vreg9 to %RCX: CH CL
********** REWRITE VIRTUAL REGISTERS **********
********** Function: func
********** REGISTER MAP **********
[%vreg0 -> %EBX] GR32
[%vreg6 -> %RAX] GR64_with_sub_8bit
[%vreg9 -> %RCX] GR64

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
344B		%ESI<def> = COPY %vreg0<kill>; GR32:%vreg0
352B		CALL64r %vreg9<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET
> %EBX<def> = COPY %EDI
> ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> %EAX<def> = MOV32ri64 8971440, %RAX<imp-def>
> %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
> %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
> CALL64r %RAX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>
> ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %EBX; mem:ST4[%i.addr]
> ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> %RCX<def> = MOV64ri <ga:@printf>
> %RDI<def> = MOV64ri <ga:@.str>
> %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
> %ESI<def> = COPY %EBX<kill>
> CALL64r %RCX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def,dead>
> ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> RET
********** EMITTING LIVE DEBUG VARIABLES **********
********** Stack Slot Coloring **********
********** Function: func
******** Post-regalloc Machine LICM: func ********

Setting up live-ins for BB#0 derived from entry.
Block has no FP live-ins.

FPInst:	RET
Stack contents:
Inserted instructions:
	RET
Stack contents:
alloc FI(0) at SP[-28]
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: func
real copy:   %EBX<def> = COPY %EDI
replaced by: %EBX<def> = MOV32rr %EDI
real copy:   %ESI<def> = COPY %EBX<kill>
replaced by: %ESI<def> = MOV32rr %EBX<kill>
RPO[BB#0 derived from LLVM BB entry] = 1
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#0 derived from LLVM BB entry)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0.0
Frequency(BB#0 derived from LLVM BB entry) = 1.0
LoopExitProb[BB#0 derived from LLVM BB entry] = 16383 / 16384 = 99.9939% from 1 - 0.0 / 1.0.
********** FIX EXECUTION DEPENDENCIES: VR128 **********
BB#0: entry
JITTing function 'func'
JIT: Starting CodeGen of Function func
JIT: Emitting BB0 at [0x7f7e4367b150]
PUSH64r %RBP<kill>, %RSP<imp-def>, %RSP<imp-use>; flags: FrameSetup
PROLOG_LABEL <MCSym=.Ltmp12>
%RBP<def> = MOV64rr %RSP; flags: FrameSetup
PROLOG_LABEL <MCSym=.Ltmp13>
PUSH64r %RBX<kill>, %RSP<imp-def>, %RSP<imp-use>; flags: FrameSetup
PUSH64r %RAX<undef>, %RSP<imp-def>, %RSP<imp-use>; flags: FrameSetup
PROLOG_LABEL <MCSym=.Ltmp14>
%EBX<def> = MOV32rr %EDI
%EAX<def> = MOV32ri64 8971440, %RAX<imp-def>
%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
CALL64r %RAX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>
MOV32mr %RBP, 1, %noreg, -12, %noreg, %EBX; mem:ST4[%i.addr]
%RCX<def> = MOV64ri <ga:@printf>
%RDI<def> = MOV64ri <ga:@.str>
%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
%ESI<def> = MOV32rr %EBX<kill>
CALL64r %RCX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def,dead>
%RSP<def,tied1> = ADD64ri8 %RSP<tied0>, 8, %EFLAGS<imp-def,dead>
%RBX<def> = POP64r %RSP<imp-def>, %RSP<imp-use>
%RBP<def> = POP64r %RSP<imp-def>, %RSP<imp-use>
RET
JIT: Finished CodeGen of [0x7f7e4367b150] Function: func: 61 bytes of text, 2 relocations
JIT: Binary code:
JIT: 0: 2291377285 2511378083 136228176184 941601910 
JIT: 16: 1601902231 2552226126 24493137208 24324018572 
JIT: 32: 05350132 1917200 6710217616 00127126 
JIT: 48: 22213719249 13172209255 93918196 195
Inside Func callback func
JIT: Map 'func' to [0x0]
CGP: Found      local addrmode: [Base:%i.addr]
CGP: Found      local addrmode: [Base:%i.addr]
Computing probabilities for entry



=== func
Initial selection DAG: BB#0 'func:entry'
SelectionDAG has 37 nodes:
  0x2e5c478: ch = EntryToken

  0x2e84940: i64 = TargetConstant<0>

  0x2e84540: i64 = Register %RDI

      0x2e5c478: <multiple use>
      0x2e84940: <multiple use>
    0x2e7f3b0: ch,glue = callseq_start 0x2e5c478, 0x2e84940 [ORD=56]

    0x2e84540: <multiple use>
    0x2e7f9b0: i64 = Constant<48717472>

  0x2eaa8d0: ch,glue = CopyToReg 0x2e7f3b0, 0x2e84540, 0x2e7f9b0 [ORD=56]

  0x2e84440: i64 = Register %RSI

    0x2eaa8d0: <multiple use>
    0x2e84440: <multiple use>
    0x2e7ffb0: i64 = Constant<48397984>

    0x2eaa8d0: <multiple use>
  0x2e84840: ch,glue = CopyToReg 0x2eaa8d0, 0x2e84440, 0x2e7ffb0, 0x2eaa8d0:1 [ORD=56]

  0x2ea9a80: Untyped = RegisterMask

    0x2e84840: <multiple use>
    0x2e7fcb0: i64 = Constant<8971440>

    0x2e84540: <multiple use>
    0x2e84440: <multiple use>
    0x2ea9a80: <multiple use>
    0x2e84840: <multiple use>
  0x2ea9980: ch,glue = X86ISD::CALL 0x2e84840, 0x2e7fcb0, 0x2e84540, 0x2e84440, 0x2ea9a80, 0x2e84840:1 [ORD=56]

    0x2ea9980: <multiple use>
    0x2e84940: <multiple use>
    0x2e84940: <multiple use>
    0x2ea9980: <multiple use>
  0x2e83f40: ch,glue = callseq_end 0x2ea9980, 0x2e84940, 0x2e84940, 0x2ea9980:1 [ORD=56]

  0x2e83b40: i64 = FrameIndex<0>

  0x2e7f8b0: i64 = Constant<0>

  0x2e7fbb0: i64 = undef

        0x2e83f40: <multiple use>
        0x2e84640: i64 = Register %RAX

        0x2e83f40: <multiple use>
      0x2e800b0: i64,ch,glue = CopyFromReg 0x2e83f40, 0x2e84640, 0x2e83f40:1 [ORD=56]

        0x2e5c478: <multiple use>
        0x2e7fab0: i32 = Register %vreg0

      0x2e7feb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=52]

      0x2e83b40: <multiple use>
      0x2e7fbb0: <multiple use>
    0x2ea9780: ch = store 0x2e800b0:1, 0x2e7feb0, 0x2e83b40, 0x2e7fbb0<ST4[%i.addr]> [ORD=58]

    0x2e83b40: <multiple use>
    0x2e7fbb0: <multiple use>
  0x2e84340: i32,ch = load 0x2ea9780, 0x2e83b40, 0x2e7fbb0<LD4[%i.addr]> [ORD=59]

      0x2e84340: <multiple use>
      0x2e84940: <multiple use>
    0x2ea9680: ch,glue = callseq_start 0x2e84340:1, 0x2e84940 [ORD=60]

    0x2e84540: <multiple use>
    0x2e7f6b0: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=60]

  0x2e7f5b0: ch,glue = CopyToReg 0x2ea9680, 0x2e84540, 0x2e7f6b0 [ORD=60]

  0x2ea9b80: i32 = Register %ESI

    0x2e7f5b0: <multiple use>
    0x2ea9b80: <multiple use>
    0x2e84340: <multiple use>
    0x2e7f5b0: <multiple use>
  0x2e7fdb0: ch,glue = CopyToReg 0x2e7f5b0, 0x2ea9b80, 0x2e84340, 0x2e7f5b0:1 [ORD=60]

  0x2ea9e80: i8 = Register %AL

    0x2e7fdb0: <multiple use>
    0x2ea9e80: <multiple use>
    0x2e84240: i8 = Constant<0>

    0x2e7fdb0: <multiple use>
  0x2e84140: ch,glue = CopyToReg 0x2e7fdb0, 0x2ea9e80, 0x2e84240, 0x2e7fdb0:1 [ORD=60]

    0x2e84140: <multiple use>
    0x2e83d40: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=60]

    0x2e84540: <multiple use>
    0x2ea9b80: <multiple use>
    0x2ea9e80: <multiple use>
    0x2ea9a80: <multiple use>
    0x2e84140: <multiple use>
  0x2ea9f80: ch,glue = X86ISD::CALL 0x2e84140, 0x2e83d40, 0x2e84540, 0x2ea9b80, 0x2ea9e80, 0x2ea9a80, 0x2e84140:1 [ORD=60]

    0x2ea9f80: <multiple use>
    0x2e84940: <multiple use>
    0x2e84940: <multiple use>
    0x2ea9f80: <multiple use>
  0x2eaa480: ch,glue = callseq_end 0x2ea9f80, 0x2e84940, 0x2e84940, 0x2ea9f80:1 [ORD=60]

      0x2eaa480: <multiple use>
      0x2e83c40: i32 = Register %EAX

      0x2eaa480: <multiple use>
    0x2eaa080: i32,ch,glue = CopyFromReg 0x2eaa480, 0x2e83c40, 0x2eaa480:1 [ORD=60]

    0x2e84740: i16 = TargetConstant<0>

  0x2e7f4b0: ch = X86ISD::RET_FLAG 0x2eaa080:1, 0x2e84740 [ORD=61]



Replacing.1 0x2e84340: i32,ch = load 0x2ea9780, 0x2e83b40, 0x2e7fbb0<LD4[%i.addr]> [ORD=59]

With: 0x2e7feb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=52]
 and 1 other values
Optimized lowered selection DAG: BB#0 'func:entry'
SelectionDAG has 35 nodes:
  0x2e5c478: ch = EntryToken

    0x2e5c478: <multiple use>
    0x2e7fab0: i32 = Register %vreg0

  0x2e7feb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=52]

  0x2e84940: i64 = TargetConstant<0>

  0x2e84540: i64 = Register %RDI

      0x2e5c478: <multiple use>
      0x2e84940: <multiple use>
    0x2e7f3b0: ch,glue = callseq_start 0x2e5c478, 0x2e84940 [ORD=56]

    0x2e84540: <multiple use>
    0x2e7f9b0: i64 = Constant<48717472>

  0x2eaa8d0: ch,glue = CopyToReg 0x2e7f3b0, 0x2e84540, 0x2e7f9b0 [ORD=56]

  0x2e84440: i64 = Register %RSI

    0x2eaa8d0: <multiple use>
    0x2e84440: <multiple use>
    0x2e7ffb0: i64 = Constant<48397984>

    0x2eaa8d0: <multiple use>
  0x2e84840: ch,glue = CopyToReg 0x2eaa8d0, 0x2e84440, 0x2e7ffb0, 0x2eaa8d0:1 [ORD=56]

  0x2ea9a80: Untyped = RegisterMask

    0x2e84840: <multiple use>
    0x2e7fcb0: i64 = Constant<8971440>

    0x2e84540: <multiple use>
    0x2e84440: <multiple use>
    0x2ea9a80: <multiple use>
    0x2e84840: <multiple use>
  0x2ea9980: ch,glue = X86ISD::CALL 0x2e84840, 0x2e7fcb0, 0x2e84540, 0x2e84440, 0x2ea9a80, 0x2e84840:1 [ORD=56]

    0x2ea9980: <multiple use>
    0x2e84940: <multiple use>
    0x2e84940: <multiple use>
    0x2ea9980: <multiple use>
  0x2e83f40: ch,glue = callseq_end 0x2ea9980, 0x2e84940, 0x2e84940, 0x2ea9980:1 [ORD=56]

          0x2e83f40: <multiple use>
          0x2e84640: i64 = Register %RAX

          0x2e83f40: <multiple use>
        0x2e800b0: i64,ch,glue = CopyFromReg 0x2e83f40, 0x2e84640, 0x2e83f40:1 [ORD=56]

        0x2e7feb0: <multiple use>
        0x2e83b40: i64 = FrameIndex<0>

        0x2e7fbb0: i64 = undef

      0x2ea9780: ch = store 0x2e800b0:1, 0x2e7feb0, 0x2e83b40, 0x2e7fbb0<ST4[%i.addr]> [ORD=58]

      0x2e84940: <multiple use>
    0x2ea9680: ch,glue = callseq_start 0x2ea9780, 0x2e84940 [ORD=60]

    0x2e84540: <multiple use>
    0x2e7f6b0: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=60]

  0x2e7f5b0: ch,glue = CopyToReg 0x2ea9680, 0x2e84540, 0x2e7f6b0 [ORD=60]

  0x2ea9b80: i32 = Register %ESI

    0x2e7f5b0: <multiple use>
    0x2ea9b80: <multiple use>
    0x2e7feb0: <multiple use>
    0x2e7f5b0: <multiple use>
  0x2e7fdb0: ch,glue = CopyToReg 0x2e7f5b0, 0x2ea9b80, 0x2e7feb0, 0x2e7f5b0:1 [ORD=60]

  0x2ea9e80: i8 = Register %AL

    0x2e7fdb0: <multiple use>
    0x2ea9e80: <multiple use>
    0x2e84240: i8 = Constant<0>

    0x2e7fdb0: <multiple use>
  0x2e84140: ch,glue = CopyToReg 0x2e7fdb0, 0x2ea9e80, 0x2e84240, 0x2e7fdb0:1 [ORD=60]

    0x2e84140: <multiple use>
    0x2e83d40: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=60]

    0x2e84540: <multiple use>
    0x2ea9b80: <multiple use>
    0x2ea9e80: <multiple use>
    0x2ea9a80: <multiple use>
    0x2e84140: <multiple use>
  0x2ea9f80: ch,glue = X86ISD::CALL 0x2e84140, 0x2e83d40, 0x2e84540, 0x2ea9b80, 0x2ea9e80, 0x2ea9a80, 0x2e84140:1 [ORD=60]

    0x2ea9f80: <multiple use>
    0x2e84940: <multiple use>
    0x2e84940: <multiple use>
    0x2ea9f80: <multiple use>
  0x2eaa480: ch,glue = callseq_end 0x2ea9f80, 0x2e84940, 0x2e84940, 0x2ea9f80:1 [ORD=60]

      0x2eaa480: <multiple use>
      0x2e83c40: i32 = Register %EAX

      0x2eaa480: <multiple use>
    0x2eaa080: i32,ch,glue = CopyFromReg 0x2eaa480, 0x2e83c40, 0x2eaa480:1 [ORD=60]

    0x2e84740: i16 = TargetConstant<0>

  0x2e7f4b0: ch = X86ISD::RET_FLAG 0x2eaa080:1, 0x2e84740 [ORD=61]


Legally typed node: 0x2e84740: i16 = TargetConstant<0> [ID=0]

Legally typed node: 0x2e83c40: i32 = Register %EAX [ID=0]

Legally typed node: 0x2ea9e80: i8 = Register %AL [ID=0]

Legally typed node: 0x2ea9b80: i32 = Register %ESI [ID=0]

Legally typed node: 0x2e84240: i8 = Constant<0> [ID=0]

Legally typed node: 0x2e7f6b0: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=60] [ID=0]

Legally typed node: 0x2e83d40: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=60] [ID=0]

Legally typed node: 0x2e7fbb0: i64 = undef [ID=0]

Legally typed node: 0x2e83b40: i64 = FrameIndex<0> [ID=0]

Legally typed node: 0x2e84640: i64 = Register %RAX [ID=0]

Legally typed node: 0x2ea9a80: Untyped = RegisterMask [ID=0]

Legally typed node: 0x2e84440: i64 = Register %RSI [ID=0]

Legally typed node: 0x2e84540: i64 = Register %RDI [ID=0]

Legally typed node: 0x2e84940: i64 = TargetConstant<0> [ID=0]

Legally typed node: 0x2e7ffb0: i64 = Constant<48397984> [ID=0]

Legally typed node: 0x2e7f9b0: i64 = Constant<48717472> [ID=0]

Legally typed node: 0x2e7fcb0: i64 = Constant<8971440> [ID=0]

Legally typed node: 0x2e7fab0: i32 = Register %vreg0 [ID=0]

Legally typed node: 0x2e5c478: ch = EntryToken [ID=0]

Legally typed node: 0x2e7feb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=52] [ID=0]

Legally typed node: 0x2e7f3b0: ch,glue = callseq_start 0x2e5c478, 0x2e84940 [ORD=56] [ID=0]

Legally typed node: 0x2eaa8d0: ch,glue = CopyToReg 0x2e7f3b0, 0x2e84540, 0x2e7f9b0 [ORD=56] [ID=0]

Legally typed node: 0x2e84840: ch,glue = CopyToReg 0x2eaa8d0, 0x2e84440, 0x2e7ffb0, 0x2eaa8d0:1 [ORD=56] [ID=0]

Legally typed node: 0x2ea9980: ch,glue = X86ISD::CALL 0x2e84840, 0x2e7fcb0, 0x2e84540, 0x2e84440, 0x2ea9a80, 0x2e84840:1 [ORD=56] [ID=0]

Legally typed node: 0x2e83f40: ch,glue = callseq_end 0x2ea9980, 0x2e84940, 0x2e84940, 0x2ea9980:1 [ORD=56] [ID=0]

Legally typed node: 0x2e800b0: i64,ch,glue = CopyFromReg 0x2e83f40, 0x2e84640, 0x2e83f40:1 [ORD=56] [ID=0]

Legally typed node: 0x2ea9780: ch = store 0x2e800b0:1, 0x2e7feb0, 0x2e83b40, 0x2e7fbb0<ST4[%i.addr]> [ORD=58] [ID=0]

Legally typed node: 0x2ea9680: ch,glue = callseq_start 0x2ea9780, 0x2e84940 [ORD=60] [ID=0]

Legally typed node: 0x2e7f5b0: ch,glue = CopyToReg 0x2ea9680, 0x2e84540, 0x2e7f6b0 [ORD=60] [ID=0]

Legally typed node: 0x2e7fdb0: ch,glue = CopyToReg 0x2e7f5b0, 0x2ea9b80, 0x2e7feb0, 0x2e7f5b0:1 [ORD=60] [ID=0]

Legally typed node: 0x2e84140: ch,glue = CopyToReg 0x2e7fdb0, 0x2ea9e80, 0x2e84240, 0x2e7fdb0:1 [ORD=60] [ID=0]

Legally typed node: 0x2ea9f80: ch,glue = X86ISD::CALL 0x2e84140, 0x2e83d40, 0x2e84540, 0x2ea9b80, 0x2ea9e80, 0x2ea9a80, 0x2e84140:1 [ORD=60] [ID=0]

Legally typed node: 0x2eaa480: ch,glue = callseq_end 0x2ea9f80, 0x2e84940, 0x2e84940, 0x2ea9f80:1 [ORD=60] [ID=0]

Legally typed node: 0x2eaa080: i32,ch,glue = CopyFromReg 0x2eaa480, 0x2e83c40, 0x2eaa480:1 [ORD=60] [ID=0]

Legally typed node: 0x2e7f4b0: ch = X86ISD::RET_FLAG 0x2eaa080:1, 0x2e84740 [ORD=61] [ID=0]

Legally typed node: 0x7fff29e7ba10: ch = handlenode 0x2e7f4b0 [ID=0]

Type-legalized selection DAG: BB#0 'func:entry'
SelectionDAG has 35 nodes:
  0x2e5c478: ch = EntryToken [ID=-3]

    0x2e5c478: <multiple use>
    0x2e7fab0: i32 = Register %vreg0 [ID=-3]

  0x2e7feb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=52] [ID=-3]

  0x2e84940: i64 = TargetConstant<0> [ID=-3]

  0x2e84540: i64 = Register %RDI [ID=-3]

      0x2e5c478: <multiple use>
      0x2e84940: <multiple use>
    0x2e7f3b0: ch,glue = callseq_start 0x2e5c478, 0x2e84940 [ORD=56] [ID=-3]

    0x2e84540: <multiple use>
    0x2e7f9b0: i64 = Constant<48717472> [ID=-3]

  0x2eaa8d0: ch,glue = CopyToReg 0x2e7f3b0, 0x2e84540, 0x2e7f9b0 [ORD=56] [ID=-3]

  0x2e84440: i64 = Register %RSI [ID=-3]

    0x2eaa8d0: <multiple use>
    0x2e84440: <multiple use>
    0x2e7ffb0: i64 = Constant<48397984> [ID=-3]

    0x2eaa8d0: <multiple use>
  0x2e84840: ch,glue = CopyToReg 0x2eaa8d0, 0x2e84440, 0x2e7ffb0, 0x2eaa8d0:1 [ORD=56] [ID=-3]

  0x2ea9a80: Untyped = RegisterMask [ID=-3]

    0x2e84840: <multiple use>
    0x2e7fcb0: i64 = Constant<8971440> [ID=-3]

    0x2e84540: <multiple use>
    0x2e84440: <multiple use>
    0x2ea9a80: <multiple use>
    0x2e84840: <multiple use>
  0x2ea9980: ch,glue = X86ISD::CALL 0x2e84840, 0x2e7fcb0, 0x2e84540, 0x2e84440, 0x2ea9a80, 0x2e84840:1 [ORD=56] [ID=-3]

    0x2ea9980: <multiple use>
    0x2e84940: <multiple use>
    0x2e84940: <multiple use>
    0x2ea9980: <multiple use>
  0x2e83f40: ch,glue = callseq_end 0x2ea9980, 0x2e84940, 0x2e84940, 0x2ea9980:1 [ORD=56] [ID=-3]

          0x2e83f40: <multiple use>
          0x2e84640: i64 = Register %RAX [ID=-3]

          0x2e83f40: <multiple use>
        0x2e800b0: i64,ch,glue = CopyFromReg 0x2e83f40, 0x2e84640, 0x2e83f40:1 [ORD=56] [ID=-3]

        0x2e7feb0: <multiple use>
        0x2e83b40: i64 = FrameIndex<0> [ID=-3]

        0x2e7fbb0: i64 = undef [ID=-3]

      0x2ea9780: ch = store 0x2e800b0:1, 0x2e7feb0, 0x2e83b40, 0x2e7fbb0<ST4[%i.addr]> [ORD=58] [ID=-3]

      0x2e84940: <multiple use>
    0x2ea9680: ch,glue = callseq_start 0x2ea9780, 0x2e84940 [ORD=60] [ID=-3]

    0x2e84540: <multiple use>
    0x2e7f6b0: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=60] [ID=-3]

  0x2e7f5b0: ch,glue = CopyToReg 0x2ea9680, 0x2e84540, 0x2e7f6b0 [ORD=60] [ID=-3]

  0x2ea9b80: i32 = Register %ESI [ID=-3]

    0x2e7f5b0: <multiple use>
    0x2ea9b80: <multiple use>
    0x2e7feb0: <multiple use>
    0x2e7f5b0: <multiple use>
  0x2e7fdb0: ch,glue = CopyToReg 0x2e7f5b0, 0x2ea9b80, 0x2e7feb0, 0x2e7f5b0:1 [ORD=60] [ID=-3]

  0x2ea9e80: i8 = Register %AL [ID=-3]

    0x2e7fdb0: <multiple use>
    0x2ea9e80: <multiple use>
    0x2e84240: i8 = Constant<0> [ID=-3]

    0x2e7fdb0: <multiple use>
  0x2e84140: ch,glue = CopyToReg 0x2e7fdb0, 0x2ea9e80, 0x2e84240, 0x2e7fdb0:1 [ORD=60] [ID=-3]

    0x2e84140: <multiple use>
    0x2e83d40: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=60] [ID=-3]

    0x2e84540: <multiple use>
    0x2ea9b80: <multiple use>
    0x2ea9e80: <multiple use>
    0x2ea9a80: <multiple use>
    0x2e84140: <multiple use>
  0x2ea9f80: ch,glue = X86ISD::CALL 0x2e84140, 0x2e83d40, 0x2e84540, 0x2ea9b80, 0x2ea9e80, 0x2ea9a80, 0x2e84140:1 [ORD=60] [ID=-3]

    0x2ea9f80: <multiple use>
    0x2e84940: <multiple use>
    0x2e84940: <multiple use>
    0x2ea9f80: <multiple use>
  0x2eaa480: ch,glue = callseq_end 0x2ea9f80, 0x2e84940, 0x2e84940, 0x2ea9f80:1 [ORD=60] [ID=-3]

      0x2eaa480: <multiple use>
      0x2e83c40: i32 = Register %EAX [ID=-3]

      0x2eaa480: <multiple use>
    0x2eaa080: i32,ch,glue = CopyFromReg 0x2eaa480, 0x2e83c40, 0x2eaa480:1 [ORD=60] [ID=-3]

    0x2e84740: i16 = TargetConstant<0> [ID=-3]

  0x2e7f4b0: ch = X86ISD::RET_FLAG 0x2eaa080:1, 0x2e84740 [ORD=61] [ID=-3]


Legalized selection DAG: BB#0 'func:entry'
SelectionDAG has 37 nodes:
  0x2e5c478: ch = EntryToken [ID=0]

  0x2e84940: i64 = TargetConstant<0> [ID=5]

  0x2e84540: i64 = Register %RDI [ID=6]

  0x2e84440: i64 = Register %RSI [ID=7]

  0x2ea9a80: Untyped = RegisterMask [ID=8]

  0x2ea9b80: i32 = Register %ESI [ID=15]

  0x2ea9e80: i8 = Register %AL [ID=16]

    0x2e5c478: <multiple use>
    0x2e7fab0: i32 = Register %vreg0 [ID=1]

  0x2e7feb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=52] [ID=19]

      0x2e5c478: <multiple use>
      0x2e84940: <multiple use>
    0x2e7f3b0: ch,glue = callseq_start 0x2e5c478, 0x2e84940 [ORD=56] [ID=20]

    0x2e84540: <multiple use>
    0x2e7f9b0: i64 = Constant<48717472> [ID=3]

  0x2eaa8d0: ch,glue = CopyToReg 0x2e7f3b0, 0x2e84540, 0x2e7f9b0 [ORD=56] [ID=21]

    0x2eaa8d0: <multiple use>
    0x2e84440: <multiple use>
    0x2e7ffb0: i64 = Constant<48397984> [ID=4]

    0x2eaa8d0: <multiple use>
  0x2e84840: ch,glue = CopyToReg 0x2eaa8d0, 0x2e84440, 0x2e7ffb0, 0x2eaa8d0:1 [ORD=56] [ID=22]

    0x2e84840: <multiple use>
    0x2e7fcb0: i64 = Constant<8971440> [ID=2]

    0x2e84540: <multiple use>
    0x2e84440: <multiple use>
    0x2ea9a80: <multiple use>
    0x2e84840: <multiple use>
  0x2ea9980: ch,glue = X86ISD::CALL 0x2e84840, 0x2e7fcb0, 0x2e84540, 0x2e84440, 0x2ea9a80, 0x2e84840:1 [ORD=56] [ID=23]

    0x2ea9980: <multiple use>
    0x2e84940: <multiple use>
    0x2e84940: <multiple use>
    0x2ea9980: <multiple use>
  0x2e83f40: ch,glue = callseq_end 0x2ea9980, 0x2e84940, 0x2e84940, 0x2ea9980:1 [ORD=56] [ID=24]

          0x2e83f40: <multiple use>
          0x2e84640: i64 = Register %RAX [ID=9]

          0x2e83f40: <multiple use>
        0x2e800b0: i64,ch,glue = CopyFromReg 0x2e83f40, 0x2e84640, 0x2e83f40:1 [ORD=56] [ID=25]

        0x2e7feb0: <multiple use>
        0x2e83b40: i64 = FrameIndex<0> [ID=10]

        0x2e7fbb0: i64 = undef [ID=11]

      0x2ea9780: ch = store 0x2e800b0:1, 0x2e7feb0, 0x2e83b40, 0x2e7fbb0<ST4[%i.addr]> [ORD=58] [ID=26]

      0x2e84940: <multiple use>
    0x2ea9680: ch,glue = callseq_start 0x2ea9780, 0x2e84940 [ORD=60] [ID=27]

    0x2e84540: <multiple use>
      0x2e7f8b0: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=60]

    0x2e84340: i64 = X86ISD::Wrapper 0x2e7f8b0 [ORD=60]

  0x2e7f5b0: ch,glue = CopyToReg 0x2ea9680, 0x2e84540, 0x2e84340 [ORD=60] [ID=28]

    0x2e7f5b0: <multiple use>
    0x2ea9b80: <multiple use>
    0x2e7feb0: <multiple use>
    0x2e7f5b0: <multiple use>
  0x2e7fdb0: ch,glue = CopyToReg 0x2e7f5b0, 0x2ea9b80, 0x2e7feb0, 0x2e7f5b0:1 [ORD=60] [ID=29]

    0x2e7fdb0: <multiple use>
    0x2ea9e80: <multiple use>
    0x2e84240: i8 = Constant<0> [ID=14]

    0x2e7fdb0: <multiple use>
  0x2e84140: ch,glue = CopyToReg 0x2e7fdb0, 0x2ea9e80, 0x2e84240, 0x2e7fdb0:1 [ORD=60] [ID=30]

    0x2e84140: <multiple use>
      0x2e7f6b0: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=60]

    0x2e801b0: i64 = X86ISD::Wrapper 0x2e7f6b0 [ORD=60]

    0x2e84540: <multiple use>
    0x2ea9b80: <multiple use>
    0x2ea9e80: <multiple use>
    0x2ea9a80: <multiple use>
    0x2e84140: <multiple use>
  0x2ea9f80: ch,glue = X86ISD::CALL 0x2e84140, 0x2e801b0, 0x2e84540, 0x2ea9b80, 0x2ea9e80, 0x2ea9a80, 0x2e84140:1 [ORD=60] [ID=31]

    0x2ea9f80: <multiple use>
    0x2e84940: <multiple use>
    0x2e84940: <multiple use>
    0x2ea9f80: <multiple use>
  0x2eaa480: ch,glue = callseq_end 0x2ea9f80, 0x2e84940, 0x2e84940, 0x2ea9f80:1 [ORD=60] [ID=32]

      0x2eaa480: <multiple use>
      0x2e83c40: i32 = Register %EAX [ID=17]

      0x2eaa480: <multiple use>
    0x2eaa080: i32,ch,glue = CopyFromReg 0x2eaa480, 0x2e83c40, 0x2eaa480:1 [ORD=60] [ID=33]

    0x2e84740: i16 = TargetConstant<0> [ID=18]

  0x2e7f4b0: ch = X86ISD::RET_FLAG 0x2eaa080:1, 0x2e84740 [ORD=61] [ID=34]


Optimized legalized selection DAG: BB#0 'func:entry'
SelectionDAG has 37 nodes:
  0x2e5c478: ch = EntryToken [ID=0]

  0x2e84940: i64 = TargetConstant<0> [ID=5]

  0x2e84540: i64 = Register %RDI [ID=6]

  0x2e84440: i64 = Register %RSI [ID=7]

  0x2ea9a80: Untyped = RegisterMask [ID=8]

  0x2ea9b80: i32 = Register %ESI [ID=15]

  0x2ea9e80: i8 = Register %AL [ID=16]

    0x2e5c478: <multiple use>
    0x2e7fab0: i32 = Register %vreg0 [ID=1]

  0x2e7feb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=52] [ID=19]

      0x2e5c478: <multiple use>
      0x2e84940: <multiple use>
    0x2e7f3b0: ch,glue = callseq_start 0x2e5c478, 0x2e84940 [ORD=56] [ID=20]

    0x2e84540: <multiple use>
    0x2e7f9b0: i64 = Constant<48717472> [ID=3]

  0x2eaa8d0: ch,glue = CopyToReg 0x2e7f3b0, 0x2e84540, 0x2e7f9b0 [ORD=56] [ID=21]

    0x2eaa8d0: <multiple use>
    0x2e84440: <multiple use>
    0x2e7ffb0: i64 = Constant<48397984> [ID=4]

    0x2eaa8d0: <multiple use>
  0x2e84840: ch,glue = CopyToReg 0x2eaa8d0, 0x2e84440, 0x2e7ffb0, 0x2eaa8d0:1 [ORD=56] [ID=22]

    0x2e84840: <multiple use>
    0x2e7fcb0: i64 = Constant<8971440> [ID=2]

    0x2e84540: <multiple use>
    0x2e84440: <multiple use>
    0x2ea9a80: <multiple use>
    0x2e84840: <multiple use>
  0x2ea9980: ch,glue = X86ISD::CALL 0x2e84840, 0x2e7fcb0, 0x2e84540, 0x2e84440, 0x2ea9a80, 0x2e84840:1 [ORD=56] [ID=23]

    0x2ea9980: <multiple use>
    0x2e84940: <multiple use>
    0x2e84940: <multiple use>
    0x2ea9980: <multiple use>
  0x2e83f40: ch,glue = callseq_end 0x2ea9980, 0x2e84940, 0x2e84940, 0x2ea9980:1 [ORD=56] [ID=24]

          0x2e83f40: <multiple use>
          0x2e84640: i64 = Register %RAX [ID=9]

          0x2e83f40: <multiple use>
        0x2e800b0: i64,ch,glue = CopyFromReg 0x2e83f40, 0x2e84640, 0x2e83f40:1 [ORD=56] [ID=25]

        0x2e7feb0: <multiple use>
        0x2e83b40: i64 = FrameIndex<0> [ID=10]

        0x2e7fbb0: i64 = undef [ID=11]

      0x2ea9780: ch = store 0x2e800b0:1, 0x2e7feb0, 0x2e83b40, 0x2e7fbb0<ST4[%i.addr]> [ORD=58] [ID=26]

      0x2e84940: <multiple use>
    0x2ea9680: ch,glue = callseq_start 0x2ea9780, 0x2e84940 [ORD=60] [ID=27]

    0x2e84540: <multiple use>
      0x2e7f8b0: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=60]

    0x2e84340: i64 = X86ISD::Wrapper 0x2e7f8b0 [ORD=60]

  0x2e7f5b0: ch,glue = CopyToReg 0x2ea9680, 0x2e84540, 0x2e84340 [ORD=60] [ID=28]

    0x2e7f5b0: <multiple use>
    0x2ea9b80: <multiple use>
    0x2e7feb0: <multiple use>
    0x2e7f5b0: <multiple use>
  0x2e7fdb0: ch,glue = CopyToReg 0x2e7f5b0, 0x2ea9b80, 0x2e7feb0, 0x2e7f5b0:1 [ORD=60] [ID=29]

    0x2e7fdb0: <multiple use>
    0x2ea9e80: <multiple use>
    0x2e84240: i8 = Constant<0> [ID=14]

    0x2e7fdb0: <multiple use>
  0x2e84140: ch,glue = CopyToReg 0x2e7fdb0, 0x2ea9e80, 0x2e84240, 0x2e7fdb0:1 [ORD=60] [ID=30]

    0x2e84140: <multiple use>
      0x2e7f6b0: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=60]

    0x2e801b0: i64 = X86ISD::Wrapper 0x2e7f6b0 [ORD=60]

    0x2e84540: <multiple use>
    0x2ea9b80: <multiple use>
    0x2ea9e80: <multiple use>
    0x2ea9a80: <multiple use>
    0x2e84140: <multiple use>
  0x2ea9f80: ch,glue = X86ISD::CALL 0x2e84140, 0x2e801b0, 0x2e84540, 0x2ea9b80, 0x2ea9e80, 0x2ea9a80, 0x2e84140:1 [ORD=60] [ID=31]

    0x2ea9f80: <multiple use>
    0x2e84940: <multiple use>
    0x2e84940: <multiple use>
    0x2ea9f80: <multiple use>
  0x2eaa480: ch,glue = callseq_end 0x2ea9f80, 0x2e84940, 0x2e84940, 0x2ea9f80:1 [ORD=60] [ID=32]

      0x2eaa480: <multiple use>
      0x2e83c40: i32 = Register %EAX [ID=17]

      0x2eaa480: <multiple use>
    0x2eaa080: i32,ch,glue = CopyFromReg 0x2eaa480, 0x2e83c40, 0x2eaa480:1 [ORD=60] [ID=33]

    0x2e84740: i16 = TargetConstant<0> [ID=18]

  0x2e7f4b0: ch = X86ISD::RET_FLAG 0x2eaa080:1, 0x2e84740 [ORD=61] [ID=34]


===== Instruction selection begins: BB#0 'entry'
Selecting: 0x2e7f4b0: ch = X86ISD::RET_FLAG 0x2eaa080:1, 0x2e84740 [ORD=61] [ID=36]

ISEL: Starting pattern match on root node: 0x2e7f4b0: ch = X86ISD::RET_FLAG 0x2eaa080:1, 0x2e84740 [ORD=61] [ID=36]

  Initial Opcode index to 93235
  Morphed node: 0x2e7f4b0: ch = RET 0x2eaa080:1 [ORD=61]

ISEL: Match complete!
=> 0x2e7f4b0: ch = RET 0x2eaa080:1 [ORD=61]

Selecting: 0x2eaa080: i32,ch,glue = CopyFromReg 0x2eaa480, 0x2e83c40, 0x2eaa480:1 [ORD=60] [ID=35]

=> 0x2eaa080: i32,ch,glue = CopyFromReg 0x2eaa480, 0x2e83c40, 0x2eaa480:1 [ORD=60]

Selecting: 0x2eaa480: ch,glue = callseq_end 0x2ea9f80, 0x2e84940, 0x2e84940, 0x2ea9f80:1 [ORD=60] [ID=34]

ISEL: Starting pattern match on root node: 0x2eaa480: ch,glue = callseq_end 0x2ea9f80, 0x2e84940, 0x2e84940, 0x2ea9f80:1 [ORD=60] [ID=34]

  Initial Opcode index to 92907
  Skipped scope entry (due to false predicate) at index 92925, continuing at 92937
  Morphed node: 0x2eaa480: i64,ch,glue = ADJCALLSTACKUP64 0x2e84940, 0x2e84940, 0x2ea9f80, 0x2ea9f80:1 [ORD=60]

ISEL: Match complete!
=> 0x2eaa480: i64,ch,glue = ADJCALLSTACKUP64 0x2e84940, 0x2e84940, 0x2ea9f80, 0x2ea9f80:1 [ORD=60]

Selecting: 0x2ea9f80: ch,glue = X86ISD::CALL 0x2e84140, 0x2e801b0, 0x2e84540, 0x2ea9b80, 0x2ea9e80, 0x2ea9a80, 0x2e84140:1 [ORD=60] [ID=33]

ISEL: Starting pattern match on root node: 0x2ea9f80: ch,glue = X86ISD::CALL 0x2e84140, 0x2e801b0, 0x2e84540, 0x2ea9b80, 0x2ea9e80, 0x2ea9a80, 0x2e84140:1 [ORD=60] [ID=33]

  Initial Opcode index to 69884
  Match failed at index 69890
  Continuing at 69951
  Match failed at index 69957
  Continuing at 70031
  Match failed at index 70032
  Continuing at 70044
  Morphed node: 0x2ea9f80: ch,glue = CALL64r 0x2e801b0, 0x2e84540, 0x2ea9b80, 0x2ea9e80, 0x2ea9a80, 0x2e84140, 0x2e84140:1 [ORD=60]

ISEL: Match complete!
=> 0x2ea9f80: ch,glue = CALL64r 0x2e801b0, 0x2e84540, 0x2ea9b80, 0x2ea9e80, 0x2ea9a80, 0x2e84140, 0x2e84140:1 [ORD=60]

Selecting: 0x2e84140: ch,glue = CopyToReg 0x2e7fdb0, 0x2ea9e80, 0x2e84240, 0x2e7fdb0:1 [ORD=60] [ID=32]

=> 0x2e84140: ch,glue = CopyToReg 0x2e7fdb0, 0x2ea9e80, 0x2e84240, 0x2e7fdb0:1 [ORD=60]

Selecting: 0x2e7fdb0: ch,glue = CopyToReg 0x2e7f5b0, 0x2ea9b80, 0x2e7feb0, 0x2e7f5b0:1 [ORD=60] [ID=31]

=> 0x2e7fdb0: ch,glue = CopyToReg 0x2e7f5b0, 0x2ea9b80, 0x2e7feb0, 0x2e7f5b0:1 [ORD=60]

Selecting: 0x2e7f5b0: ch,glue = CopyToReg 0x2ea9680, 0x2e84540, 0x2e84340 [ORD=60] [ID=30]

=> 0x2e7f5b0: ch,glue = CopyToReg 0x2ea9680, 0x2e84540, 0x2e84340 [ORD=60]

Selecting: 0x2ea9680: ch,glue = callseq_start 0x2ea9780, 0x2e84940 [ORD=60] [ID=29]

ISEL: Starting pattern match on root node: 0x2ea9680: ch,glue = callseq_start 0x2ea9780, 0x2e84940 [ORD=60] [ID=29]

  Initial Opcode index to 95380
  Skipped scope entry (due to false predicate) at index 95390, continuing at 95401
  Morphed node: 0x2ea9680: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84940, 0x2ea9780 [ORD=60]

ISEL: Match complete!
=> 0x2ea9680: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84940, 0x2ea9780 [ORD=60]

Selecting: 0x2ea9780: ch = store 0x2e800b0:1, 0x2e7feb0, 0x2e83b40, 0x2e7fbb0<ST4[%i.addr]> [ORD=58] [ID=28]

ISEL: Starting pattern match on root node: 0x2ea9780: ch = store 0x2e800b0:1, 0x2e7feb0, 0x2e83b40, 0x2e7fbb0<ST4[%i.addr]> [ORD=58] [ID=28]

  Initial Opcode index to 5
  Skipped scope entry (due to false predicate) at index 13, continuing at 58
  Skipped scope entry (due to false predicate) at index 59, continuing at 104
  Skipped scope entry (due to false predicate) at index 105, continuing at 188
  Skipped scope entry (due to false predicate) at index 189, continuing at 212
  Skipped scope entry (due to false predicate) at index 213, continuing at 236
  Skipped scope entry (due to false predicate) at index 237, continuing at 260
  Match failed at index 264
  Continuing at 284
  Match failed at index 285
  Continuing at 308
  Continuing at 309
  Match failed at index 313
  Continuing at 10708
  Match failed at index 10713
  Continuing at 11131
  Match failed at index 11135
  Continuing at 11509
  Match failed at index 11513
  Continuing at 11624
  Match failed at index 11628
  Continuing at 11859
  Skipped scope entry (due to false predicate) at index 11864, continuing at 11950
  Skipped scope entry (due to false predicate) at index 11951, continuing at 12064
  Skipped scope entry (due to false predicate) at index 12065, continuing at 12137
  Skipped scope entry (due to false predicate) at index 12138, continuing at 12161
  Skipped scope entry (due to false predicate) at index 12162, continuing at 12185
MatchAddress: X86ISelAddressMode 0x7fff29e7b560
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
  Morphed node: 0x2ea9780: ch = MOV32mr 0x2e83d40, 0x2ea9880, 0x2e84740, 0x2ea9c80, 0x2e7f7b0, 0x2e7feb0, 0x2e800b0:1<Mem:ST4[%i.addr]> [ORD=58]

ISEL: Match complete!
=> 0x2ea9780: ch = MOV32mr 0x2e83d40, 0x2ea9880, 0x2e84740, 0x2ea9c80, 0x2e7f7b0, 0x2e7feb0, 0x2e800b0:1<Mem:ST4[%i.addr]> [ORD=58]

Selecting: 0x2e800b0: i64,ch,glue = CopyFromReg 0x2e83f40, 0x2e84640, 0x2e83f40:1 [ORD=56] [ID=27]

=> 0x2e800b0: i64,ch,glue = CopyFromReg 0x2e83f40, 0x2e84640, 0x2e83f40:1 [ORD=56]

Selecting: 0x2e83f40: ch,glue = callseq_end 0x2ea9980, 0x2e84940, 0x2e84940, 0x2ea9980:1 [ORD=56] [ID=26]

ISEL: Starting pattern match on root node: 0x2e83f40: ch,glue = callseq_end 0x2ea9980, 0x2e84940, 0x2e84940, 0x2ea9980:1 [ORD=56] [ID=26]

  Initial Opcode index to 92907
  Skipped scope entry (due to false predicate) at index 92925, continuing at 92937
  Morphed node: 0x2e83f40: i64,ch,glue = ADJCALLSTACKUP64 0x2e84940, 0x2e84940, 0x2ea9980, 0x2ea9980:1 [ORD=56]

ISEL: Match complete!
=> 0x2e83f40: i64,ch,glue = ADJCALLSTACKUP64 0x2e84940, 0x2e84940, 0x2ea9980, 0x2ea9980:1 [ORD=56]

Selecting: 0x2ea9980: ch,glue = X86ISD::CALL 0x2e84840, 0x2e7fcb0, 0x2e84540, 0x2e84440, 0x2ea9a80, 0x2e84840:1 [ORD=56] [ID=25]

ISEL: Starting pattern match on root node: 0x2ea9980: ch,glue = X86ISD::CALL 0x2e84840, 0x2e7fcb0, 0x2e84540, 0x2e84440, 0x2ea9a80, 0x2e84840:1 [ORD=56] [ID=25]

  Initial Opcode index to 69884
  Match failed at index 69890
  Continuing at 69951
  OpcodeSwitch from 69957 to 70015
  Match failed at index 70015
  Continuing at 70031
  Match failed at index 70032
  Continuing at 70044
  Morphed node: 0x2ea9980: ch,glue = CALL64r 0x2e7fcb0, 0x2e84540, 0x2e84440, 0x2ea9a80, 0x2e84840, 0x2e84840:1 [ORD=56]

ISEL: Match complete!
=> 0x2ea9980: ch,glue = CALL64r 0x2e7fcb0, 0x2e84540, 0x2e84440, 0x2ea9a80, 0x2e84840, 0x2e84840:1 [ORD=56]

Selecting: 0x2e84840: ch,glue = CopyToReg 0x2eaa8d0, 0x2e84440, 0x2e7ffb0, 0x2eaa8d0:1 [ORD=56] [ID=24]

=> 0x2e84840: ch,glue = CopyToReg 0x2eaa8d0, 0x2e84440, 0x2e7ffb0, 0x2eaa8d0:1 [ORD=56]

Selecting: 0x2eaa8d0: ch,glue = CopyToReg 0x2e7f3b0, 0x2e84540, 0x2e7f9b0 [ORD=56] [ID=23]

=> 0x2eaa8d0: ch,glue = CopyToReg 0x2e7f3b0, 0x2e84540, 0x2e7f9b0 [ORD=56]

Selecting: 0x2e801b0: i64 = X86ISD::Wrapper 0x2e7f6b0 [ORD=60] [ID=22]

ISEL: Starting pattern match on root node: 0x2e801b0: i64 = X86ISD::Wrapper 0x2e7f6b0 [ORD=60] [ID=22]

  Initial Opcode index to 94787
  Match failed at index 94792
  Continuing at 94819
  OpcodeSwitch from 94824 to 94938
  TypeSwitch[i64] from 94939 to 94952
  Morphed node: 0x2e801b0: i64 = MOV64ri 0x2e7f6b0 [ORD=60]

ISEL: Match complete!
=> 0x2e801b0: i64 = MOV64ri 0x2e7f6b0 [ORD=60]

Selecting: 0x2e84340: i64 = X86ISD::Wrapper 0x2e7f8b0 [ORD=60] [ID=21]

ISEL: Starting pattern match on root node: 0x2e84340: i64 = X86ISD::Wrapper 0x2e7f8b0 [ORD=60] [ID=21]

  Initial Opcode index to 94787
  Match failed at index 94792
  Continuing at 94819
  OpcodeSwitch from 94824 to 94938
  TypeSwitch[i64] from 94939 to 94952
  Morphed node: 0x2e84340: i64 = MOV64ri 0x2e7f8b0 [ORD=60]

ISEL: Match complete!
=> 0x2e84340: i64 = MOV64ri 0x2e7f8b0 [ORD=60]

Selecting: 0x2e7f3b0: ch,glue = callseq_start 0x2e5c478, 0x2e84940 [ORD=56] [ID=20]

ISEL: Starting pattern match on root node: 0x2e7f3b0: ch,glue = callseq_start 0x2e5c478, 0x2e84940 [ORD=56] [ID=20]

  Initial Opcode index to 95380
  Skipped scope entry (due to false predicate) at index 95390, continuing at 95401
  Morphed node: 0x2e7f3b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84940, 0x2e5c478 [ORD=56]

ISEL: Match complete!
=> 0x2e7f3b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84940, 0x2e5c478 [ORD=56]

Selecting: 0x2e7feb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=52] [ID=19]

=> 0x2e7feb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=52]

Selecting: 0x2e7f6b0: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=60] [ID=18]

=> 0x2e7f6b0: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=60]

Selecting: 0x2e7f8b0: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=60] [ID=17]

=> 0x2e7f8b0: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=60]

Selecting: 0x2e83c40: i32 = Register %EAX [ID=15]

=> 0x2e83c40: i32 = Register %EAX

Selecting: 0x2ea9e80: i8 = Register %AL [ID=14]

=> 0x2ea9e80: i8 = Register %AL

Selecting: 0x2ea9b80: i32 = Register %ESI [ID=13]

=> 0x2ea9b80: i32 = Register %ESI

Selecting: 0x2e84240: i8 = Constant<0> [ID=12]

ISEL: Starting pattern match on root node: 0x2e84240: i8 = Constant<0> [ID=12]

  Initial Opcode index to 82786
  Match failed at index 82790
  Continuing at 82816
  Match failed at index 82818
  Continuing at 82847
  TypeSwitch[i8] from 82850 to 82863
  Created node: 0x2e83b40: i32,i32 = MOV32r0

  Morphed node: 0x2e84240: i8 = EXTRACT_SUBREG 0x2e83b40, 0x2e7fbb0

ISEL: Match complete!
=> 0x2e84240: i8 = EXTRACT_SUBREG 0x2e83b40, 0x2e7fbb0

Selecting: 0x2e84640: i64 = Register %RAX [ID=9]

=> 0x2e84640: i64 = Register %RAX

Selecting: 0x2ea9a80: Untyped = RegisterMask [ID=8]

=> 0x2ea9a80: Untyped = RegisterMask

Selecting: 0x2e84440: i64 = Register %RSI [ID=7]

=> 0x2e84440: i64 = Register %RSI

Selecting: 0x2e84540: i64 = Register %RDI [ID=6]

=> 0x2e84540: i64 = Register %RDI

Selecting: 0x2e84940: i64 = TargetConstant<0> [ID=5]

=> 0x2e84940: i64 = TargetConstant<0>

Selecting: 0x2e7ffb0: i64 = Constant<48397984> [ID=4]

ISEL: Starting pattern match on root node: 0x2e7ffb0: i64 = Constant<48397984> [ID=4]

  Initial Opcode index to 82786
  Skipped scope entry (due to false predicate) at index 82788, continuing at 82816
  Created node: 0x2e84040: i32 = MOV32ri64 0x2ea9d80

  Morphed node: 0x2e7ffb0: i64 = SUBREG_TO_REG 0x2e84940, 0x2e84040, 0x2e83e40

ISEL: Match complete!
=> 0x2e7ffb0: i64 = SUBREG_TO_REG 0x2e84940, 0x2e84040, 0x2e83e40

Selecting: 0x2e7f9b0: i64 = Constant<48717472> [ID=3]

ISEL: Starting pattern match on root node: 0x2e7f9b0: i64 = Constant<48717472> [ID=3]

  Initial Opcode index to 82786
  Skipped scope entry (due to false predicate) at index 82788, continuing at 82816
  Created node: 0x2eaa280: i32 = MOV32ri64 0x2eaa180

  Morphed node: 0x2e7f9b0: i64 = SUBREG_TO_REG 0x2e84940, 0x2eaa280, 0x2e83e40

ISEL: Match complete!
=> 0x2e7f9b0: i64 = SUBREG_TO_REG 0x2e84940, 0x2eaa280, 0x2e83e40

Selecting: 0x2e7fcb0: i64 = Constant<8971440> [ID=2]

ISEL: Starting pattern match on root node: 0x2e7fcb0: i64 = Constant<8971440> [ID=2]

  Initial Opcode index to 82786
  Skipped scope entry (due to false predicate) at index 82788, continuing at 82816
  Created node: 0x2eaa9d0: i32 = MOV32ri64 0x2eaa380

  Morphed node: 0x2e7fcb0: i64 = SUBREG_TO_REG 0x2e84940, 0x2eaa9d0, 0x2e83e40

ISEL: Match complete!
=> 0x2e7fcb0: i64 = SUBREG_TO_REG 0x2e84940, 0x2eaa9d0, 0x2e83e40

Selecting: 0x2e7fab0: i32 = Register %vreg0 [ID=1]

=> 0x2e7fab0: i32 = Register %vreg0

Selecting: 0x2e5c478: ch = EntryToken [ID=0]

=> 0x2e5c478: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: BB#0 'func:entry'
SelectionDAG has 48 nodes:
  0x2e5c478: ch = EntryToken

  0x2e84940: i64 = TargetConstant<0>

  0x2e84540: i64 = Register %RDI

  0x2e84440: i64 = Register %RSI

  0x2ea9a80: Untyped = RegisterMask

  0x2ea9b80: i32 = Register %ESI

  0x2ea9e80: i8 = Register %AL

    0x2e5c478: <multiple use>
    0x2e7fab0: i32 = Register %vreg0

  0x2e7feb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=52]

      0x2e84940: <multiple use>
      0x2e5c478: <multiple use>
    0x2e7f3b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84940, 0x2e5c478 [ORD=56]

    0x2e84540: <multiple use>
      0x2e84940: <multiple use>
        0x2eaa180: i64 = TargetConstant<48717472>

      0x2eaa280: i32 = MOV32ri64 0x2eaa180

      0x2e83e40: <multiple use>
    0x2e7f9b0: i64 = SUBREG_TO_REG 0x2e84940, 0x2eaa280, 0x2e83e40

  0x2eaa8d0: ch,glue = CopyToReg 0x2e7f3b0:1, 0x2e84540, 0x2e7f9b0 [ORD=56]

    0x2eaa8d0: <multiple use>
    0x2e84440: <multiple use>
      0x2e84940: <multiple use>
        0x2ea9d80: i64 = TargetConstant<48397984>

      0x2e84040: i32 = MOV32ri64 0x2ea9d80

      0x2e83e40: <multiple use>
    0x2e7ffb0: i64 = SUBREG_TO_REG 0x2e84940, 0x2e84040, 0x2e83e40

    0x2eaa8d0: <multiple use>
  0x2e84840: ch,glue = CopyToReg 0x2eaa8d0, 0x2e84440, 0x2e7ffb0, 0x2eaa8d0:1 [ORD=56]

      0x2e84940: <multiple use>
        0x2eaa380: i64 = TargetConstant<8971440>

      0x2eaa9d0: i32 = MOV32ri64 0x2eaa380

      0x2e83e40: <multiple use>
    0x2e7fcb0: i64 = SUBREG_TO_REG 0x2e84940, 0x2eaa9d0, 0x2e83e40

    0x2e84540: <multiple use>
    0x2e84440: <multiple use>
    0x2ea9a80: <multiple use>
    0x2e84840: <multiple use>
    0x2e84840: <multiple use>
  0x2ea9980: ch,glue = CALL64r 0x2e7fcb0, 0x2e84540, 0x2e84440, 0x2ea9a80, 0x2e84840, 0x2e84840:1 [ORD=56]

    0x2e84940: <multiple use>
    0x2e84940: <multiple use>
    0x2ea9980: <multiple use>
    0x2ea9980: <multiple use>
  0x2e83f40: i64,ch,glue = ADJCALLSTACKUP64 0x2e84940, 0x2e84940, 0x2ea9980, 0x2ea9980:1 [ORD=56]

      0x2e84940: <multiple use>
        0x2e83d40: i64 = TargetFrameIndex<0>

        0x2ea9880: i8 = TargetConstant<1>

        0x2e84740: i64 = Register %noreg

        0x2ea9c80: i32 = TargetConstant<0>

        0x2e7f7b0: i32 = Register %noreg

        0x2e7feb0: <multiple use>
          0x2e83f40: <multiple use>
          0x2e84640: i64 = Register %RAX

          0x2e83f40: <multiple use>
        0x2e800b0: i64,ch,glue = CopyFromReg 0x2e83f40:1, 0x2e84640, 0x2e83f40:2 [ORD=56]

      0x2ea9780: ch = MOV32mr 0x2e83d40, 0x2ea9880, 0x2e84740, 0x2ea9c80, 0x2e7f7b0, 0x2e7feb0, 0x2e800b0:1<Mem:ST4[%i.addr]> [ORD=58]

    0x2ea9680: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84940, 0x2ea9780 [ORD=60]

    0x2e84540: <multiple use>
      0x2e7f8b0: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=60]

    0x2e84340: i64 = MOV64ri 0x2e7f8b0 [ORD=60]

  0x2e7f5b0: ch,glue = CopyToReg 0x2ea9680:1, 0x2e84540, 0x2e84340 [ORD=60]

    0x2e7f5b0: <multiple use>
    0x2ea9b80: <multiple use>
    0x2e7feb0: <multiple use>
    0x2e7f5b0: <multiple use>
  0x2e7fdb0: ch,glue = CopyToReg 0x2e7f5b0, 0x2ea9b80, 0x2e7feb0, 0x2e7f5b0:1 [ORD=60]

    0x2e7fdb0: <multiple use>
    0x2ea9e80: <multiple use>
      0x2e83b40: i32,i32 = MOV32r0

      0x2e7fbb0: i32 = TargetConstant<1>

    0x2e84240: i8 = EXTRACT_SUBREG 0x2e83b40, 0x2e7fbb0

    0x2e7fdb0: <multiple use>
  0x2e84140: ch,glue = CopyToReg 0x2e7fdb0, 0x2ea9e80, 0x2e84240, 0x2e7fdb0:1 [ORD=60]

      0x2e7f6b0: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=60]

    0x2e801b0: i64 = MOV64ri 0x2e7f6b0 [ORD=60]

    0x2e84540: <multiple use>
    0x2ea9b80: <multiple use>
    0x2ea9e80: <multiple use>
    0x2ea9a80: <multiple use>
    0x2e84140: <multiple use>
    0x2e84140: <multiple use>
  0x2ea9f80: ch,glue = CALL64r 0x2e801b0, 0x2e84540, 0x2ea9b80, 0x2ea9e80, 0x2ea9a80, 0x2e84140, 0x2e84140:1 [ORD=60]

    0x2e84940: <multiple use>
    0x2e84940: <multiple use>
    0x2ea9f80: <multiple use>
    0x2ea9f80: <multiple use>
  0x2eaa480: i64,ch,glue = ADJCALLSTACKUP64 0x2e84940, 0x2e84940, 0x2ea9f80, 0x2ea9f80:1 [ORD=60]

  0x2e83e40: i32 = TargetConstant<4>

      0x2eaa480: <multiple use>
      0x2e83c40: i32 = Register %EAX

      0x2eaa480: <multiple use>
    0x2eaa080: i32,ch,glue = CopyFromReg 0x2eaa480:1, 0x2e83c40, 0x2eaa480:2 [ORD=60]

  0x2e7f4b0: ch = RET 0x2eaa080:1 [ORD=61]


********** List Scheduling BB#0 'entry' **********
SU(0): 0x2e7f4b0: ch = RET 0x2eaa080:1 [ORD=61] [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 0
  Predecessors:
   ch  SU(1): Latency=1

SU(1): 0x2eaa080: i32,ch,glue = CopyFromReg 0x2eaa480:1, 0x2e83c40, 0x2eaa480:2 [ORD=60] [ID=1]

    0x2e7f5b0: ch,glue = CopyToReg 0x2ea9680:1, 0x2e84540, 0x2e84340 [ORD=60] [ID=1]

    0x2e7fdb0: ch,glue = CopyToReg 0x2e7f5b0, 0x2ea9b80, 0x2e7feb0, 0x2e7f5b0:1 [ORD=60] [ID=1]

    0x2e84140: ch,glue = CopyToReg 0x2e7fdb0, 0x2ea9e80, 0x2e84240, 0x2e7fdb0:1 [ORD=60] [ID=1]

    0x2ea9f80: ch,glue = CALL64r 0x2e801b0, 0x2e84540, 0x2ea9b80, 0x2ea9e80, 0x2ea9a80, 0x2e84140, 0x2e84140:1 [ORD=60] [ID=1]

    0x2eaa480: i64,ch,glue = ADJCALLSTACKUP64 0x2e84940, 0x2e84940, 0x2ea9f80, 0x2ea9f80:1 [ORD=60] [ID=1]

  # preds left       : 5
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 1
  Predecessors:
   val SU(16): Latency=1
   val SU(2): Latency=1
   val SU(4): Latency=1
   ch  SU(6): Latency=1
   val SU(5): Latency=1
  Successors:
   ch  SU(0): Latency=1

SU(2): 0x2e84240: i8 = EXTRACT_SUBREG 0x2e83b40, 0x2e7fbb0 [ID=2]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
   val SU(3): Latency=1
  Successors:
   val SU(1): Latency=1

SU(3): 0x2e83b40: i32,i32 = MOV32r0 [ID=3]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
   val SU(2): Latency=1

SU(4): 0x2e7feb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=52] [ID=4]

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
   val SU(1): Latency=1
   val SU(7): Latency=1

SU(5): 0x2e84340: i64 = MOV64ri 0x2e7f8b0 [ORD=60] [ID=5]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
   val SU(1): Latency=1

SU(6): 0x2ea9680: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84940, 0x2ea9780 [ORD=60] [ID=6]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 2
  Predecessors:
   ch  SU(7): Latency=1
  Successors:
   ch  SU(1): Latency=1

SU(7): 0x2ea9780: ch = MOV32mr 0x2e83d40, 0x2ea9880, 0x2e84740, 0x2ea9c80, 0x2e7f7b0, 0x2e7feb0, 0x2e800b0:1<Mem:ST4[%i.addr]> [ORD=58] [ID=7]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 3
  Predecessors:
   val SU(4): Latency=1
   ch  SU(8): Latency=1
  Successors:
   ch  SU(6): Latency=1

SU(8): 0x2e800b0: i64,ch,glue = CopyFromReg 0x2e83f40:1, 0x2e84640, 0x2e83f40:2 [ORD=56] [ID=8]

    0x2eaa8d0: ch,glue = CopyToReg 0x2e7f3b0:1, 0x2e84540, 0x2e7f9b0 [ORD=56] [ID=8]

    0x2e84840: ch,glue = CopyToReg 0x2eaa8d0, 0x2e84440, 0x2e7ffb0, 0x2eaa8d0:1 [ORD=56] [ID=8]

    0x2ea9980: ch,glue = CALL64r 0x2e7fcb0, 0x2e84540, 0x2e84440, 0x2ea9a80, 0x2e84840, 0x2e84840:1 [ORD=56] [ID=8]

    0x2e83f40: i64,ch,glue = ADJCALLSTACKUP64 0x2e84940, 0x2e84940, 0x2ea9980, 0x2ea9980:1 [ORD=56] [ID=8]

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 4
  Predecessors:
   val SU(14): Latency=1
   val SU(9): Latency=1
   ch  SU(13): Latency=1
   val SU(11): Latency=1
  Successors:
   ch  SU(7): Latency=1

SU(9): 0x2e7ffb0: i64 = SUBREG_TO_REG 0x2e84940, 0x2e84040, 0x2e83e40 [ID=9]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
   val SU(10): Latency=1
  Successors:
   val SU(8): Latency=1

SU(10): 0x2e84040: i32 = MOV32ri64 0x2ea9d80 [ID=10]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
   val SU(9): Latency=1

SU(11): 0x2e7f9b0: i64 = SUBREG_TO_REG 0x2e84940, 0x2eaa280, 0x2e83e40 [ID=11]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
   val SU(12): Latency=1
  Successors:
   val SU(8): Latency=1

SU(12): 0x2eaa280: i32 = MOV32ri64 0x2eaa180 [ID=12]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
   val SU(11): Latency=1

SU(13): 0x2e7f3b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84940, 0x2e5c478 [ORD=56] [ID=13]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
   ch  SU(8): Latency=1

SU(14): 0x2e7fcb0: i64 = SUBREG_TO_REG 0x2e84940, 0x2eaa9d0, 0x2e83e40 [ID=14]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
   val SU(15): Latency=1
  Successors:
   val SU(8): Latency=1

SU(15): 0x2eaa9d0: i32 = MOV32ri64 0x2eaa380 [ID=15]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
   val SU(14): Latency=1

SU(16): 0x2e801b0: i64 = MOV64ri 0x2e7f6b0 [ORD=60] [ID=16]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
   val SU(1): Latency=1


Examining Available:
Height 0: SU(0): 0x2e7f4b0: ch = RET 0x2eaa080:1 [ORD=61] [ID=0]


*** Scheduling [0]: SU(0): 0x2e7f4b0: ch = RET 0x2eaa080:1 [ORD=61] [ID=0]


Examining Available:
Height 1: SU(1): 0x2eaa080: i32,ch,glue = CopyFromReg 0x2eaa480:1, 0x2e83c40, 0x2eaa480:2 [ORD=60] [ID=1]

    0x2e7f5b0: ch,glue = CopyToReg 0x2ea9680:1, 0x2e84540, 0x2e84340 [ORD=60] [ID=1]

    0x2e7fdb0: ch,glue = CopyToReg 0x2e7f5b0, 0x2ea9b80, 0x2e7feb0, 0x2e7f5b0:1 [ORD=60] [ID=1]

    0x2e84140: ch,glue = CopyToReg 0x2e7fdb0, 0x2ea9e80, 0x2e84240, 0x2e7fdb0:1 [ORD=60] [ID=1]

    0x2ea9f80: ch,glue = CALL64r 0x2e801b0, 0x2e84540, 0x2ea9b80, 0x2ea9e80, 0x2ea9a80, 0x2e84140, 0x2e84140:1 [ORD=60] [ID=1]

    0x2eaa480: i64,ch,glue = ADJCALLSTACKUP64 0x2e84940, 0x2e84940, 0x2ea9f80, 0x2ea9f80:1 [ORD=60] [ID=1]


*** Scheduling [1]: SU(1): 0x2eaa080: i32,ch,glue = CopyFromReg 0x2eaa480:1, 0x2e83c40, 0x2eaa480:2 [ORD=60] [ID=1]

    0x2e7f5b0: ch,glue = CopyToReg 0x2ea9680:1, 0x2e84540, 0x2e84340 [ORD=60] [ID=1]

    0x2e7fdb0: ch,glue = CopyToReg 0x2e7f5b0, 0x2ea9b80, 0x2e7feb0, 0x2e7f5b0:1 [ORD=60] [ID=1]

    0x2e84140: ch,glue = CopyToReg 0x2e7fdb0, 0x2ea9e80, 0x2e84240, 0x2e7fdb0:1 [ORD=60] [ID=1]

    0x2ea9f80: ch,glue = CALL64r 0x2e801b0, 0x2e84540, 0x2ea9b80, 0x2ea9e80, 0x2ea9a80, 0x2e84140, 0x2e84140:1 [ORD=60] [ID=1]

    0x2eaa480: i64,ch,glue = ADJCALLSTACKUP64 0x2e84940, 0x2e84940, 0x2ea9f80, 0x2ea9f80:1 [ORD=60] [ID=1]


Examining Available:
Height 2: SU(2): 0x2e84240: i8 = EXTRACT_SUBREG 0x2e83b40, 0x2e7fbb0 [ID=2]

Height 2: SU(16): 0x2e801b0: i64 = MOV64ri 0x2e7f6b0 [ORD=60] [ID=16]

Height 2: SU(5): 0x2e84340: i64 = MOV64ri 0x2e7f8b0 [ORD=60] [ID=5]

Height 2: SU(6): 0x2ea9680: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84940, 0x2ea9780 [ORD=60] [ID=6]


*** Scheduling [2]: SU(2): 0x2e84240: i8 = EXTRACT_SUBREG 0x2e83b40, 0x2e7fbb0 [ID=2]


Examining Available:
Height 3: SU(3): 0x2e83b40: i32,i32 = MOV32r0 [ID=3]

Height 2: SU(16): 0x2e801b0: i64 = MOV64ri 0x2e7f6b0 [ORD=60] [ID=16]

Height 2: SU(5): 0x2e84340: i64 = MOV64ri 0x2e7f8b0 [ORD=60] [ID=5]

Height 2: SU(6): 0x2ea9680: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84940, 0x2ea9780 [ORD=60] [ID=6]


*** Scheduling [3]: SU(3): 0x2e83b40: i32,i32 = MOV32r0 [ID=3]


Examining Available:
Height 2: SU(16): 0x2e801b0: i64 = MOV64ri 0x2e7f6b0 [ORD=60] [ID=16]

Height 2: SU(5): 0x2e84340: i64 = MOV64ri 0x2e7f8b0 [ORD=60] [ID=5]

Height 2: SU(6): 0x2ea9680: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84940, 0x2ea9780 [ORD=60] [ID=6]


*** Scheduling [4]: SU(16): 0x2e801b0: i64 = MOV64ri 0x2e7f6b0 [ORD=60] [ID=16]


Examining Available:
Height 2: SU(5): 0x2e84340: i64 = MOV64ri 0x2e7f8b0 [ORD=60] [ID=5]

Height 2: SU(6): 0x2ea9680: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84940, 0x2ea9780 [ORD=60] [ID=6]


*** Scheduling [5]: SU(5): 0x2e84340: i64 = MOV64ri 0x2e7f8b0 [ORD=60] [ID=5]


Examining Available:
Height 2: SU(6): 0x2ea9680: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84940, 0x2ea9780 [ORD=60] [ID=6]


*** Scheduling [6]: SU(6): 0x2ea9680: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84940, 0x2ea9780 [ORD=60] [ID=6]


Examining Available:
Height 7: SU(7): 0x2ea9780: ch = MOV32mr 0x2e83d40, 0x2ea9880, 0x2e84740, 0x2ea9c80, 0x2e7f7b0, 0x2e7feb0, 0x2e800b0:1<Mem:ST4[%i.addr]> [ORD=58] [ID=7]


*** Scheduling [7]: SU(7): 0x2ea9780: ch = MOV32mr 0x2e83d40, 0x2ea9880, 0x2e84740, 0x2ea9c80, 0x2e7f7b0, 0x2e7feb0, 0x2e800b0:1<Mem:ST4[%i.addr]> [ORD=58] [ID=7]


Examining Available:
Height 8: SU(8): 0x2e800b0: i64,ch,glue = CopyFromReg 0x2e83f40:1, 0x2e84640, 0x2e83f40:2 [ORD=56] [ID=8]

    0x2eaa8d0: ch,glue = CopyToReg 0x2e7f3b0:1, 0x2e84540, 0x2e7f9b0 [ORD=56] [ID=8]

    0x2e84840: ch,glue = CopyToReg 0x2eaa8d0, 0x2e84440, 0x2e7ffb0, 0x2eaa8d0:1 [ORD=56] [ID=8]

    0x2ea9980: ch,glue = CALL64r 0x2e7fcb0, 0x2e84540, 0x2e84440, 0x2ea9a80, 0x2e84840, 0x2e84840:1 [ORD=56] [ID=8]

    0x2e83f40: i64,ch,glue = ADJCALLSTACKUP64 0x2e84940, 0x2e84940, 0x2ea9980, 0x2ea9980:1 [ORD=56] [ID=8]

Height 8: SU(4): 0x2e7feb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=52] [ID=4]


*** Scheduling [8]: SU(8): 0x2e800b0: i64,ch,glue = CopyFromReg 0x2e83f40:1, 0x2e84640, 0x2e83f40:2 [ORD=56] [ID=8]

    0x2eaa8d0: ch,glue = CopyToReg 0x2e7f3b0:1, 0x2e84540, 0x2e7f9b0 [ORD=56] [ID=8]

    0x2e84840: ch,glue = CopyToReg 0x2eaa8d0, 0x2e84440, 0x2e7ffb0, 0x2eaa8d0:1 [ORD=56] [ID=8]

    0x2ea9980: ch,glue = CALL64r 0x2e7fcb0, 0x2e84540, 0x2e84440, 0x2ea9a80, 0x2e84840, 0x2e84840:1 [ORD=56] [ID=8]

    0x2e83f40: i64,ch,glue = ADJCALLSTACKUP64 0x2e84940, 0x2e84940, 0x2ea9980, 0x2ea9980:1 [ORD=56] [ID=8]


Examining Available:
Height 9: SU(14): 0x2e7fcb0: i64 = SUBREG_TO_REG 0x2e84940, 0x2eaa9d0, 0x2e83e40 [ID=14]

Height 9: SU(9): 0x2e7ffb0: i64 = SUBREG_TO_REG 0x2e84940, 0x2e84040, 0x2e83e40 [ID=9]

Height 9: SU(11): 0x2e7f9b0: i64 = SUBREG_TO_REG 0x2e84940, 0x2eaa280, 0x2e83e40 [ID=11]

Height 9: SU(13): 0x2e7f3b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84940, 0x2e5c478 [ORD=56] [ID=13]

Height 8: SU(4): 0x2e7feb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=52] [ID=4]


*** Scheduling [9]: SU(14): 0x2e7fcb0: i64 = SUBREG_TO_REG 0x2e84940, 0x2eaa9d0, 0x2e83e40 [ID=14]


Examining Available:
Height 10: SU(15): 0x2eaa9d0: i32 = MOV32ri64 0x2eaa380 [ID=15]

Height 9: SU(9): 0x2e7ffb0: i64 = SUBREG_TO_REG 0x2e84940, 0x2e84040, 0x2e83e40 [ID=9]

Height 9: SU(11): 0x2e7f9b0: i64 = SUBREG_TO_REG 0x2e84940, 0x2eaa280, 0x2e83e40 [ID=11]

Height 9: SU(13): 0x2e7f3b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84940, 0x2e5c478 [ORD=56] [ID=13]

Height 8: SU(4): 0x2e7feb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=52] [ID=4]


*** Scheduling [10]: SU(15): 0x2eaa9d0: i32 = MOV32ri64 0x2eaa380 [ID=15]


Examining Available:
Height 9: SU(9): 0x2e7ffb0: i64 = SUBREG_TO_REG 0x2e84940, 0x2e84040, 0x2e83e40 [ID=9]

Height 9: SU(11): 0x2e7f9b0: i64 = SUBREG_TO_REG 0x2e84940, 0x2eaa280, 0x2e83e40 [ID=11]

Height 9: SU(13): 0x2e7f3b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84940, 0x2e5c478 [ORD=56] [ID=13]

Height 8: SU(4): 0x2e7feb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=52] [ID=4]


*** Scheduling [11]: SU(9): 0x2e7ffb0: i64 = SUBREG_TO_REG 0x2e84940, 0x2e84040, 0x2e83e40 [ID=9]


Examining Available:
Height 12: SU(10): 0x2e84040: i32 = MOV32ri64 0x2ea9d80 [ID=10]

Height 9: SU(11): 0x2e7f9b0: i64 = SUBREG_TO_REG 0x2e84940, 0x2eaa280, 0x2e83e40 [ID=11]

Height 9: SU(13): 0x2e7f3b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84940, 0x2e5c478 [ORD=56] [ID=13]

Height 8: SU(4): 0x2e7feb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=52] [ID=4]


*** Scheduling [12]: SU(10): 0x2e84040: i32 = MOV32ri64 0x2ea9d80 [ID=10]


Examining Available:
Height 9: SU(11): 0x2e7f9b0: i64 = SUBREG_TO_REG 0x2e84940, 0x2eaa280, 0x2e83e40 [ID=11]

Height 9: SU(13): 0x2e7f3b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84940, 0x2e5c478 [ORD=56] [ID=13]

Height 8: SU(4): 0x2e7feb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=52] [ID=4]


*** Scheduling [13]: SU(11): 0x2e7f9b0: i64 = SUBREG_TO_REG 0x2e84940, 0x2eaa280, 0x2e83e40 [ID=11]


Examining Available:
Height 14: SU(12): 0x2eaa280: i32 = MOV32ri64 0x2eaa180 [ID=12]

Height 9: SU(13): 0x2e7f3b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84940, 0x2e5c478 [ORD=56] [ID=13]

Height 8: SU(4): 0x2e7feb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=52] [ID=4]


*** Scheduling [14]: SU(12): 0x2eaa280: i32 = MOV32ri64 0x2eaa180 [ID=12]


Examining Available:
Height 9: SU(13): 0x2e7f3b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84940, 0x2e5c478 [ORD=56] [ID=13]

Height 8: SU(4): 0x2e7feb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=52] [ID=4]


*** Scheduling [15]: SU(13): 0x2e7f3b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84940, 0x2e5c478 [ORD=56] [ID=13]


Examining Available:
Height 8: SU(4): 0x2e7feb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=52] [ID=4]


*** Scheduling [16]: SU(4): 0x2e7feb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=52] [ID=4]

*** Final schedule ***
SU(4): 0x2e7feb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=52] [ID=4]

SU(13): 0x2e7f3b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84940, 0x2e5c478 [ORD=56] [ID=13]

SU(12): 0x2eaa280: i32 = MOV32ri64 0x2eaa180 [ID=12]

SU(11): 0x2e7f9b0: i64 = SUBREG_TO_REG 0x2e84940, 0x2eaa280, 0x2e83e40 [ID=11]

SU(10): 0x2e84040: i32 = MOV32ri64 0x2ea9d80 [ID=10]

SU(9): 0x2e7ffb0: i64 = SUBREG_TO_REG 0x2e84940, 0x2e84040, 0x2e83e40 [ID=9]

SU(15): 0x2eaa9d0: i32 = MOV32ri64 0x2eaa380 [ID=15]

SU(14): 0x2e7fcb0: i64 = SUBREG_TO_REG 0x2e84940, 0x2eaa9d0, 0x2e83e40 [ID=14]

SU(8): 0x2e800b0: i64,ch,glue = CopyFromReg 0x2e83f40:1, 0x2e84640, 0x2e83f40:2 [ORD=56] [ID=8]

    0x2eaa8d0: ch,glue = CopyToReg 0x2e7f3b0:1, 0x2e84540, 0x2e7f9b0 [ORD=56] [ID=8]

    0x2e84840: ch,glue = CopyToReg 0x2eaa8d0, 0x2e84440, 0x2e7ffb0, 0x2eaa8d0:1 [ORD=56] [ID=8]

    0x2ea9980: ch,glue = CALL64r 0x2e7fcb0, 0x2e84540, 0x2e84440, 0x2ea9a80, 0x2e84840, 0x2e84840:1 [ORD=56] [ID=8]

    0x2e83f40: i64,ch,glue = ADJCALLSTACKUP64 0x2e84940, 0x2e84940, 0x2ea9980, 0x2ea9980:1 [ORD=56] [ID=8]

SU(7): 0x2ea9780: ch = MOV32mr 0x2e83d40, 0x2ea9880, 0x2e84740, 0x2ea9c80, 0x2e7f7b0, 0x2e7feb0, 0x2e800b0:1<Mem:ST4[%i.addr]> [ORD=58] [ID=7]

SU(6): 0x2ea9680: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84940, 0x2ea9780 [ORD=60] [ID=6]

SU(5): 0x2e84340: i64 = MOV64ri 0x2e7f8b0 [ORD=60] [ID=5]

SU(16): 0x2e801b0: i64 = MOV64ri 0x2e7f6b0 [ORD=60] [ID=16]

SU(3): 0x2e83b40: i32,i32 = MOV32r0 [ID=3]

SU(2): 0x2e84240: i8 = EXTRACT_SUBREG 0x2e83b40, 0x2e7fbb0 [ID=2]

SU(1): 0x2eaa080: i32,ch,glue = CopyFromReg 0x2eaa480:1, 0x2e83c40, 0x2eaa480:2 [ORD=60] [ID=1]

    0x2e7f5b0: ch,glue = CopyToReg 0x2ea9680:1, 0x2e84540, 0x2e84340 [ORD=60] [ID=1]

    0x2e7fdb0: ch,glue = CopyToReg 0x2e7f5b0, 0x2ea9b80, 0x2e7feb0, 0x2e7f5b0:1 [ORD=60] [ID=1]

    0x2e84140: ch,glue = CopyToReg 0x2e7fdb0, 0x2ea9e80, 0x2e84240, 0x2e7fdb0:1 [ORD=60] [ID=1]

    0x2ea9f80: ch,glue = CALL64r 0x2e801b0, 0x2e84540, 0x2ea9b80, 0x2ea9e80, 0x2ea9a80, 0x2e84140, 0x2e84140:1 [ORD=60] [ID=1]

    0x2eaa480: i64,ch,glue = ADJCALLSTACKUP64 0x2e84940, 0x2e84940, 0x2ea9f80, 0x2ea9f80:1 [ORD=60] [ID=1]

SU(0): 0x2e7f4b0: ch = RET 0x2eaa080:1 [ORD=61] [ID=0]


Total amount of phi nodes to update: 0
# Machine code for function func: SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
48B		%vreg1<def> = MOV32ri64 48717472; GR32:%vreg1
64B		%vreg2<def> = SUBREG_TO_REG 0, %vreg1<kill>, 4; GR64:%vreg2 GR32:%vreg1
80B		%vreg3<def> = MOV32ri64 48397984; GR32:%vreg3
96B		%vreg4<def> = SUBREG_TO_REG 0, %vreg3<kill>, 4; GR64:%vreg4 GR32:%vreg3
112B		%vreg5<def> = MOV32ri64 8971440; GR32:%vreg5
128B		%vreg6<def> = SUBREG_TO_REG 0, %vreg5<kill>, 4; GR64:%vreg6 GR32:%vreg5
144B		%RDI<def> = COPY %vreg2; GR64:%vreg2
160B		%RSI<def> = COPY %vreg4; GR64:%vreg4
176B		CALL64r %vreg6<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def>; GR64:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		%vreg7<def> = COPY %RAX; GR64:%vreg7
224B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
240B		ADJCALLSTACKDOWN64 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg8<def> = MOV64ri <ga:@.str>; GR64:%vreg8
272B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
288B		%vreg10<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
304B		%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
320B		%RDI<def> = COPY %vreg8; GR64:%vreg8
336B		%ESI<def> = COPY %vreg0; GR32:%vreg0
352B		%AL<def> = COPY %vreg11; GR8:%vreg11
368B		CALL64r %vreg9<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def>; GR64:%vreg9
384B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
400B		%vreg12<def> = COPY %EAX; GR32:%vreg12
416B		RET

# End machine code for function func.

********** Stack Coloring **********
********** Function: func
Found 0 markers and 1 slots
Slot structure:
Slot #0 - 4 bytes.
Total Stack size: 4 bytes

Will not try to merge slots.
Removed 0 markers.
DeadMachineInstructionElim: DELETING: %vreg12<def> = COPY %EAX; GR32:%vreg12
DeadMachineInstructionElim: DELETING: %vreg7<def> = COPY %RAX; GR64:%vreg7
******** Pre-regalloc Machine LICM: func ********
Entering: entry
Exiting: entry
******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: func
********** PROCESS IMPLICIT DEFS **********
********** Function: func
********** REWRITING TWO-ADDR INSTRS **********
********** Function: func
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI<kill>; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
48B		%vreg1<def> = MOV32ri64 48717472; GR32:%vreg1
64B		%vreg2<def> = SUBREG_TO_REG 0, %vreg1<kill>, 4; GR64:%vreg2 GR32:%vreg1
80B		%vreg3<def> = MOV32ri64 48397984; GR32:%vreg3
96B		%vreg4<def> = SUBREG_TO_REG 0, %vreg3<kill>, 4; GR64:%vreg4 GR32:%vreg3
112B		%vreg5<def> = MOV32ri64 8971440; GR32:%vreg5
128B		%vreg6<def> = SUBREG_TO_REG 0, %vreg5<kill>, 4; GR64:%vreg6 GR32:%vreg5
144B		%RDI<def> = COPY %vreg2<kill>; GR64:%vreg2
160B		%RSI<def> = COPY %vreg4<kill>; GR64:%vreg4
176B		CALL64r %vreg6<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use,kill>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
240B		%vreg8<def> = MOV64ri <ga:@.str>; GR64:%vreg8
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
272B		%vreg10<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
288B		%vreg11<def> = COPY %vreg10:sub_8bit<kill>; GR8:%vreg11 GR32:%vreg10
304B		%RDI<def> = COPY %vreg8<kill>; GR64:%vreg8
320B		%ESI<def> = COPY %vreg0<kill>; GR32:%vreg0
336B		%AL<def> = COPY %vreg11<kill>; GR8:%vreg11
352B		CALL64r %vreg9<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use,kill>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

Computing live-in reg-units in ABI blocks.
0B	BB#0 DIL#0
Created 1 new intervals.
********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
%vreg0 [16r,320r:0)  0@16r
%vreg1 [48r,64r:0)  0@48r
%vreg2 [64r,144r:0)  0@64r
%vreg3 [80r,96r:0)  0@80r
%vreg4 [96r,160r:0)  0@96r
%vreg5 [112r,128r:0)  0@112r
%vreg6 [128r,176r:0)  0@128r
%vreg8 [240r,304r:0)  0@240r
%vreg9 [256r,352r:0)  0@256r
%vreg10 [272r,288r:0)  0@272r
%vreg11 [288r,336r:0)  0@288r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
48B		%vreg1<def> = MOV32ri64 48717472; GR32:%vreg1
64B		%vreg2<def> = SUBREG_TO_REG 0, %vreg1, 4; GR64:%vreg2 GR32:%vreg1
80B		%vreg3<def> = MOV32ri64 48397984; GR32:%vreg3
96B		%vreg4<def> = SUBREG_TO_REG 0, %vreg3, 4; GR64:%vreg4 GR32:%vreg3
112B		%vreg5<def> = MOV32ri64 8971440; GR32:%vreg5
128B		%vreg6<def> = SUBREG_TO_REG 0, %vreg5, 4; GR64:%vreg6 GR32:%vreg5
144B		%RDI<def> = COPY %vreg2; GR64:%vreg2
160B		%RSI<def> = COPY %vreg4; GR64:%vreg4
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
240B		%vreg8<def> = MOV64ri <ga:@.str>; GR64:%vreg8
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
272B		%vreg10<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
288B		%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
304B		%RDI<def> = COPY %vreg8; GR64:%vreg8
320B		%ESI<def> = COPY %vreg0; GR32:%vreg0
336B		%AL<def> = COPY %vreg11; GR8:%vreg11
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

********** SIMPLE REGISTER COALESCING **********
********** Function: func
********** JOINING INTERVALS ***********
entry:
16B	%vreg0<def> = COPY %EDI; GR32:%vreg0
	Considering merging %vreg0 with %EDI
	Can only merge into reserved registers.
64B	%vreg2<def> = SUBREG_TO_REG 0, %vreg1, 4; GR64:%vreg2 GR32:%vreg1
	Considering merging to GR64_with_sub_8bit with %vreg1 in %vreg2:sub_32bit
		RHS = %vreg1 [48r,64r:0)  0@48r
		LHS = %vreg2 [64r,144r:0)  0@64r
		merge %vreg2:0@64r into %vreg1:0@48r --> @48r
		erased:	64r	%vreg2<def> = SUBREG_TO_REG 0, %vreg1, 4; GR64:%vreg2 GR32:%vreg1
		updated: 48B	%vreg2:sub_32bit<def,read-undef> = MOV32ri64 48717472; GR64_with_sub_8bit:%vreg2
	Joined. Result = %vreg2 [48r,144r:0)  0@48r
96B	%vreg4<def> = SUBREG_TO_REG 0, %vreg3, 4; GR64:%vreg4 GR32:%vreg3
	Considering merging to GR64_with_sub_8bit with %vreg3 in %vreg4:sub_32bit
		RHS = %vreg3 [80r,96r:0)  0@80r
		LHS = %vreg4 [96r,160r:0)  0@96r
		merge %vreg4:0@96r into %vreg3:0@80r --> @80r
		erased:	96r	%vreg4<def> = SUBREG_TO_REG 0, %vreg3, 4; GR64:%vreg4 GR32:%vreg3
		updated: 80B	%vreg4:sub_32bit<def,read-undef> = MOV32ri64 48397984; GR64_with_sub_8bit:%vreg4
	Joined. Result = %vreg4 [80r,160r:0)  0@80r
128B	%vreg6<def> = SUBREG_TO_REG 0, %vreg5, 4; GR64:%vreg6 GR32:%vreg5
	Considering merging to GR64_with_sub_8bit with %vreg5 in %vreg6:sub_32bit
		RHS = %vreg5 [112r,128r:0)  0@112r
		LHS = %vreg6 [128r,176r:0)  0@128r
		merge %vreg6:0@128r into %vreg5:0@112r --> @112r
		erased:	128r	%vreg6<def> = SUBREG_TO_REG 0, %vreg5, 4; GR64:%vreg6 GR32:%vreg5
		updated: 112B	%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
	Joined. Result = %vreg6 [112r,176r:0)  0@112r
144B	%RDI<def> = COPY %vreg2; GR64_with_sub_8bit:%vreg2
	Considering merging %vreg2 with %RDI
	Can only merge into reserved registers.
Remat: %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
Shrink: %vreg2 [48r,144r:0)  0@48r
All defs dead: 48r	%vreg2:sub_32bit<def,read-undef,dead> = MOV32ri64 48717472; GR64_with_sub_8bit:%vreg2
Shrunk: %vreg2 [48r,48d:0)  0@48r
Deleting dead def 48r	%vreg2:sub_32bit<def,read-undef,dead> = MOV32ri64 48717472; GR64_with_sub_8bit:%vreg2
160B	%RSI<def> = COPY %vreg4; GR64_with_sub_8bit:%vreg4
	Considering merging %vreg4 with %RSI
	Can only merge into reserved registers.
Remat: %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
Shrink: %vreg4 [80r,160r:0)  0@80r
All defs dead: 80r	%vreg4:sub_32bit<def,read-undef,dead> = MOV32ri64 48397984; GR64_with_sub_8bit:%vreg4
Shrunk: %vreg4 [80r,80d:0)  0@80r
Deleting dead def 80r	%vreg4:sub_32bit<def,read-undef,dead> = MOV32ri64 48397984; GR64_with_sub_8bit:%vreg4
304B	%RDI<def> = COPY %vreg8; GR64:%vreg8
	Considering merging %vreg8 with %RDI
	Can only merge into reserved registers.
Remat: %RDI<def> = MOV64ri <ga:@.str>
Shrink: %vreg8 [240r,304r:0)  0@240r
All defs dead: 240r	%vreg8<def,dead> = MOV64ri <ga:@.str>; GR64:%vreg8
Shrunk: %vreg8 [240r,240d:0)  0@240r
Deleting dead def 240r	%vreg8<def,dead> = MOV64ri <ga:@.str>; GR64:%vreg8
320B	%ESI<def> = COPY %vreg0; GR32:%vreg0
	Considering merging %vreg0 with %ESI
	Can only merge into reserved registers.
336B	%AL<def> = COPY %vreg11; GR8:%vreg11
	Considering merging %vreg11 with %AL
	Can only merge into reserved registers.
288B	%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
	Considering merging to GR32 with %vreg11 in %vreg10:sub_8bit
		RHS = %vreg11 [288r,336r:0)  0@288r
		LHS = %vreg10 [272r,288r:0)  0@272r
		merge %vreg11:0@288r into %vreg10:0@272r --> @272r
		erased:	288r	%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
		updated: 336B	%AL<def> = COPY %vreg10:sub_8bit; GR32:%vreg10
	Joined. Result = %vreg10 [272r,336r:0)  0@272r
320B	%ESI<def> = COPY %vreg0; GR32:%vreg0
	Considering merging %vreg0 with %ESI
	Can only merge into reserved registers.
336B	%AL<def> = COPY %vreg10:sub_8bit; GR32:%vreg10
	Considering merging %vreg10 with %EAX
	Can only merge into reserved registers.
Remat: %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
Shrink: %vreg10 [272r,336r:0)  0@272r
All defs dead: 272r	%vreg10<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
Shrunk: %vreg10 [272r,272d:0)  0@272r
Deleting dead def 272r	%vreg10<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
320B	%ESI<def> = COPY %vreg0; GR32:%vreg0
	Considering merging %vreg0 with %ESI
	Can only merge into reserved registers.
Trying to inflate 0 regs.
********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
%vreg0 [16r,320r:0)  0@16r
%vreg6 [112r,176r:0)  0@112r
%vreg9 [256r,352r:0)  0@256r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
320B		%ESI<def> = COPY %vreg0; GR32:%vreg0
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

Before MISsched:
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

BB#0: derived from LLVM BB %entry
    Live Ins: %EDI
	%vreg0<def> = COPY %EDI; GR32:%vreg0
	ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
	%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
	%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
	CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
	ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
	ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
	%RDI<def> = MOV64ri <ga:@.str>
	%ESI<def> = COPY %vreg0; GR32:%vreg0
	%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
	CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
	ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	RET

# End machine code for function func.

********** MI Scheduling **********
func:BB#0 entry
  From: %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
    To: CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
 RegionInstrs: 4 Remaining: 9
Disabled scoreboard hazard recognizer
Disabled scoreboard hazard recognizer
SU(0):   %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   val SU(4294967295): Latency=1 Reg=%vreg9

SU(1):   %RDI<def> = MOV64ri <ga:@.str>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

SU(2):   %ESI<def> = COPY %vreg0; GR32:%vreg0
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
   ch  SU(4294967295) *: Latency=0

SU(3):   %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

Critical Path: 1
BotQ.A: 0 3 2 1 
  SU(0) ORDER                              
  SU(3) ORDER                              
  SU(2) PREG-COPY                         
Pick Bot PREG-COPY
Scheduling SU(2) %ESI<def> = COPY %vreg0; GR32:%vreg0
handleMove 320B -> 344B: %ESI<def> = COPY %vreg0; GR32:%vreg0
     SIL:	[160r,176r:0)[344r,352r:1)  0@160r 1@344r
        -->	[160r,176r:0)[344r,352r:1)  0@160r 1@344r
     %vreg0:	[16r,320r:0)  0@16r
        -->	[16r,344r:0)  0@16r
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
BotQ.A: 0 3 1 
  SU(0) ORDER                              
  SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
  Ready @1c
  BotQ.A BotLatency SU(3) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
BotQ.A: 0 1 
  SU(0) ORDER                              
  SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %RDI<def> = MOV64ri <ga:@.str>
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
Scheduling SU(0) %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
*** Final schedule for BB#0 ***
SU(0):   %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
SU(1):   %RDI<def> = MOV64ri <ga:@.str>
SU(3):   %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
SU(2):   %ESI<def> = COPY %vreg0; GR32:%vreg0

********** MI Scheduling **********
func:BB#0 entry
  From: %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
    To: CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
 RegionInstrs: 3 Remaining: 2
SU(0):   %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   val SU(4294967295): Latency=1 Reg=%vreg6

SU(1):   %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

SU(2):   %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

Critical Path: 1
BotQ.A: 0 2 1 
  SU(0) ORDER                              
  SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
  Ready @1c
  SBPort015 +1x4u
  *** Critical resource SBPort015: 0c
  SBPortAny +1x2u
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
BotQ.A: 0 1 
  SU(0) ORDER                              
  SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
Scheduling SU(0) %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 3
  Executed: 1c
  Critical: 1c, 3 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
*** Final schedule for BB#0 ***
SU(0):   %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
SU(1):   %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
SU(2):   %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>

********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
SIL [160r,176r:0)[344r,352r:1)  0@160r 1@344r
%vreg0 [16r,344r:0)  0@16r
%vreg6 [112r,176r:0)  0@112r
%vreg9 [256r,352r:0)  0@256r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
344B		%ESI<def> = COPY %vreg0; GR32:%vreg0
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

RPO[BB#0 derived from LLVM BB entry] = 1
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#0 derived from LLVM BB entry)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0.0
Frequency(BB#0 derived from LLVM BB entry) = 1.0
LoopExitProb[BB#0 derived from LLVM BB entry] = 16383 / 16384 = 99.9939% from 1 - 0.0 / 1.0.
********** COMPUTING LIVE DEBUG VARIABLES: func **********
********** DEBUG VARIABLES **********
********** GREEDY REGISTER ALLOCATION **********
********** Function: func
********** Compute Spill Weights **********
********** Function: func
********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
SIL [160r,176r:0)[344r,352r:1)  0@160r 1@344r
%vreg0 [16r,344r:0)  0@16r
%vreg6 [112r,176r:0)  0@112r
%vreg9 [256r,352r:0)  0@256r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
344B		%ESI<def> = COPY %vreg0; GR32:%vreg0
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.


selectOrSplit GR32:%vreg0 [16r,344r:0)  0@16r
hints: %EDI
missed hint %EDI
assigning %vreg0 to %EBX: BH BL

selectOrSplit GR64_with_sub_8bit:%vreg6 [112r,176r:0)  0@112r
assigning %vreg6 to %RAX: AH AL

selectOrSplit GR64:%vreg9 [256r,352r:0)  0@256r
assigning %vreg9 to %RCX: CH CL
********** REWRITE VIRTUAL REGISTERS **********
********** Function: func
********** REGISTER MAP **********
[%vreg0 -> %EBX] GR32
[%vreg6 -> %RAX] GR64_with_sub_8bit
[%vreg9 -> %RCX] GR64

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
344B		%ESI<def> = COPY %vreg0<kill>; GR32:%vreg0
352B		CALL64r %vreg9<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET
> %EBX<def> = COPY %EDI
> ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> %EAX<def> = MOV32ri64 8971440, %RAX<imp-def>
> %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
> %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
> CALL64r %RAX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>
> ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %EBX; mem:ST4[%i.addr]
> ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> %RCX<def> = MOV64ri <ga:@printf>
> %RDI<def> = MOV64ri <ga:@.str>
> %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
> %ESI<def> = COPY %EBX<kill>
> CALL64r %RCX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def,dead>
> ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> RET
********** EMITTING LIVE DEBUG VARIABLES **********
********** Stack Slot Coloring **********
********** Function: func
******** Post-regalloc Machine LICM: func ********

Setting up live-ins for BB#0 derived from entry.
Block has no FP live-ins.

FPInst:	RET
Stack contents:
Inserted instructions:
	RET
Stack contents:
alloc FI(0) at SP[-28]
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: func
real copy:   %EBX<def> = COPY %EDI
replaced by: %EBX<def> = MOV32rr %EDI
real copy:   %ESI<def> = COPY %EBX<kill>
replaced by: %ESI<def> = MOV32rr %EBX<kill>
RPO[BB#0 derived from LLVM BB entry] = 1
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#0 derived from LLVM BB entry)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0.0
Frequency(BB#0 derived from LLVM BB entry) = 1.0
LoopExitProb[BB#0 derived from LLVM BB entry] = 16383 / 16384 = 99.9939% from 1 - 0.0 / 1.0.
********** FIX EXECUTION DEPENDENCIES: VR128 **********
BB#0: entry
JITTing function 'func'
JIT: Starting CodeGen of Function func
JIT: Emitting BB0 at [0x7f7e4367b1a0]
PUSH64r %RBP<kill>, %RSP<imp-def>, %RSP<imp-use>; flags: FrameSetup
PROLOG_LABEL <MCSym=.Ltmp15>
%RBP<def> = MOV64rr %RSP; flags: FrameSetup
PROLOG_LABEL <MCSym=.Ltmp16>
PUSH64r %RBX<kill>, %RSP<imp-def>, %RSP<imp-use>; flags: FrameSetup
PUSH64r %RAX<undef>, %RSP<imp-def>, %RSP<imp-use>; flags: FrameSetup
PROLOG_LABEL <MCSym=.Ltmp17>
%EBX<def> = MOV32rr %EDI
%EAX<def> = MOV32ri64 8971440, %RAX<imp-def>
%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
CALL64r %RAX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>
MOV32mr %RBP, 1, %noreg, -12, %noreg, %EBX; mem:ST4[%i.addr]
%RCX<def> = MOV64ri <ga:@printf>
%RDI<def> = MOV64ri <ga:@.str>
%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
%ESI<def> = MOV32rr %EBX<kill>
CALL64r %RCX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def,dead>
%RSP<def,tied1> = ADD64ri8 %RSP<tied0>, 8, %EFLAGS<imp-def,dead>
%RBX<def> = POP64r %RSP<imp-def>, %RSP<imp-use>
%RBP<def> = POP64r %RSP<imp-def>, %RSP<imp-use>
RET
JIT: Finished CodeGen of [0x7f7e4367b1a0] Function: func: 61 bytes of text, 2 relocations
JIT: Binary code:
JIT: 0: 2291377285 2511378083 136228176184 941601910 
JIT: 16: 1601902231 2552226126 24493137208 24324018572 
JIT: 32: 05350132 1917200 6710217616 00127126 
JIT: 48: 22213719249 13172209255 93918196 195
Inside Func callback func
JIT: Map 'func' to [0x0]
CGP: Found      local addrmode: [Base:%i.addr]
CGP: Found      local addrmode: [Base:%i.addr]
Computing probabilities for entry



=== func
Initial selection DAG: BB#0 'func:entry'
SelectionDAG has 37 nodes:
  0x2e5c478: ch = EntryToken

  0x2e84040: i64 = TargetConstant<0>

  0x2e7fbb0: i64 = Register %RDI

      0x2e5c478: <multiple use>
      0x2e84040: <multiple use>
    0x2ea9d80: ch,glue = callseq_start 0x2e5c478, 0x2e84040 [ORD=65]

    0x2e7fbb0: <multiple use>
    0x2eaa180: i64 = Constant<48717472>

  0x2e83b40: ch,glue = CopyToReg 0x2ea9d80, 0x2e7fbb0, 0x2eaa180 [ORD=65]

  0x2e7f7b0: i64 = Register %RSI

    0x2e83b40: <multiple use>
    0x2e7f7b0: <multiple use>
    0x2e83e40: i64 = Constant<48397984>

    0x2e83b40: <multiple use>
  0x2ea9c80: ch,glue = CopyToReg 0x2e83b40, 0x2e7f7b0, 0x2e83e40, 0x2e83b40:1 [ORD=65]

  0x2ea9880: Untyped = RegisterMask

    0x2ea9c80: <multiple use>
    0x2eaa280: i64 = Constant<8971440>

    0x2e7fbb0: <multiple use>
    0x2e7f7b0: <multiple use>
    0x2ea9880: <multiple use>
    0x2ea9c80: <multiple use>
  0x2e83d40: ch,glue = X86ISD::CALL 0x2ea9c80, 0x2eaa280, 0x2e7fbb0, 0x2e7f7b0, 0x2ea9880, 0x2ea9c80:1 [ORD=65]

    0x2e83d40: <multiple use>
    0x2e84040: <multiple use>
    0x2e84040: <multiple use>
    0x2e83d40: <multiple use>
  0x2e84740: ch,glue = callseq_end 0x2e83d40, 0x2e84040, 0x2e84040, 0x2e83d40:1 [ORD=65]

  0x2eaa480: i64 = FrameIndex<0>

  0x2ea9f80: i64 = Constant<0>

  0x2e84140: i64 = undef

        0x2e84740: <multiple use>
        0x2e7f4b0: i64 = Register %RAX

        0x2e84740: <multiple use>
      0x2eaa080: i64,ch,glue = CopyFromReg 0x2e84740, 0x2e7f4b0, 0x2e84740:1 [ORD=65]

        0x2e5c478: <multiple use>
        0x2eaa9d0: i32 = Register %vreg0

      0x2eaa380: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=61]

      0x2eaa480: <multiple use>
      0x2e84140: <multiple use>
    0x2e7fdb0: ch = store 0x2eaa080:1, 0x2eaa380, 0x2eaa480, 0x2e84140<ST4[%i.addr]> [ORD=67]

    0x2eaa480: <multiple use>
    0x2e84140: <multiple use>
  0x2e7f5b0: i32,ch = load 0x2e7fdb0, 0x2eaa480, 0x2e84140<LD4[%i.addr]> [ORD=68]

      0x2e7f5b0: <multiple use>
      0x2e84040: <multiple use>
    0x2e800b0: ch,glue = callseq_start 0x2e7f5b0:1, 0x2e84040 [ORD=69]

    0x2e7fbb0: <multiple use>
    0x2ea9780: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=69]

  0x2ea9980: ch,glue = CopyToReg 0x2e800b0, 0x2e7fbb0, 0x2ea9780 [ORD=69]

  0x2e84840: i32 = Register %ESI

    0x2ea9980: <multiple use>
    0x2e84840: <multiple use>
    0x2e7f5b0: <multiple use>
    0x2ea9980: <multiple use>
  0x2eaa8d0: ch,glue = CopyToReg 0x2ea9980, 0x2e84840, 0x2e7f5b0, 0x2ea9980:1 [ORD=69]

  0x2e801b0: i8 = Register %AL

    0x2eaa8d0: <multiple use>
    0x2e801b0: <multiple use>
    0x2e83f40: i8 = Constant<0>

    0x2eaa8d0: <multiple use>
  0x2e84340: ch,glue = CopyToReg 0x2eaa8d0, 0x2e801b0, 0x2e83f40, 0x2eaa8d0:1 [ORD=69]

    0x2e84340: <multiple use>
    0x2ea9680: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=69]

    0x2e7fbb0: <multiple use>
    0x2e84840: <multiple use>
    0x2e801b0: <multiple use>
    0x2ea9880: <multiple use>
    0x2e84340: <multiple use>
  0x2e7f3b0: ch,glue = X86ISD::CALL 0x2e84340, 0x2ea9680, 0x2e7fbb0, 0x2e84840, 0x2e801b0, 0x2ea9880, 0x2e84340:1 [ORD=69]

    0x2e7f3b0: <multiple use>
    0x2e84040: <multiple use>
    0x2e84040: <multiple use>
    0x2e7f3b0: <multiple use>
  0x2e7feb0: ch,glue = callseq_end 0x2e7f3b0, 0x2e84040, 0x2e84040, 0x2e7f3b0:1 [ORD=69]

      0x2e7feb0: <multiple use>
      0x2e7f6b0: i32 = Register %EAX

      0x2e7feb0: <multiple use>
    0x2e7f8b0: i32,ch,glue = CopyFromReg 0x2e7feb0, 0x2e7f6b0, 0x2e7feb0:1 [ORD=69]

    0x2e83c40: i16 = TargetConstant<0>

  0x2ea9e80: ch = X86ISD::RET_FLAG 0x2e7f8b0:1, 0x2e83c40 [ORD=70]



Replacing.1 0x2e7f5b0: i32,ch = load 0x2e7fdb0, 0x2eaa480, 0x2e84140<LD4[%i.addr]> [ORD=68]

With: 0x2eaa380: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=61]
 and 1 other values
Optimized lowered selection DAG: BB#0 'func:entry'
SelectionDAG has 35 nodes:
  0x2e5c478: ch = EntryToken

    0x2e5c478: <multiple use>
    0x2eaa9d0: i32 = Register %vreg0

  0x2eaa380: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=61]

  0x2e84040: i64 = TargetConstant<0>

  0x2e7fbb0: i64 = Register %RDI

      0x2e5c478: <multiple use>
      0x2e84040: <multiple use>
    0x2ea9d80: ch,glue = callseq_start 0x2e5c478, 0x2e84040 [ORD=65]

    0x2e7fbb0: <multiple use>
    0x2eaa180: i64 = Constant<48717472>

  0x2e83b40: ch,glue = CopyToReg 0x2ea9d80, 0x2e7fbb0, 0x2eaa180 [ORD=65]

  0x2e7f7b0: i64 = Register %RSI

    0x2e83b40: <multiple use>
    0x2e7f7b0: <multiple use>
    0x2e83e40: i64 = Constant<48397984>

    0x2e83b40: <multiple use>
  0x2ea9c80: ch,glue = CopyToReg 0x2e83b40, 0x2e7f7b0, 0x2e83e40, 0x2e83b40:1 [ORD=65]

  0x2ea9880: Untyped = RegisterMask

    0x2ea9c80: <multiple use>
    0x2eaa280: i64 = Constant<8971440>

    0x2e7fbb0: <multiple use>
    0x2e7f7b0: <multiple use>
    0x2ea9880: <multiple use>
    0x2ea9c80: <multiple use>
  0x2e83d40: ch,glue = X86ISD::CALL 0x2ea9c80, 0x2eaa280, 0x2e7fbb0, 0x2e7f7b0, 0x2ea9880, 0x2ea9c80:1 [ORD=65]

    0x2e83d40: <multiple use>
    0x2e84040: <multiple use>
    0x2e84040: <multiple use>
    0x2e83d40: <multiple use>
  0x2e84740: ch,glue = callseq_end 0x2e83d40, 0x2e84040, 0x2e84040, 0x2e83d40:1 [ORD=65]

          0x2e84740: <multiple use>
          0x2e7f4b0: i64 = Register %RAX

          0x2e84740: <multiple use>
        0x2eaa080: i64,ch,glue = CopyFromReg 0x2e84740, 0x2e7f4b0, 0x2e84740:1 [ORD=65]

        0x2eaa380: <multiple use>
        0x2eaa480: i64 = FrameIndex<0>

        0x2e84140: i64 = undef

      0x2e7fdb0: ch = store 0x2eaa080:1, 0x2eaa380, 0x2eaa480, 0x2e84140<ST4[%i.addr]> [ORD=67]

      0x2e84040: <multiple use>
    0x2e800b0: ch,glue = callseq_start 0x2e7fdb0, 0x2e84040 [ORD=69]

    0x2e7fbb0: <multiple use>
    0x2ea9780: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=69]

  0x2ea9980: ch,glue = CopyToReg 0x2e800b0, 0x2e7fbb0, 0x2ea9780 [ORD=69]

  0x2e84840: i32 = Register %ESI

    0x2ea9980: <multiple use>
    0x2e84840: <multiple use>
    0x2eaa380: <multiple use>
    0x2ea9980: <multiple use>
  0x2eaa8d0: ch,glue = CopyToReg 0x2ea9980, 0x2e84840, 0x2eaa380, 0x2ea9980:1 [ORD=69]

  0x2e801b0: i8 = Register %AL

    0x2eaa8d0: <multiple use>
    0x2e801b0: <multiple use>
    0x2e83f40: i8 = Constant<0>

    0x2eaa8d0: <multiple use>
  0x2e84340: ch,glue = CopyToReg 0x2eaa8d0, 0x2e801b0, 0x2e83f40, 0x2eaa8d0:1 [ORD=69]

    0x2e84340: <multiple use>
    0x2ea9680: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=69]

    0x2e7fbb0: <multiple use>
    0x2e84840: <multiple use>
    0x2e801b0: <multiple use>
    0x2ea9880: <multiple use>
    0x2e84340: <multiple use>
  0x2e7f3b0: ch,glue = X86ISD::CALL 0x2e84340, 0x2ea9680, 0x2e7fbb0, 0x2e84840, 0x2e801b0, 0x2ea9880, 0x2e84340:1 [ORD=69]

    0x2e7f3b0: <multiple use>
    0x2e84040: <multiple use>
    0x2e84040: <multiple use>
    0x2e7f3b0: <multiple use>
  0x2e7feb0: ch,glue = callseq_end 0x2e7f3b0, 0x2e84040, 0x2e84040, 0x2e7f3b0:1 [ORD=69]

      0x2e7feb0: <multiple use>
      0x2e7f6b0: i32 = Register %EAX

      0x2e7feb0: <multiple use>
    0x2e7f8b0: i32,ch,glue = CopyFromReg 0x2e7feb0, 0x2e7f6b0, 0x2e7feb0:1 [ORD=69]

    0x2e83c40: i16 = TargetConstant<0>

  0x2ea9e80: ch = X86ISD::RET_FLAG 0x2e7f8b0:1, 0x2e83c40 [ORD=70]


Legally typed node: 0x2e83c40: i16 = TargetConstant<0> [ID=0]

Legally typed node: 0x2e7f6b0: i32 = Register %EAX [ID=0]

Legally typed node: 0x2e801b0: i8 = Register %AL [ID=0]

Legally typed node: 0x2e84840: i32 = Register %ESI [ID=0]

Legally typed node: 0x2e83f40: i8 = Constant<0> [ID=0]

Legally typed node: 0x2ea9780: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=69] [ID=0]

Legally typed node: 0x2ea9680: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=69] [ID=0]

Legally typed node: 0x2e84140: i64 = undef [ID=0]

Legally typed node: 0x2eaa480: i64 = FrameIndex<0> [ID=0]

Legally typed node: 0x2e7f4b0: i64 = Register %RAX [ID=0]

Legally typed node: 0x2ea9880: Untyped = RegisterMask [ID=0]

Legally typed node: 0x2e7f7b0: i64 = Register %RSI [ID=0]

Legally typed node: 0x2e7fbb0: i64 = Register %RDI [ID=0]

Legally typed node: 0x2e84040: i64 = TargetConstant<0> [ID=0]

Legally typed node: 0x2e83e40: i64 = Constant<48397984> [ID=0]

Legally typed node: 0x2eaa180: i64 = Constant<48717472> [ID=0]

Legally typed node: 0x2eaa280: i64 = Constant<8971440> [ID=0]

Legally typed node: 0x2eaa9d0: i32 = Register %vreg0 [ID=0]

Legally typed node: 0x2e5c478: ch = EntryToken [ID=0]

Legally typed node: 0x2eaa380: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=61] [ID=0]

Legally typed node: 0x2ea9d80: ch,glue = callseq_start 0x2e5c478, 0x2e84040 [ORD=65] [ID=0]

Legally typed node: 0x2e83b40: ch,glue = CopyToReg 0x2ea9d80, 0x2e7fbb0, 0x2eaa180 [ORD=65] [ID=0]

Legally typed node: 0x2ea9c80: ch,glue = CopyToReg 0x2e83b40, 0x2e7f7b0, 0x2e83e40, 0x2e83b40:1 [ORD=65] [ID=0]

Legally typed node: 0x2e83d40: ch,glue = X86ISD::CALL 0x2ea9c80, 0x2eaa280, 0x2e7fbb0, 0x2e7f7b0, 0x2ea9880, 0x2ea9c80:1 [ORD=65] [ID=0]

Legally typed node: 0x2e84740: ch,glue = callseq_end 0x2e83d40, 0x2e84040, 0x2e84040, 0x2e83d40:1 [ORD=65] [ID=0]

Legally typed node: 0x2eaa080: i64,ch,glue = CopyFromReg 0x2e84740, 0x2e7f4b0, 0x2e84740:1 [ORD=65] [ID=0]

Legally typed node: 0x2e7fdb0: ch = store 0x2eaa080:1, 0x2eaa380, 0x2eaa480, 0x2e84140<ST4[%i.addr]> [ORD=67] [ID=0]

Legally typed node: 0x2e800b0: ch,glue = callseq_start 0x2e7fdb0, 0x2e84040 [ORD=69] [ID=0]

Legally typed node: 0x2ea9980: ch,glue = CopyToReg 0x2e800b0, 0x2e7fbb0, 0x2ea9780 [ORD=69] [ID=0]

Legally typed node: 0x2eaa8d0: ch,glue = CopyToReg 0x2ea9980, 0x2e84840, 0x2eaa380, 0x2ea9980:1 [ORD=69] [ID=0]

Legally typed node: 0x2e84340: ch,glue = CopyToReg 0x2eaa8d0, 0x2e801b0, 0x2e83f40, 0x2eaa8d0:1 [ORD=69] [ID=0]

Legally typed node: 0x2e7f3b0: ch,glue = X86ISD::CALL 0x2e84340, 0x2ea9680, 0x2e7fbb0, 0x2e84840, 0x2e801b0, 0x2ea9880, 0x2e84340:1 [ORD=69] [ID=0]

Legally typed node: 0x2e7feb0: ch,glue = callseq_end 0x2e7f3b0, 0x2e84040, 0x2e84040, 0x2e7f3b0:1 [ORD=69] [ID=0]

Legally typed node: 0x2e7f8b0: i32,ch,glue = CopyFromReg 0x2e7feb0, 0x2e7f6b0, 0x2e7feb0:1 [ORD=69] [ID=0]

Legally typed node: 0x2ea9e80: ch = X86ISD::RET_FLAG 0x2e7f8b0:1, 0x2e83c40 [ORD=70] [ID=0]

Legally typed node: 0x7fff29e7ba10: ch = handlenode 0x2ea9e80 [ID=0]

Type-legalized selection DAG: BB#0 'func:entry'
SelectionDAG has 35 nodes:
  0x2e5c478: ch = EntryToken [ID=-3]

    0x2e5c478: <multiple use>
    0x2eaa9d0: i32 = Register %vreg0 [ID=-3]

  0x2eaa380: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=61] [ID=-3]

  0x2e84040: i64 = TargetConstant<0> [ID=-3]

  0x2e7fbb0: i64 = Register %RDI [ID=-3]

      0x2e5c478: <multiple use>
      0x2e84040: <multiple use>
    0x2ea9d80: ch,glue = callseq_start 0x2e5c478, 0x2e84040 [ORD=65] [ID=-3]

    0x2e7fbb0: <multiple use>
    0x2eaa180: i64 = Constant<48717472> [ID=-3]

  0x2e83b40: ch,glue = CopyToReg 0x2ea9d80, 0x2e7fbb0, 0x2eaa180 [ORD=65] [ID=-3]

  0x2e7f7b0: i64 = Register %RSI [ID=-3]

    0x2e83b40: <multiple use>
    0x2e7f7b0: <multiple use>
    0x2e83e40: i64 = Constant<48397984> [ID=-3]

    0x2e83b40: <multiple use>
  0x2ea9c80: ch,glue = CopyToReg 0x2e83b40, 0x2e7f7b0, 0x2e83e40, 0x2e83b40:1 [ORD=65] [ID=-3]

  0x2ea9880: Untyped = RegisterMask [ID=-3]

    0x2ea9c80: <multiple use>
    0x2eaa280: i64 = Constant<8971440> [ID=-3]

    0x2e7fbb0: <multiple use>
    0x2e7f7b0: <multiple use>
    0x2ea9880: <multiple use>
    0x2ea9c80: <multiple use>
  0x2e83d40: ch,glue = X86ISD::CALL 0x2ea9c80, 0x2eaa280, 0x2e7fbb0, 0x2e7f7b0, 0x2ea9880, 0x2ea9c80:1 [ORD=65] [ID=-3]

    0x2e83d40: <multiple use>
    0x2e84040: <multiple use>
    0x2e84040: <multiple use>
    0x2e83d40: <multiple use>
  0x2e84740: ch,glue = callseq_end 0x2e83d40, 0x2e84040, 0x2e84040, 0x2e83d40:1 [ORD=65] [ID=-3]

          0x2e84740: <multiple use>
          0x2e7f4b0: i64 = Register %RAX [ID=-3]

          0x2e84740: <multiple use>
        0x2eaa080: i64,ch,glue = CopyFromReg 0x2e84740, 0x2e7f4b0, 0x2e84740:1 [ORD=65] [ID=-3]

        0x2eaa380: <multiple use>
        0x2eaa480: i64 = FrameIndex<0> [ID=-3]

        0x2e84140: i64 = undef [ID=-3]

      0x2e7fdb0: ch = store 0x2eaa080:1, 0x2eaa380, 0x2eaa480, 0x2e84140<ST4[%i.addr]> [ORD=67] [ID=-3]

      0x2e84040: <multiple use>
    0x2e800b0: ch,glue = callseq_start 0x2e7fdb0, 0x2e84040 [ORD=69] [ID=-3]

    0x2e7fbb0: <multiple use>
    0x2ea9780: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=69] [ID=-3]

  0x2ea9980: ch,glue = CopyToReg 0x2e800b0, 0x2e7fbb0, 0x2ea9780 [ORD=69] [ID=-3]

  0x2e84840: i32 = Register %ESI [ID=-3]

    0x2ea9980: <multiple use>
    0x2e84840: <multiple use>
    0x2eaa380: <multiple use>
    0x2ea9980: <multiple use>
  0x2eaa8d0: ch,glue = CopyToReg 0x2ea9980, 0x2e84840, 0x2eaa380, 0x2ea9980:1 [ORD=69] [ID=-3]

  0x2e801b0: i8 = Register %AL [ID=-3]

    0x2eaa8d0: <multiple use>
    0x2e801b0: <multiple use>
    0x2e83f40: i8 = Constant<0> [ID=-3]

    0x2eaa8d0: <multiple use>
  0x2e84340: ch,glue = CopyToReg 0x2eaa8d0, 0x2e801b0, 0x2e83f40, 0x2eaa8d0:1 [ORD=69] [ID=-3]

    0x2e84340: <multiple use>
    0x2ea9680: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=69] [ID=-3]

    0x2e7fbb0: <multiple use>
    0x2e84840: <multiple use>
    0x2e801b0: <multiple use>
    0x2ea9880: <multiple use>
    0x2e84340: <multiple use>
  0x2e7f3b0: ch,glue = X86ISD::CALL 0x2e84340, 0x2ea9680, 0x2e7fbb0, 0x2e84840, 0x2e801b0, 0x2ea9880, 0x2e84340:1 [ORD=69] [ID=-3]

    0x2e7f3b0: <multiple use>
    0x2e84040: <multiple use>
    0x2e84040: <multiple use>
    0x2e7f3b0: <multiple use>
  0x2e7feb0: ch,glue = callseq_end 0x2e7f3b0, 0x2e84040, 0x2e84040, 0x2e7f3b0:1 [ORD=69] [ID=-3]

      0x2e7feb0: <multiple use>
      0x2e7f6b0: i32 = Register %EAX [ID=-3]

      0x2e7feb0: <multiple use>
    0x2e7f8b0: i32,ch,glue = CopyFromReg 0x2e7feb0, 0x2e7f6b0, 0x2e7feb0:1 [ORD=69] [ID=-3]

    0x2e83c40: i16 = TargetConstant<0> [ID=-3]

  0x2ea9e80: ch = X86ISD::RET_FLAG 0x2e7f8b0:1, 0x2e83c40 [ORD=70] [ID=-3]


Legalized selection DAG: BB#0 'func:entry'
SelectionDAG has 37 nodes:
  0x2e5c478: ch = EntryToken [ID=0]

  0x2e84040: i64 = TargetConstant<0> [ID=5]

  0x2e7fbb0: i64 = Register %RDI [ID=6]

  0x2e7f7b0: i64 = Register %RSI [ID=7]

  0x2ea9880: Untyped = RegisterMask [ID=8]

  0x2e84840: i32 = Register %ESI [ID=15]

  0x2e801b0: i8 = Register %AL [ID=16]

    0x2e5c478: <multiple use>
    0x2eaa9d0: i32 = Register %vreg0 [ID=1]

  0x2eaa380: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=61] [ID=19]

      0x2e5c478: <multiple use>
      0x2e84040: <multiple use>
    0x2ea9d80: ch,glue = callseq_start 0x2e5c478, 0x2e84040 [ORD=65] [ID=20]

    0x2e7fbb0: <multiple use>
    0x2eaa180: i64 = Constant<48717472> [ID=3]

  0x2e83b40: ch,glue = CopyToReg 0x2ea9d80, 0x2e7fbb0, 0x2eaa180 [ORD=65] [ID=21]

    0x2e83b40: <multiple use>
    0x2e7f7b0: <multiple use>
    0x2e83e40: i64 = Constant<48397984> [ID=4]

    0x2e83b40: <multiple use>
  0x2ea9c80: ch,glue = CopyToReg 0x2e83b40, 0x2e7f7b0, 0x2e83e40, 0x2e83b40:1 [ORD=65] [ID=22]

    0x2ea9c80: <multiple use>
    0x2eaa280: i64 = Constant<8971440> [ID=2]

    0x2e7fbb0: <multiple use>
    0x2e7f7b0: <multiple use>
    0x2ea9880: <multiple use>
    0x2ea9c80: <multiple use>
  0x2e83d40: ch,glue = X86ISD::CALL 0x2ea9c80, 0x2eaa280, 0x2e7fbb0, 0x2e7f7b0, 0x2ea9880, 0x2ea9c80:1 [ORD=65] [ID=23]

    0x2e83d40: <multiple use>
    0x2e84040: <multiple use>
    0x2e84040: <multiple use>
    0x2e83d40: <multiple use>
  0x2e84740: ch,glue = callseq_end 0x2e83d40, 0x2e84040, 0x2e84040, 0x2e83d40:1 [ORD=65] [ID=24]

          0x2e84740: <multiple use>
          0x2e7f4b0: i64 = Register %RAX [ID=9]

          0x2e84740: <multiple use>
        0x2eaa080: i64,ch,glue = CopyFromReg 0x2e84740, 0x2e7f4b0, 0x2e84740:1 [ORD=65] [ID=25]

        0x2eaa380: <multiple use>
        0x2eaa480: i64 = FrameIndex<0> [ID=10]

        0x2e84140: i64 = undef [ID=11]

      0x2e7fdb0: ch = store 0x2eaa080:1, 0x2eaa380, 0x2eaa480, 0x2e84140<ST4[%i.addr]> [ORD=67] [ID=26]

      0x2e84040: <multiple use>
    0x2e800b0: ch,glue = callseq_start 0x2e7fdb0, 0x2e84040 [ORD=69] [ID=27]

    0x2e7fbb0: <multiple use>
      0x2ea9f80: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=69]

    0x2e7f5b0: i64 = X86ISD::Wrapper 0x2ea9f80 [ORD=69]

  0x2ea9980: ch,glue = CopyToReg 0x2e800b0, 0x2e7fbb0, 0x2e7f5b0 [ORD=69] [ID=28]

    0x2ea9980: <multiple use>
    0x2e84840: <multiple use>
    0x2eaa380: <multiple use>
    0x2ea9980: <multiple use>
  0x2eaa8d0: ch,glue = CopyToReg 0x2ea9980, 0x2e84840, 0x2eaa380, 0x2ea9980:1 [ORD=69] [ID=29]

    0x2eaa8d0: <multiple use>
    0x2e801b0: <multiple use>
    0x2e83f40: i8 = Constant<0> [ID=14]

    0x2eaa8d0: <multiple use>
  0x2e84340: ch,glue = CopyToReg 0x2eaa8d0, 0x2e801b0, 0x2e83f40, 0x2eaa8d0:1 [ORD=69] [ID=30]

    0x2e84340: <multiple use>
      0x2ea9780: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=69]

    0x2ea9b80: i64 = X86ISD::Wrapper 0x2ea9780 [ORD=69]

    0x2e7fbb0: <multiple use>
    0x2e84840: <multiple use>
    0x2e801b0: <multiple use>
    0x2ea9880: <multiple use>
    0x2e84340: <multiple use>
  0x2e7f3b0: ch,glue = X86ISD::CALL 0x2e84340, 0x2ea9b80, 0x2e7fbb0, 0x2e84840, 0x2e801b0, 0x2ea9880, 0x2e84340:1 [ORD=69] [ID=31]

    0x2e7f3b0: <multiple use>
    0x2e84040: <multiple use>
    0x2e84040: <multiple use>
    0x2e7f3b0: <multiple use>
  0x2e7feb0: ch,glue = callseq_end 0x2e7f3b0, 0x2e84040, 0x2e84040, 0x2e7f3b0:1 [ORD=69] [ID=32]

      0x2e7feb0: <multiple use>
      0x2e7f6b0: i32 = Register %EAX [ID=17]

      0x2e7feb0: <multiple use>
    0x2e7f8b0: i32,ch,glue = CopyFromReg 0x2e7feb0, 0x2e7f6b0, 0x2e7feb0:1 [ORD=69] [ID=33]

    0x2e83c40: i16 = TargetConstant<0> [ID=18]

  0x2ea9e80: ch = X86ISD::RET_FLAG 0x2e7f8b0:1, 0x2e83c40 [ORD=70] [ID=34]


Optimized legalized selection DAG: BB#0 'func:entry'
SelectionDAG has 37 nodes:
  0x2e5c478: ch = EntryToken [ID=0]

  0x2e84040: i64 = TargetConstant<0> [ID=5]

  0x2e7fbb0: i64 = Register %RDI [ID=6]

  0x2e7f7b0: i64 = Register %RSI [ID=7]

  0x2ea9880: Untyped = RegisterMask [ID=8]

  0x2e84840: i32 = Register %ESI [ID=15]

  0x2e801b0: i8 = Register %AL [ID=16]

    0x2e5c478: <multiple use>
    0x2eaa9d0: i32 = Register %vreg0 [ID=1]

  0x2eaa380: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=61] [ID=19]

      0x2e5c478: <multiple use>
      0x2e84040: <multiple use>
    0x2ea9d80: ch,glue = callseq_start 0x2e5c478, 0x2e84040 [ORD=65] [ID=20]

    0x2e7fbb0: <multiple use>
    0x2eaa180: i64 = Constant<48717472> [ID=3]

  0x2e83b40: ch,glue = CopyToReg 0x2ea9d80, 0x2e7fbb0, 0x2eaa180 [ORD=65] [ID=21]

    0x2e83b40: <multiple use>
    0x2e7f7b0: <multiple use>
    0x2e83e40: i64 = Constant<48397984> [ID=4]

    0x2e83b40: <multiple use>
  0x2ea9c80: ch,glue = CopyToReg 0x2e83b40, 0x2e7f7b0, 0x2e83e40, 0x2e83b40:1 [ORD=65] [ID=22]

    0x2ea9c80: <multiple use>
    0x2eaa280: i64 = Constant<8971440> [ID=2]

    0x2e7fbb0: <multiple use>
    0x2e7f7b0: <multiple use>
    0x2ea9880: <multiple use>
    0x2ea9c80: <multiple use>
  0x2e83d40: ch,glue = X86ISD::CALL 0x2ea9c80, 0x2eaa280, 0x2e7fbb0, 0x2e7f7b0, 0x2ea9880, 0x2ea9c80:1 [ORD=65] [ID=23]

    0x2e83d40: <multiple use>
    0x2e84040: <multiple use>
    0x2e84040: <multiple use>
    0x2e83d40: <multiple use>
  0x2e84740: ch,glue = callseq_end 0x2e83d40, 0x2e84040, 0x2e84040, 0x2e83d40:1 [ORD=65] [ID=24]

          0x2e84740: <multiple use>
          0x2e7f4b0: i64 = Register %RAX [ID=9]

          0x2e84740: <multiple use>
        0x2eaa080: i64,ch,glue = CopyFromReg 0x2e84740, 0x2e7f4b0, 0x2e84740:1 [ORD=65] [ID=25]

        0x2eaa380: <multiple use>
        0x2eaa480: i64 = FrameIndex<0> [ID=10]

        0x2e84140: i64 = undef [ID=11]

      0x2e7fdb0: ch = store 0x2eaa080:1, 0x2eaa380, 0x2eaa480, 0x2e84140<ST4[%i.addr]> [ORD=67] [ID=26]

      0x2e84040: <multiple use>
    0x2e800b0: ch,glue = callseq_start 0x2e7fdb0, 0x2e84040 [ORD=69] [ID=27]

    0x2e7fbb0: <multiple use>
      0x2ea9f80: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=69]

    0x2e7f5b0: i64 = X86ISD::Wrapper 0x2ea9f80 [ORD=69]

  0x2ea9980: ch,glue = CopyToReg 0x2e800b0, 0x2e7fbb0, 0x2e7f5b0 [ORD=69] [ID=28]

    0x2ea9980: <multiple use>
    0x2e84840: <multiple use>
    0x2eaa380: <multiple use>
    0x2ea9980: <multiple use>
  0x2eaa8d0: ch,glue = CopyToReg 0x2ea9980, 0x2e84840, 0x2eaa380, 0x2ea9980:1 [ORD=69] [ID=29]

    0x2eaa8d0: <multiple use>
    0x2e801b0: <multiple use>
    0x2e83f40: i8 = Constant<0> [ID=14]

    0x2eaa8d0: <multiple use>
  0x2e84340: ch,glue = CopyToReg 0x2eaa8d0, 0x2e801b0, 0x2e83f40, 0x2eaa8d0:1 [ORD=69] [ID=30]

    0x2e84340: <multiple use>
      0x2ea9780: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=69]

    0x2ea9b80: i64 = X86ISD::Wrapper 0x2ea9780 [ORD=69]

    0x2e7fbb0: <multiple use>
    0x2e84840: <multiple use>
    0x2e801b0: <multiple use>
    0x2ea9880: <multiple use>
    0x2e84340: <multiple use>
  0x2e7f3b0: ch,glue = X86ISD::CALL 0x2e84340, 0x2ea9b80, 0x2e7fbb0, 0x2e84840, 0x2e801b0, 0x2ea9880, 0x2e84340:1 [ORD=69] [ID=31]

    0x2e7f3b0: <multiple use>
    0x2e84040: <multiple use>
    0x2e84040: <multiple use>
    0x2e7f3b0: <multiple use>
  0x2e7feb0: ch,glue = callseq_end 0x2e7f3b0, 0x2e84040, 0x2e84040, 0x2e7f3b0:1 [ORD=69] [ID=32]

      0x2e7feb0: <multiple use>
      0x2e7f6b0: i32 = Register %EAX [ID=17]

      0x2e7feb0: <multiple use>
    0x2e7f8b0: i32,ch,glue = CopyFromReg 0x2e7feb0, 0x2e7f6b0, 0x2e7feb0:1 [ORD=69] [ID=33]

    0x2e83c40: i16 = TargetConstant<0> [ID=18]

  0x2ea9e80: ch = X86ISD::RET_FLAG 0x2e7f8b0:1, 0x2e83c40 [ORD=70] [ID=34]


===== Instruction selection begins: BB#0 'entry'
Selecting: 0x2ea9e80: ch = X86ISD::RET_FLAG 0x2e7f8b0:1, 0x2e83c40 [ORD=70] [ID=36]

ISEL: Starting pattern match on root node: 0x2ea9e80: ch = X86ISD::RET_FLAG 0x2e7f8b0:1, 0x2e83c40 [ORD=70] [ID=36]

  Initial Opcode index to 93235
  Morphed node: 0x2ea9e80: ch = RET 0x2e7f8b0:1 [ORD=70]

ISEL: Match complete!
=> 0x2ea9e80: ch = RET 0x2e7f8b0:1 [ORD=70]

Selecting: 0x2e7f8b0: i32,ch,glue = CopyFromReg 0x2e7feb0, 0x2e7f6b0, 0x2e7feb0:1 [ORD=69] [ID=35]

=> 0x2e7f8b0: i32,ch,glue = CopyFromReg 0x2e7feb0, 0x2e7f6b0, 0x2e7feb0:1 [ORD=69]

Selecting: 0x2e7feb0: ch,glue = callseq_end 0x2e7f3b0, 0x2e84040, 0x2e84040, 0x2e7f3b0:1 [ORD=69] [ID=34]

ISEL: Starting pattern match on root node: 0x2e7feb0: ch,glue = callseq_end 0x2e7f3b0, 0x2e84040, 0x2e84040, 0x2e7f3b0:1 [ORD=69] [ID=34]

  Initial Opcode index to 92907
  Skipped scope entry (due to false predicate) at index 92925, continuing at 92937
  Morphed node: 0x2e7feb0: i64,ch,glue = ADJCALLSTACKUP64 0x2e84040, 0x2e84040, 0x2e7f3b0, 0x2e7f3b0:1 [ORD=69]

ISEL: Match complete!
=> 0x2e7feb0: i64,ch,glue = ADJCALLSTACKUP64 0x2e84040, 0x2e84040, 0x2e7f3b0, 0x2e7f3b0:1 [ORD=69]

Selecting: 0x2e7f3b0: ch,glue = X86ISD::CALL 0x2e84340, 0x2ea9b80, 0x2e7fbb0, 0x2e84840, 0x2e801b0, 0x2ea9880, 0x2e84340:1 [ORD=69] [ID=33]

ISEL: Starting pattern match on root node: 0x2e7f3b0: ch,glue = X86ISD::CALL 0x2e84340, 0x2ea9b80, 0x2e7fbb0, 0x2e84840, 0x2e801b0, 0x2ea9880, 0x2e84340:1 [ORD=69] [ID=33]

  Initial Opcode index to 69884
  Match failed at index 69890
  Continuing at 69951
  Match failed at index 69957
  Continuing at 70031
  Match failed at index 70032
  Continuing at 70044
  Morphed node: 0x2e7f3b0: ch,glue = CALL64r 0x2ea9b80, 0x2e7fbb0, 0x2e84840, 0x2e801b0, 0x2ea9880, 0x2e84340, 0x2e84340:1 [ORD=69]

ISEL: Match complete!
=> 0x2e7f3b0: ch,glue = CALL64r 0x2ea9b80, 0x2e7fbb0, 0x2e84840, 0x2e801b0, 0x2ea9880, 0x2e84340, 0x2e84340:1 [ORD=69]

Selecting: 0x2e84340: ch,glue = CopyToReg 0x2eaa8d0, 0x2e801b0, 0x2e83f40, 0x2eaa8d0:1 [ORD=69] [ID=32]

=> 0x2e84340: ch,glue = CopyToReg 0x2eaa8d0, 0x2e801b0, 0x2e83f40, 0x2eaa8d0:1 [ORD=69]

Selecting: 0x2eaa8d0: ch,glue = CopyToReg 0x2ea9980, 0x2e84840, 0x2eaa380, 0x2ea9980:1 [ORD=69] [ID=31]

=> 0x2eaa8d0: ch,glue = CopyToReg 0x2ea9980, 0x2e84840, 0x2eaa380, 0x2ea9980:1 [ORD=69]

Selecting: 0x2ea9980: ch,glue = CopyToReg 0x2e800b0, 0x2e7fbb0, 0x2e7f5b0 [ORD=69] [ID=30]

=> 0x2ea9980: ch,glue = CopyToReg 0x2e800b0, 0x2e7fbb0, 0x2e7f5b0 [ORD=69]

Selecting: 0x2e800b0: ch,glue = callseq_start 0x2e7fdb0, 0x2e84040 [ORD=69] [ID=29]

ISEL: Starting pattern match on root node: 0x2e800b0: ch,glue = callseq_start 0x2e7fdb0, 0x2e84040 [ORD=69] [ID=29]

  Initial Opcode index to 95380
  Skipped scope entry (due to false predicate) at index 95390, continuing at 95401
  Morphed node: 0x2e800b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84040, 0x2e7fdb0 [ORD=69]

ISEL: Match complete!
=> 0x2e800b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84040, 0x2e7fdb0 [ORD=69]

Selecting: 0x2e7fdb0: ch = store 0x2eaa080:1, 0x2eaa380, 0x2eaa480, 0x2e84140<ST4[%i.addr]> [ORD=67] [ID=28]

ISEL: Starting pattern match on root node: 0x2e7fdb0: ch = store 0x2eaa080:1, 0x2eaa380, 0x2eaa480, 0x2e84140<ST4[%i.addr]> [ORD=67] [ID=28]

  Initial Opcode index to 5
  Skipped scope entry (due to false predicate) at index 13, continuing at 58
  Skipped scope entry (due to false predicate) at index 59, continuing at 104
  Skipped scope entry (due to false predicate) at index 105, continuing at 188
  Skipped scope entry (due to false predicate) at index 189, continuing at 212
  Skipped scope entry (due to false predicate) at index 213, continuing at 236
  Skipped scope entry (due to false predicate) at index 237, continuing at 260
  Match failed at index 264
  Continuing at 284
  Match failed at index 285
  Continuing at 308
  Continuing at 309
  Match failed at index 313
  Continuing at 10708
  Match failed at index 10713
  Continuing at 11131
  Match failed at index 11135
  Continuing at 11509
  Match failed at index 11513
  Continuing at 11624
  Match failed at index 11628
  Continuing at 11859
  Skipped scope entry (due to false predicate) at index 11864, continuing at 11950
  Skipped scope entry (due to false predicate) at index 11951, continuing at 12064
  Skipped scope entry (due to false predicate) at index 12065, continuing at 12137
  Skipped scope entry (due to false predicate) at index 12138, continuing at 12161
  Skipped scope entry (due to false predicate) at index 12162, continuing at 12185
MatchAddress: X86ISelAddressMode 0x7fff29e7b560
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
  Morphed node: 0x2e7fdb0: ch = MOV32mr 0x2ea9680, 0x2e84240, 0x2e83c40, 0x2e84640, 0x2ea9a80, 0x2eaa380, 0x2eaa080:1<Mem:ST4[%i.addr]> [ORD=67]

ISEL: Match complete!
=> 0x2e7fdb0: ch = MOV32mr 0x2ea9680, 0x2e84240, 0x2e83c40, 0x2e84640, 0x2ea9a80, 0x2eaa380, 0x2eaa080:1<Mem:ST4[%i.addr]> [ORD=67]

Selecting: 0x2eaa080: i64,ch,glue = CopyFromReg 0x2e84740, 0x2e7f4b0, 0x2e84740:1 [ORD=65] [ID=27]

=> 0x2eaa080: i64,ch,glue = CopyFromReg 0x2e84740, 0x2e7f4b0, 0x2e84740:1 [ORD=65]

Selecting: 0x2e84740: ch,glue = callseq_end 0x2e83d40, 0x2e84040, 0x2e84040, 0x2e83d40:1 [ORD=65] [ID=26]

ISEL: Starting pattern match on root node: 0x2e84740: ch,glue = callseq_end 0x2e83d40, 0x2e84040, 0x2e84040, 0x2e83d40:1 [ORD=65] [ID=26]

  Initial Opcode index to 92907
  Skipped scope entry (due to false predicate) at index 92925, continuing at 92937
  Morphed node: 0x2e84740: i64,ch,glue = ADJCALLSTACKUP64 0x2e84040, 0x2e84040, 0x2e83d40, 0x2e83d40:1 [ORD=65]

ISEL: Match complete!
=> 0x2e84740: i64,ch,glue = ADJCALLSTACKUP64 0x2e84040, 0x2e84040, 0x2e83d40, 0x2e83d40:1 [ORD=65]

Selecting: 0x2e83d40: ch,glue = X86ISD::CALL 0x2ea9c80, 0x2eaa280, 0x2e7fbb0, 0x2e7f7b0, 0x2ea9880, 0x2ea9c80:1 [ORD=65] [ID=25]

ISEL: Starting pattern match on root node: 0x2e83d40: ch,glue = X86ISD::CALL 0x2ea9c80, 0x2eaa280, 0x2e7fbb0, 0x2e7f7b0, 0x2ea9880, 0x2ea9c80:1 [ORD=65] [ID=25]

  Initial Opcode index to 69884
  Match failed at index 69890
  Continuing at 69951
  OpcodeSwitch from 69957 to 70015
  Match failed at index 70015
  Continuing at 70031
  Match failed at index 70032
  Continuing at 70044
  Morphed node: 0x2e83d40: ch,glue = CALL64r 0x2eaa280, 0x2e7fbb0, 0x2e7f7b0, 0x2ea9880, 0x2ea9c80, 0x2ea9c80:1 [ORD=65]

ISEL: Match complete!
=> 0x2e83d40: ch,glue = CALL64r 0x2eaa280, 0x2e7fbb0, 0x2e7f7b0, 0x2ea9880, 0x2ea9c80, 0x2ea9c80:1 [ORD=65]

Selecting: 0x2ea9c80: ch,glue = CopyToReg 0x2e83b40, 0x2e7f7b0, 0x2e83e40, 0x2e83b40:1 [ORD=65] [ID=24]

=> 0x2ea9c80: ch,glue = CopyToReg 0x2e83b40, 0x2e7f7b0, 0x2e83e40, 0x2e83b40:1 [ORD=65]

Selecting: 0x2e83b40: ch,glue = CopyToReg 0x2ea9d80, 0x2e7fbb0, 0x2eaa180 [ORD=65] [ID=23]

=> 0x2e83b40: ch,glue = CopyToReg 0x2ea9d80, 0x2e7fbb0, 0x2eaa180 [ORD=65]

Selecting: 0x2ea9b80: i64 = X86ISD::Wrapper 0x2ea9780 [ORD=69] [ID=22]

ISEL: Starting pattern match on root node: 0x2ea9b80: i64 = X86ISD::Wrapper 0x2ea9780 [ORD=69] [ID=22]

  Initial Opcode index to 94787
  Match failed at index 94792
  Continuing at 94819
  OpcodeSwitch from 94824 to 94938
  TypeSwitch[i64] from 94939 to 94952
  Morphed node: 0x2ea9b80: i64 = MOV64ri 0x2ea9780 [ORD=69]

ISEL: Match complete!
=> 0x2ea9b80: i64 = MOV64ri 0x2ea9780 [ORD=69]

Selecting: 0x2e7f5b0: i64 = X86ISD::Wrapper 0x2ea9f80 [ORD=69] [ID=21]

ISEL: Starting pattern match on root node: 0x2e7f5b0: i64 = X86ISD::Wrapper 0x2ea9f80 [ORD=69] [ID=21]

  Initial Opcode index to 94787
  Match failed at index 94792
  Continuing at 94819
  OpcodeSwitch from 94824 to 94938
  TypeSwitch[i64] from 94939 to 94952
  Morphed node: 0x2e7f5b0: i64 = MOV64ri 0x2ea9f80 [ORD=69]

ISEL: Match complete!
=> 0x2e7f5b0: i64 = MOV64ri 0x2ea9f80 [ORD=69]

Selecting: 0x2ea9d80: ch,glue = callseq_start 0x2e5c478, 0x2e84040 [ORD=65] [ID=20]

ISEL: Starting pattern match on root node: 0x2ea9d80: ch,glue = callseq_start 0x2e5c478, 0x2e84040 [ORD=65] [ID=20]

  Initial Opcode index to 95380
  Skipped scope entry (due to false predicate) at index 95390, continuing at 95401
  Morphed node: 0x2ea9d80: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84040, 0x2e5c478 [ORD=65]

ISEL: Match complete!
=> 0x2ea9d80: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84040, 0x2e5c478 [ORD=65]

Selecting: 0x2eaa380: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=61] [ID=19]

=> 0x2eaa380: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=61]

Selecting: 0x2ea9780: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=69] [ID=18]

=> 0x2ea9780: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=69]

Selecting: 0x2ea9f80: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=69] [ID=17]

=> 0x2ea9f80: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=69]

Selecting: 0x2e7f6b0: i32 = Register %EAX [ID=15]

=> 0x2e7f6b0: i32 = Register %EAX

Selecting: 0x2e801b0: i8 = Register %AL [ID=14]

=> 0x2e801b0: i8 = Register %AL

Selecting: 0x2e84840: i32 = Register %ESI [ID=13]

=> 0x2e84840: i32 = Register %ESI

Selecting: 0x2e83f40: i8 = Constant<0> [ID=12]

ISEL: Starting pattern match on root node: 0x2e83f40: i8 = Constant<0> [ID=12]

  Initial Opcode index to 82786
  Match failed at index 82790
  Continuing at 82816
  Match failed at index 82818
  Continuing at 82847
  TypeSwitch[i8] from 82850 to 82863
  Created node: 0x2eaa480: i32,i32 = MOV32r0

  Morphed node: 0x2e83f40: i8 = EXTRACT_SUBREG 0x2eaa480, 0x2e84140

ISEL: Match complete!
=> 0x2e83f40: i8 = EXTRACT_SUBREG 0x2eaa480, 0x2e84140

Selecting: 0x2e7f4b0: i64 = Register %RAX [ID=9]

=> 0x2e7f4b0: i64 = Register %RAX

Selecting: 0x2ea9880: Untyped = RegisterMask [ID=8]

=> 0x2ea9880: Untyped = RegisterMask

Selecting: 0x2e7f7b0: i64 = Register %RSI [ID=7]

=> 0x2e7f7b0: i64 = Register %RSI

Selecting: 0x2e7fbb0: i64 = Register %RDI [ID=6]

=> 0x2e7fbb0: i64 = Register %RDI

Selecting: 0x2e84040: i64 = TargetConstant<0> [ID=5]

=> 0x2e84040: i64 = TargetConstant<0>

Selecting: 0x2e83e40: i64 = Constant<48397984> [ID=4]

ISEL: Starting pattern match on root node: 0x2e83e40: i64 = Constant<48397984> [ID=4]

  Initial Opcode index to 82786
  Skipped scope entry (due to false predicate) at index 82788, continuing at 82816
  Created node: 0x2e84540: i32 = MOV32ri64 0x2e84440

  Morphed node: 0x2e83e40: i64 = SUBREG_TO_REG 0x2e84040, 0x2e84540, 0x2e84940

ISEL: Match complete!
=> 0x2e83e40: i64 = SUBREG_TO_REG 0x2e84040, 0x2e84540, 0x2e84940

Selecting: 0x2eaa180: i64 = Constant<48717472> [ID=3]

ISEL: Starting pattern match on root node: 0x2eaa180: i64 = Constant<48717472> [ID=3]

  Initial Opcode index to 82786
  Skipped scope entry (due to false predicate) at index 82788, continuing at 82816
  Created node: 0x2e7f9b0: i32 = MOV32ri64 0x2e7ffb0

  Morphed node: 0x2eaa180: i64 = SUBREG_TO_REG 0x2e84040, 0x2e7f9b0, 0x2e84940

ISEL: Match complete!
=> 0x2eaa180: i64 = SUBREG_TO_REG 0x2e84040, 0x2e7f9b0, 0x2e84940

Selecting: 0x2eaa280: i64 = Constant<8971440> [ID=2]

ISEL: Starting pattern match on root node: 0x2eaa280: i64 = Constant<8971440> [ID=2]

  Initial Opcode index to 82786
  Skipped scope entry (due to false predicate) at index 82788, continuing at 82816
  Created node: 0x2e7fab0: i32 = MOV32ri64 0x2e7fcb0

  Morphed node: 0x2eaa280: i64 = SUBREG_TO_REG 0x2e84040, 0x2e7fab0, 0x2e84940

ISEL: Match complete!
=> 0x2eaa280: i64 = SUBREG_TO_REG 0x2e84040, 0x2e7fab0, 0x2e84940

Selecting: 0x2eaa9d0: i32 = Register %vreg0 [ID=1]

=> 0x2eaa9d0: i32 = Register %vreg0

Selecting: 0x2e5c478: ch = EntryToken [ID=0]

=> 0x2e5c478: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: BB#0 'func:entry'
SelectionDAG has 48 nodes:
  0x2e5c478: ch = EntryToken

  0x2e84040: i64 = TargetConstant<0>

  0x2e7fbb0: i64 = Register %RDI

  0x2e7f7b0: i64 = Register %RSI

  0x2ea9880: Untyped = RegisterMask

  0x2e84840: i32 = Register %ESI

  0x2e801b0: i8 = Register %AL

    0x2e5c478: <multiple use>
    0x2eaa9d0: i32 = Register %vreg0

  0x2eaa380: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=61]

      0x2e84040: <multiple use>
      0x2e5c478: <multiple use>
    0x2ea9d80: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84040, 0x2e5c478 [ORD=65]

    0x2e7fbb0: <multiple use>
      0x2e84040: <multiple use>
        0x2e7ffb0: i64 = TargetConstant<48717472>

      0x2e7f9b0: i32 = MOV32ri64 0x2e7ffb0

      0x2e84940: <multiple use>
    0x2eaa180: i64 = SUBREG_TO_REG 0x2e84040, 0x2e7f9b0, 0x2e84940

  0x2e83b40: ch,glue = CopyToReg 0x2ea9d80:1, 0x2e7fbb0, 0x2eaa180 [ORD=65]

    0x2e83b40: <multiple use>
    0x2e7f7b0: <multiple use>
      0x2e84040: <multiple use>
        0x2e84440: i64 = TargetConstant<48397984>

      0x2e84540: i32 = MOV32ri64 0x2e84440

      0x2e84940: <multiple use>
    0x2e83e40: i64 = SUBREG_TO_REG 0x2e84040, 0x2e84540, 0x2e84940

    0x2e83b40: <multiple use>
  0x2ea9c80: ch,glue = CopyToReg 0x2e83b40, 0x2e7f7b0, 0x2e83e40, 0x2e83b40:1 [ORD=65]

      0x2e84040: <multiple use>
        0x2e7fcb0: i64 = TargetConstant<8971440>

      0x2e7fab0: i32 = MOV32ri64 0x2e7fcb0

      0x2e84940: <multiple use>
    0x2eaa280: i64 = SUBREG_TO_REG 0x2e84040, 0x2e7fab0, 0x2e84940

    0x2e7fbb0: <multiple use>
    0x2e7f7b0: <multiple use>
    0x2ea9880: <multiple use>
    0x2ea9c80: <multiple use>
    0x2ea9c80: <multiple use>
  0x2e83d40: ch,glue = CALL64r 0x2eaa280, 0x2e7fbb0, 0x2e7f7b0, 0x2ea9880, 0x2ea9c80, 0x2ea9c80:1 [ORD=65]

    0x2e84040: <multiple use>
    0x2e84040: <multiple use>
    0x2e83d40: <multiple use>
    0x2e83d40: <multiple use>
  0x2e84740: i64,ch,glue = ADJCALLSTACKUP64 0x2e84040, 0x2e84040, 0x2e83d40, 0x2e83d40:1 [ORD=65]

      0x2e84040: <multiple use>
        0x2ea9680: i64 = TargetFrameIndex<0>

        0x2e84240: i8 = TargetConstant<1>

        0x2e83c40: i64 = Register %noreg

        0x2e84640: i32 = TargetConstant<0>

        0x2ea9a80: i32 = Register %noreg

        0x2eaa380: <multiple use>
          0x2e84740: <multiple use>
          0x2e7f4b0: i64 = Register %RAX

          0x2e84740: <multiple use>
        0x2eaa080: i64,ch,glue = CopyFromReg 0x2e84740:1, 0x2e7f4b0, 0x2e84740:2 [ORD=65]

      0x2e7fdb0: ch = MOV32mr 0x2ea9680, 0x2e84240, 0x2e83c40, 0x2e84640, 0x2ea9a80, 0x2eaa380, 0x2eaa080:1<Mem:ST4[%i.addr]> [ORD=67]

    0x2e800b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84040, 0x2e7fdb0 [ORD=69]

    0x2e7fbb0: <multiple use>
      0x2ea9f80: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=69]

    0x2e7f5b0: i64 = MOV64ri 0x2ea9f80 [ORD=69]

  0x2ea9980: ch,glue = CopyToReg 0x2e800b0:1, 0x2e7fbb0, 0x2e7f5b0 [ORD=69]

    0x2ea9980: <multiple use>
    0x2e84840: <multiple use>
    0x2eaa380: <multiple use>
    0x2ea9980: <multiple use>
  0x2eaa8d0: ch,glue = CopyToReg 0x2ea9980, 0x2e84840, 0x2eaa380, 0x2ea9980:1 [ORD=69]

    0x2eaa8d0: <multiple use>
    0x2e801b0: <multiple use>
      0x2eaa480: i32,i32 = MOV32r0

      0x2e84140: i32 = TargetConstant<1>

    0x2e83f40: i8 = EXTRACT_SUBREG 0x2eaa480, 0x2e84140

    0x2eaa8d0: <multiple use>
  0x2e84340: ch,glue = CopyToReg 0x2eaa8d0, 0x2e801b0, 0x2e83f40, 0x2eaa8d0:1 [ORD=69]

      0x2ea9780: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=69]

    0x2ea9b80: i64 = MOV64ri 0x2ea9780 [ORD=69]

    0x2e7fbb0: <multiple use>
    0x2e84840: <multiple use>
    0x2e801b0: <multiple use>
    0x2ea9880: <multiple use>
    0x2e84340: <multiple use>
    0x2e84340: <multiple use>
  0x2e7f3b0: ch,glue = CALL64r 0x2ea9b80, 0x2e7fbb0, 0x2e84840, 0x2e801b0, 0x2ea9880, 0x2e84340, 0x2e84340:1 [ORD=69]

    0x2e84040: <multiple use>
    0x2e84040: <multiple use>
    0x2e7f3b0: <multiple use>
    0x2e7f3b0: <multiple use>
  0x2e7feb0: i64,ch,glue = ADJCALLSTACKUP64 0x2e84040, 0x2e84040, 0x2e7f3b0, 0x2e7f3b0:1 [ORD=69]

  0x2e84940: i32 = TargetConstant<4>

      0x2e7feb0: <multiple use>
      0x2e7f6b0: i32 = Register %EAX

      0x2e7feb0: <multiple use>
    0x2e7f8b0: i32,ch,glue = CopyFromReg 0x2e7feb0:1, 0x2e7f6b0, 0x2e7feb0:2 [ORD=69]

  0x2ea9e80: ch = RET 0x2e7f8b0:1 [ORD=70]


********** List Scheduling BB#0 'entry' **********
SU(0): 0x2ea9e80: ch = RET 0x2e7f8b0:1 [ORD=70] [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 0
  Predecessors:
   ch  SU(1): Latency=1

SU(1): 0x2e7f8b0: i32,ch,glue = CopyFromReg 0x2e7feb0:1, 0x2e7f6b0, 0x2e7feb0:2 [ORD=69] [ID=1]

    0x2ea9980: ch,glue = CopyToReg 0x2e800b0:1, 0x2e7fbb0, 0x2e7f5b0 [ORD=69] [ID=1]

    0x2eaa8d0: ch,glue = CopyToReg 0x2ea9980, 0x2e84840, 0x2eaa380, 0x2ea9980:1 [ORD=69] [ID=1]

    0x2e84340: ch,glue = CopyToReg 0x2eaa8d0, 0x2e801b0, 0x2e83f40, 0x2eaa8d0:1 [ORD=69] [ID=1]

    0x2e7f3b0: ch,glue = CALL64r 0x2ea9b80, 0x2e7fbb0, 0x2e84840, 0x2e801b0, 0x2ea9880, 0x2e84340, 0x2e84340:1 [ORD=69] [ID=1]

    0x2e7feb0: i64,ch,glue = ADJCALLSTACKUP64 0x2e84040, 0x2e84040, 0x2e7f3b0, 0x2e7f3b0:1 [ORD=69] [ID=1]

  # preds left       : 5
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 1
  Predecessors:
   val SU(16): Latency=1
   val SU(2): Latency=1
   val SU(4): Latency=1
   ch  SU(6): Latency=1
   val SU(5): Latency=1
  Successors:
   ch  SU(0): Latency=1

SU(2): 0x2e83f40: i8 = EXTRACT_SUBREG 0x2eaa480, 0x2e84140 [ID=2]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
   val SU(3): Latency=1
  Successors:
   val SU(1): Latency=1

SU(3): 0x2eaa480: i32,i32 = MOV32r0 [ID=3]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
   val SU(2): Latency=1

SU(4): 0x2eaa380: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=61] [ID=4]

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
   val SU(1): Latency=1
   val SU(7): Latency=1

SU(5): 0x2e7f5b0: i64 = MOV64ri 0x2ea9f80 [ORD=69] [ID=5]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
   val SU(1): Latency=1

SU(6): 0x2e800b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84040, 0x2e7fdb0 [ORD=69] [ID=6]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 2
  Predecessors:
   ch  SU(7): Latency=1
  Successors:
   ch  SU(1): Latency=1

SU(7): 0x2e7fdb0: ch = MOV32mr 0x2ea9680, 0x2e84240, 0x2e83c40, 0x2e84640, 0x2ea9a80, 0x2eaa380, 0x2eaa080:1<Mem:ST4[%i.addr]> [ORD=67] [ID=7]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 3
  Predecessors:
   val SU(4): Latency=1
   ch  SU(8): Latency=1
  Successors:
   ch  SU(6): Latency=1

SU(8): 0x2eaa080: i64,ch,glue = CopyFromReg 0x2e84740:1, 0x2e7f4b0, 0x2e84740:2 [ORD=65] [ID=8]

    0x2e83b40: ch,glue = CopyToReg 0x2ea9d80:1, 0x2e7fbb0, 0x2eaa180 [ORD=65] [ID=8]

    0x2ea9c80: ch,glue = CopyToReg 0x2e83b40, 0x2e7f7b0, 0x2e83e40, 0x2e83b40:1 [ORD=65] [ID=8]

    0x2e83d40: ch,glue = CALL64r 0x2eaa280, 0x2e7fbb0, 0x2e7f7b0, 0x2ea9880, 0x2ea9c80, 0x2ea9c80:1 [ORD=65] [ID=8]

    0x2e84740: i64,ch,glue = ADJCALLSTACKUP64 0x2e84040, 0x2e84040, 0x2e83d40, 0x2e83d40:1 [ORD=65] [ID=8]

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 4
  Predecessors:
   val SU(14): Latency=1
   val SU(9): Latency=1
   ch  SU(13): Latency=1
   val SU(11): Latency=1
  Successors:
   ch  SU(7): Latency=1

SU(9): 0x2e83e40: i64 = SUBREG_TO_REG 0x2e84040, 0x2e84540, 0x2e84940 [ID=9]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
   val SU(10): Latency=1
  Successors:
   val SU(8): Latency=1

SU(10): 0x2e84540: i32 = MOV32ri64 0x2e84440 [ID=10]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
   val SU(9): Latency=1

SU(11): 0x2eaa180: i64 = SUBREG_TO_REG 0x2e84040, 0x2e7f9b0, 0x2e84940 [ID=11]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
   val SU(12): Latency=1
  Successors:
   val SU(8): Latency=1

SU(12): 0x2e7f9b0: i32 = MOV32ri64 0x2e7ffb0 [ID=12]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
   val SU(11): Latency=1

SU(13): 0x2ea9d80: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84040, 0x2e5c478 [ORD=65] [ID=13]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
   ch  SU(8): Latency=1

SU(14): 0x2eaa280: i64 = SUBREG_TO_REG 0x2e84040, 0x2e7fab0, 0x2e84940 [ID=14]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
   val SU(15): Latency=1
  Successors:
   val SU(8): Latency=1

SU(15): 0x2e7fab0: i32 = MOV32ri64 0x2e7fcb0 [ID=15]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
   val SU(14): Latency=1

SU(16): 0x2ea9b80: i64 = MOV64ri 0x2ea9780 [ORD=69] [ID=16]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
   val SU(1): Latency=1


Examining Available:
Height 0: SU(0): 0x2ea9e80: ch = RET 0x2e7f8b0:1 [ORD=70] [ID=0]


*** Scheduling [0]: SU(0): 0x2ea9e80: ch = RET 0x2e7f8b0:1 [ORD=70] [ID=0]


Examining Available:
Height 1: SU(1): 0x2e7f8b0: i32,ch,glue = CopyFromReg 0x2e7feb0:1, 0x2e7f6b0, 0x2e7feb0:2 [ORD=69] [ID=1]

    0x2ea9980: ch,glue = CopyToReg 0x2e800b0:1, 0x2e7fbb0, 0x2e7f5b0 [ORD=69] [ID=1]

    0x2eaa8d0: ch,glue = CopyToReg 0x2ea9980, 0x2e84840, 0x2eaa380, 0x2ea9980:1 [ORD=69] [ID=1]

    0x2e84340: ch,glue = CopyToReg 0x2eaa8d0, 0x2e801b0, 0x2e83f40, 0x2eaa8d0:1 [ORD=69] [ID=1]

    0x2e7f3b0: ch,glue = CALL64r 0x2ea9b80, 0x2e7fbb0, 0x2e84840, 0x2e801b0, 0x2ea9880, 0x2e84340, 0x2e84340:1 [ORD=69] [ID=1]

    0x2e7feb0: i64,ch,glue = ADJCALLSTACKUP64 0x2e84040, 0x2e84040, 0x2e7f3b0, 0x2e7f3b0:1 [ORD=69] [ID=1]


*** Scheduling [1]: SU(1): 0x2e7f8b0: i32,ch,glue = CopyFromReg 0x2e7feb0:1, 0x2e7f6b0, 0x2e7feb0:2 [ORD=69] [ID=1]

    0x2ea9980: ch,glue = CopyToReg 0x2e800b0:1, 0x2e7fbb0, 0x2e7f5b0 [ORD=69] [ID=1]

    0x2eaa8d0: ch,glue = CopyToReg 0x2ea9980, 0x2e84840, 0x2eaa380, 0x2ea9980:1 [ORD=69] [ID=1]

    0x2e84340: ch,glue = CopyToReg 0x2eaa8d0, 0x2e801b0, 0x2e83f40, 0x2eaa8d0:1 [ORD=69] [ID=1]

    0x2e7f3b0: ch,glue = CALL64r 0x2ea9b80, 0x2e7fbb0, 0x2e84840, 0x2e801b0, 0x2ea9880, 0x2e84340, 0x2e84340:1 [ORD=69] [ID=1]

    0x2e7feb0: i64,ch,glue = ADJCALLSTACKUP64 0x2e84040, 0x2e84040, 0x2e7f3b0, 0x2e7f3b0:1 [ORD=69] [ID=1]


Examining Available:
Height 2: SU(2): 0x2e83f40: i8 = EXTRACT_SUBREG 0x2eaa480, 0x2e84140 [ID=2]

Height 2: SU(16): 0x2ea9b80: i64 = MOV64ri 0x2ea9780 [ORD=69] [ID=16]

Height 2: SU(5): 0x2e7f5b0: i64 = MOV64ri 0x2ea9f80 [ORD=69] [ID=5]

Height 2: SU(6): 0x2e800b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84040, 0x2e7fdb0 [ORD=69] [ID=6]


*** Scheduling [2]: SU(2): 0x2e83f40: i8 = EXTRACT_SUBREG 0x2eaa480, 0x2e84140 [ID=2]


Examining Available:
Height 3: SU(3): 0x2eaa480: i32,i32 = MOV32r0 [ID=3]

Height 2: SU(16): 0x2ea9b80: i64 = MOV64ri 0x2ea9780 [ORD=69] [ID=16]

Height 2: SU(5): 0x2e7f5b0: i64 = MOV64ri 0x2ea9f80 [ORD=69] [ID=5]

Height 2: SU(6): 0x2e800b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84040, 0x2e7fdb0 [ORD=69] [ID=6]


*** Scheduling [3]: SU(3): 0x2eaa480: i32,i32 = MOV32r0 [ID=3]


Examining Available:
Height 2: SU(16): 0x2ea9b80: i64 = MOV64ri 0x2ea9780 [ORD=69] [ID=16]

Height 2: SU(5): 0x2e7f5b0: i64 = MOV64ri 0x2ea9f80 [ORD=69] [ID=5]

Height 2: SU(6): 0x2e800b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84040, 0x2e7fdb0 [ORD=69] [ID=6]


*** Scheduling [4]: SU(16): 0x2ea9b80: i64 = MOV64ri 0x2ea9780 [ORD=69] [ID=16]


Examining Available:
Height 2: SU(5): 0x2e7f5b0: i64 = MOV64ri 0x2ea9f80 [ORD=69] [ID=5]

Height 2: SU(6): 0x2e800b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84040, 0x2e7fdb0 [ORD=69] [ID=6]


*** Scheduling [5]: SU(5): 0x2e7f5b0: i64 = MOV64ri 0x2ea9f80 [ORD=69] [ID=5]


Examining Available:
Height 2: SU(6): 0x2e800b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84040, 0x2e7fdb0 [ORD=69] [ID=6]


*** Scheduling [6]: SU(6): 0x2e800b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84040, 0x2e7fdb0 [ORD=69] [ID=6]


Examining Available:
Height 7: SU(7): 0x2e7fdb0: ch = MOV32mr 0x2ea9680, 0x2e84240, 0x2e83c40, 0x2e84640, 0x2ea9a80, 0x2eaa380, 0x2eaa080:1<Mem:ST4[%i.addr]> [ORD=67] [ID=7]


*** Scheduling [7]: SU(7): 0x2e7fdb0: ch = MOV32mr 0x2ea9680, 0x2e84240, 0x2e83c40, 0x2e84640, 0x2ea9a80, 0x2eaa380, 0x2eaa080:1<Mem:ST4[%i.addr]> [ORD=67] [ID=7]


Examining Available:
Height 8: SU(8): 0x2eaa080: i64,ch,glue = CopyFromReg 0x2e84740:1, 0x2e7f4b0, 0x2e84740:2 [ORD=65] [ID=8]

    0x2e83b40: ch,glue = CopyToReg 0x2ea9d80:1, 0x2e7fbb0, 0x2eaa180 [ORD=65] [ID=8]

    0x2ea9c80: ch,glue = CopyToReg 0x2e83b40, 0x2e7f7b0, 0x2e83e40, 0x2e83b40:1 [ORD=65] [ID=8]

    0x2e83d40: ch,glue = CALL64r 0x2eaa280, 0x2e7fbb0, 0x2e7f7b0, 0x2ea9880, 0x2ea9c80, 0x2ea9c80:1 [ORD=65] [ID=8]

    0x2e84740: i64,ch,glue = ADJCALLSTACKUP64 0x2e84040, 0x2e84040, 0x2e83d40, 0x2e83d40:1 [ORD=65] [ID=8]

Height 8: SU(4): 0x2eaa380: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=61] [ID=4]


*** Scheduling [8]: SU(8): 0x2eaa080: i64,ch,glue = CopyFromReg 0x2e84740:1, 0x2e7f4b0, 0x2e84740:2 [ORD=65] [ID=8]

    0x2e83b40: ch,glue = CopyToReg 0x2ea9d80:1, 0x2e7fbb0, 0x2eaa180 [ORD=65] [ID=8]

    0x2ea9c80: ch,glue = CopyToReg 0x2e83b40, 0x2e7f7b0, 0x2e83e40, 0x2e83b40:1 [ORD=65] [ID=8]

    0x2e83d40: ch,glue = CALL64r 0x2eaa280, 0x2e7fbb0, 0x2e7f7b0, 0x2ea9880, 0x2ea9c80, 0x2ea9c80:1 [ORD=65] [ID=8]

    0x2e84740: i64,ch,glue = ADJCALLSTACKUP64 0x2e84040, 0x2e84040, 0x2e83d40, 0x2e83d40:1 [ORD=65] [ID=8]


Examining Available:
Height 9: SU(14): 0x2eaa280: i64 = SUBREG_TO_REG 0x2e84040, 0x2e7fab0, 0x2e84940 [ID=14]

Height 9: SU(9): 0x2e83e40: i64 = SUBREG_TO_REG 0x2e84040, 0x2e84540, 0x2e84940 [ID=9]

Height 9: SU(11): 0x2eaa180: i64 = SUBREG_TO_REG 0x2e84040, 0x2e7f9b0, 0x2e84940 [ID=11]

Height 9: SU(13): 0x2ea9d80: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84040, 0x2e5c478 [ORD=65] [ID=13]

Height 8: SU(4): 0x2eaa380: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=61] [ID=4]


*** Scheduling [9]: SU(14): 0x2eaa280: i64 = SUBREG_TO_REG 0x2e84040, 0x2e7fab0, 0x2e84940 [ID=14]


Examining Available:
Height 10: SU(15): 0x2e7fab0: i32 = MOV32ri64 0x2e7fcb0 [ID=15]

Height 9: SU(9): 0x2e83e40: i64 = SUBREG_TO_REG 0x2e84040, 0x2e84540, 0x2e84940 [ID=9]

Height 9: SU(11): 0x2eaa180: i64 = SUBREG_TO_REG 0x2e84040, 0x2e7f9b0, 0x2e84940 [ID=11]

Height 9: SU(13): 0x2ea9d80: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84040, 0x2e5c478 [ORD=65] [ID=13]

Height 8: SU(4): 0x2eaa380: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=61] [ID=4]


*** Scheduling [10]: SU(15): 0x2e7fab0: i32 = MOV32ri64 0x2e7fcb0 [ID=15]


Examining Available:
Height 9: SU(9): 0x2e83e40: i64 = SUBREG_TO_REG 0x2e84040, 0x2e84540, 0x2e84940 [ID=9]

Height 9: SU(11): 0x2eaa180: i64 = SUBREG_TO_REG 0x2e84040, 0x2e7f9b0, 0x2e84940 [ID=11]

Height 9: SU(13): 0x2ea9d80: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84040, 0x2e5c478 [ORD=65] [ID=13]

Height 8: SU(4): 0x2eaa380: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=61] [ID=4]


*** Scheduling [11]: SU(9): 0x2e83e40: i64 = SUBREG_TO_REG 0x2e84040, 0x2e84540, 0x2e84940 [ID=9]


Examining Available:
Height 12: SU(10): 0x2e84540: i32 = MOV32ri64 0x2e84440 [ID=10]

Height 9: SU(11): 0x2eaa180: i64 = SUBREG_TO_REG 0x2e84040, 0x2e7f9b0, 0x2e84940 [ID=11]

Height 9: SU(13): 0x2ea9d80: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84040, 0x2e5c478 [ORD=65] [ID=13]

Height 8: SU(4): 0x2eaa380: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=61] [ID=4]


*** Scheduling [12]: SU(10): 0x2e84540: i32 = MOV32ri64 0x2e84440 [ID=10]


Examining Available:
Height 9: SU(11): 0x2eaa180: i64 = SUBREG_TO_REG 0x2e84040, 0x2e7f9b0, 0x2e84940 [ID=11]

Height 9: SU(13): 0x2ea9d80: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84040, 0x2e5c478 [ORD=65] [ID=13]

Height 8: SU(4): 0x2eaa380: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=61] [ID=4]


*** Scheduling [13]: SU(11): 0x2eaa180: i64 = SUBREG_TO_REG 0x2e84040, 0x2e7f9b0, 0x2e84940 [ID=11]


Examining Available:
Height 14: SU(12): 0x2e7f9b0: i32 = MOV32ri64 0x2e7ffb0 [ID=12]

Height 9: SU(13): 0x2ea9d80: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84040, 0x2e5c478 [ORD=65] [ID=13]

Height 8: SU(4): 0x2eaa380: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=61] [ID=4]


*** Scheduling [14]: SU(12): 0x2e7f9b0: i32 = MOV32ri64 0x2e7ffb0 [ID=12]


Examining Available:
Height 9: SU(13): 0x2ea9d80: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84040, 0x2e5c478 [ORD=65] [ID=13]

Height 8: SU(4): 0x2eaa380: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=61] [ID=4]


*** Scheduling [15]: SU(13): 0x2ea9d80: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84040, 0x2e5c478 [ORD=65] [ID=13]


Examining Available:
Height 8: SU(4): 0x2eaa380: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=61] [ID=4]


*** Scheduling [16]: SU(4): 0x2eaa380: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=61] [ID=4]

*** Final schedule ***
SU(4): 0x2eaa380: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=61] [ID=4]

SU(13): 0x2ea9d80: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84040, 0x2e5c478 [ORD=65] [ID=13]

SU(12): 0x2e7f9b0: i32 = MOV32ri64 0x2e7ffb0 [ID=12]

SU(11): 0x2eaa180: i64 = SUBREG_TO_REG 0x2e84040, 0x2e7f9b0, 0x2e84940 [ID=11]

SU(10): 0x2e84540: i32 = MOV32ri64 0x2e84440 [ID=10]

SU(9): 0x2e83e40: i64 = SUBREG_TO_REG 0x2e84040, 0x2e84540, 0x2e84940 [ID=9]

SU(15): 0x2e7fab0: i32 = MOV32ri64 0x2e7fcb0 [ID=15]

SU(14): 0x2eaa280: i64 = SUBREG_TO_REG 0x2e84040, 0x2e7fab0, 0x2e84940 [ID=14]

SU(8): 0x2eaa080: i64,ch,glue = CopyFromReg 0x2e84740:1, 0x2e7f4b0, 0x2e84740:2 [ORD=65] [ID=8]

    0x2e83b40: ch,glue = CopyToReg 0x2ea9d80:1, 0x2e7fbb0, 0x2eaa180 [ORD=65] [ID=8]

    0x2ea9c80: ch,glue = CopyToReg 0x2e83b40, 0x2e7f7b0, 0x2e83e40, 0x2e83b40:1 [ORD=65] [ID=8]

    0x2e83d40: ch,glue = CALL64r 0x2eaa280, 0x2e7fbb0, 0x2e7f7b0, 0x2ea9880, 0x2ea9c80, 0x2ea9c80:1 [ORD=65] [ID=8]

    0x2e84740: i64,ch,glue = ADJCALLSTACKUP64 0x2e84040, 0x2e84040, 0x2e83d40, 0x2e83d40:1 [ORD=65] [ID=8]

SU(7): 0x2e7fdb0: ch = MOV32mr 0x2ea9680, 0x2e84240, 0x2e83c40, 0x2e84640, 0x2ea9a80, 0x2eaa380, 0x2eaa080:1<Mem:ST4[%i.addr]> [ORD=67] [ID=7]

SU(6): 0x2e800b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84040, 0x2e7fdb0 [ORD=69] [ID=6]

SU(5): 0x2e7f5b0: i64 = MOV64ri 0x2ea9f80 [ORD=69] [ID=5]

SU(16): 0x2ea9b80: i64 = MOV64ri 0x2ea9780 [ORD=69] [ID=16]

SU(3): 0x2eaa480: i32,i32 = MOV32r0 [ID=3]

SU(2): 0x2e83f40: i8 = EXTRACT_SUBREG 0x2eaa480, 0x2e84140 [ID=2]

SU(1): 0x2e7f8b0: i32,ch,glue = CopyFromReg 0x2e7feb0:1, 0x2e7f6b0, 0x2e7feb0:2 [ORD=69] [ID=1]

    0x2ea9980: ch,glue = CopyToReg 0x2e800b0:1, 0x2e7fbb0, 0x2e7f5b0 [ORD=69] [ID=1]

    0x2eaa8d0: ch,glue = CopyToReg 0x2ea9980, 0x2e84840, 0x2eaa380, 0x2ea9980:1 [ORD=69] [ID=1]

    0x2e84340: ch,glue = CopyToReg 0x2eaa8d0, 0x2e801b0, 0x2e83f40, 0x2eaa8d0:1 [ORD=69] [ID=1]

    0x2e7f3b0: ch,glue = CALL64r 0x2ea9b80, 0x2e7fbb0, 0x2e84840, 0x2e801b0, 0x2ea9880, 0x2e84340, 0x2e84340:1 [ORD=69] [ID=1]

    0x2e7feb0: i64,ch,glue = ADJCALLSTACKUP64 0x2e84040, 0x2e84040, 0x2e7f3b0, 0x2e7f3b0:1 [ORD=69] [ID=1]

SU(0): 0x2ea9e80: ch = RET 0x2e7f8b0:1 [ORD=70] [ID=0]


Total amount of phi nodes to update: 0
# Machine code for function func: SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
48B		%vreg1<def> = MOV32ri64 48717472; GR32:%vreg1
64B		%vreg2<def> = SUBREG_TO_REG 0, %vreg1<kill>, 4; GR64:%vreg2 GR32:%vreg1
80B		%vreg3<def> = MOV32ri64 48397984; GR32:%vreg3
96B		%vreg4<def> = SUBREG_TO_REG 0, %vreg3<kill>, 4; GR64:%vreg4 GR32:%vreg3
112B		%vreg5<def> = MOV32ri64 8971440; GR32:%vreg5
128B		%vreg6<def> = SUBREG_TO_REG 0, %vreg5<kill>, 4; GR64:%vreg6 GR32:%vreg5
144B		%RDI<def> = COPY %vreg2; GR64:%vreg2
160B		%RSI<def> = COPY %vreg4; GR64:%vreg4
176B		CALL64r %vreg6<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def>; GR64:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		%vreg7<def> = COPY %RAX; GR64:%vreg7
224B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
240B		ADJCALLSTACKDOWN64 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg8<def> = MOV64ri <ga:@.str>; GR64:%vreg8
272B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
288B		%vreg10<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
304B		%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
320B		%RDI<def> = COPY %vreg8; GR64:%vreg8
336B		%ESI<def> = COPY %vreg0; GR32:%vreg0
352B		%AL<def> = COPY %vreg11; GR8:%vreg11
368B		CALL64r %vreg9<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def>; GR64:%vreg9
384B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
400B		%vreg12<def> = COPY %EAX; GR32:%vreg12
416B		RET

# End machine code for function func.

********** Stack Coloring **********
********** Function: func
Found 0 markers and 1 slots
Slot structure:
Slot #0 - 4 bytes.
Total Stack size: 4 bytes

Will not try to merge slots.
Removed 0 markers.
DeadMachineInstructionElim: DELETING: %vreg12<def> = COPY %EAX; GR32:%vreg12
DeadMachineInstructionElim: DELETING: %vreg7<def> = COPY %RAX; GR64:%vreg7
******** Pre-regalloc Machine LICM: func ********
Entering: entry
Exiting: entry
******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: func
********** PROCESS IMPLICIT DEFS **********
********** Function: func
********** REWRITING TWO-ADDR INSTRS **********
********** Function: func
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI<kill>; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
48B		%vreg1<def> = MOV32ri64 48717472; GR32:%vreg1
64B		%vreg2<def> = SUBREG_TO_REG 0, %vreg1<kill>, 4; GR64:%vreg2 GR32:%vreg1
80B		%vreg3<def> = MOV32ri64 48397984; GR32:%vreg3
96B		%vreg4<def> = SUBREG_TO_REG 0, %vreg3<kill>, 4; GR64:%vreg4 GR32:%vreg3
112B		%vreg5<def> = MOV32ri64 8971440; GR32:%vreg5
128B		%vreg6<def> = SUBREG_TO_REG 0, %vreg5<kill>, 4; GR64:%vreg6 GR32:%vreg5
144B		%RDI<def> = COPY %vreg2<kill>; GR64:%vreg2
160B		%RSI<def> = COPY %vreg4<kill>; GR64:%vreg4
176B		CALL64r %vreg6<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use,kill>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
240B		%vreg8<def> = MOV64ri <ga:@.str>; GR64:%vreg8
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
272B		%vreg10<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
288B		%vreg11<def> = COPY %vreg10:sub_8bit<kill>; GR8:%vreg11 GR32:%vreg10
304B		%RDI<def> = COPY %vreg8<kill>; GR64:%vreg8
320B		%ESI<def> = COPY %vreg0<kill>; GR32:%vreg0
336B		%AL<def> = COPY %vreg11<kill>; GR8:%vreg11
352B		CALL64r %vreg9<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use,kill>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

Computing live-in reg-units in ABI blocks.
0B	BB#0 DIL#0
Created 1 new intervals.
********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
%vreg0 [16r,320r:0)  0@16r
%vreg1 [48r,64r:0)  0@48r
%vreg2 [64r,144r:0)  0@64r
%vreg3 [80r,96r:0)  0@80r
%vreg4 [96r,160r:0)  0@96r
%vreg5 [112r,128r:0)  0@112r
%vreg6 [128r,176r:0)  0@128r
%vreg8 [240r,304r:0)  0@240r
%vreg9 [256r,352r:0)  0@256r
%vreg10 [272r,288r:0)  0@272r
%vreg11 [288r,336r:0)  0@288r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
48B		%vreg1<def> = MOV32ri64 48717472; GR32:%vreg1
64B		%vreg2<def> = SUBREG_TO_REG 0, %vreg1, 4; GR64:%vreg2 GR32:%vreg1
80B		%vreg3<def> = MOV32ri64 48397984; GR32:%vreg3
96B		%vreg4<def> = SUBREG_TO_REG 0, %vreg3, 4; GR64:%vreg4 GR32:%vreg3
112B		%vreg5<def> = MOV32ri64 8971440; GR32:%vreg5
128B		%vreg6<def> = SUBREG_TO_REG 0, %vreg5, 4; GR64:%vreg6 GR32:%vreg5
144B		%RDI<def> = COPY %vreg2; GR64:%vreg2
160B		%RSI<def> = COPY %vreg4; GR64:%vreg4
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
240B		%vreg8<def> = MOV64ri <ga:@.str>; GR64:%vreg8
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
272B		%vreg10<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
288B		%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
304B		%RDI<def> = COPY %vreg8; GR64:%vreg8
320B		%ESI<def> = COPY %vreg0; GR32:%vreg0
336B		%AL<def> = COPY %vreg11; GR8:%vreg11
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

********** SIMPLE REGISTER COALESCING **********
********** Function: func
********** JOINING INTERVALS ***********
entry:
16B	%vreg0<def> = COPY %EDI; GR32:%vreg0
	Considering merging %vreg0 with %EDI
	Can only merge into reserved registers.
64B	%vreg2<def> = SUBREG_TO_REG 0, %vreg1, 4; GR64:%vreg2 GR32:%vreg1
	Considering merging to GR64_with_sub_8bit with %vreg1 in %vreg2:sub_32bit
		RHS = %vreg1 [48r,64r:0)  0@48r
		LHS = %vreg2 [64r,144r:0)  0@64r
		merge %vreg2:0@64r into %vreg1:0@48r --> @48r
		erased:	64r	%vreg2<def> = SUBREG_TO_REG 0, %vreg1, 4; GR64:%vreg2 GR32:%vreg1
		updated: 48B	%vreg2:sub_32bit<def,read-undef> = MOV32ri64 48717472; GR64_with_sub_8bit:%vreg2
	Joined. Result = %vreg2 [48r,144r:0)  0@48r
96B	%vreg4<def> = SUBREG_TO_REG 0, %vreg3, 4; GR64:%vreg4 GR32:%vreg3
	Considering merging to GR64_with_sub_8bit with %vreg3 in %vreg4:sub_32bit
		RHS = %vreg3 [80r,96r:0)  0@80r
		LHS = %vreg4 [96r,160r:0)  0@96r
		merge %vreg4:0@96r into %vreg3:0@80r --> @80r
		erased:	96r	%vreg4<def> = SUBREG_TO_REG 0, %vreg3, 4; GR64:%vreg4 GR32:%vreg3
		updated: 80B	%vreg4:sub_32bit<def,read-undef> = MOV32ri64 48397984; GR64_with_sub_8bit:%vreg4
	Joined. Result = %vreg4 [80r,160r:0)  0@80r
128B	%vreg6<def> = SUBREG_TO_REG 0, %vreg5, 4; GR64:%vreg6 GR32:%vreg5
	Considering merging to GR64_with_sub_8bit with %vreg5 in %vreg6:sub_32bit
		RHS = %vreg5 [112r,128r:0)  0@112r
		LHS = %vreg6 [128r,176r:0)  0@128r
		merge %vreg6:0@128r into %vreg5:0@112r --> @112r
		erased:	128r	%vreg6<def> = SUBREG_TO_REG 0, %vreg5, 4; GR64:%vreg6 GR32:%vreg5
		updated: 112B	%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
	Joined. Result = %vreg6 [112r,176r:0)  0@112r
144B	%RDI<def> = COPY %vreg2; GR64_with_sub_8bit:%vreg2
	Considering merging %vreg2 with %RDI
	Can only merge into reserved registers.
Remat: %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
Shrink: %vreg2 [48r,144r:0)  0@48r
All defs dead: 48r	%vreg2:sub_32bit<def,read-undef,dead> = MOV32ri64 48717472; GR64_with_sub_8bit:%vreg2
Shrunk: %vreg2 [48r,48d:0)  0@48r
Deleting dead def 48r	%vreg2:sub_32bit<def,read-undef,dead> = MOV32ri64 48717472; GR64_with_sub_8bit:%vreg2
160B	%RSI<def> = COPY %vreg4; GR64_with_sub_8bit:%vreg4
	Considering merging %vreg4 with %RSI
	Can only merge into reserved registers.
Remat: %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
Shrink: %vreg4 [80r,160r:0)  0@80r
All defs dead: 80r	%vreg4:sub_32bit<def,read-undef,dead> = MOV32ri64 48397984; GR64_with_sub_8bit:%vreg4
Shrunk: %vreg4 [80r,80d:0)  0@80r
Deleting dead def 80r	%vreg4:sub_32bit<def,read-undef,dead> = MOV32ri64 48397984; GR64_with_sub_8bit:%vreg4
304B	%RDI<def> = COPY %vreg8; GR64:%vreg8
	Considering merging %vreg8 with %RDI
	Can only merge into reserved registers.
Remat: %RDI<def> = MOV64ri <ga:@.str>
Shrink: %vreg8 [240r,304r:0)  0@240r
All defs dead: 240r	%vreg8<def,dead> = MOV64ri <ga:@.str>; GR64:%vreg8
Shrunk: %vreg8 [240r,240d:0)  0@240r
Deleting dead def 240r	%vreg8<def,dead> = MOV64ri <ga:@.str>; GR64:%vreg8
320B	%ESI<def> = COPY %vreg0; GR32:%vreg0
	Considering merging %vreg0 with %ESI
	Can only merge into reserved registers.
336B	%AL<def> = COPY %vreg11; GR8:%vreg11
	Considering merging %vreg11 with %AL
	Can only merge into reserved registers.
288B	%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
	Considering merging to GR32 with %vreg11 in %vreg10:sub_8bit
		RHS = %vreg11 [288r,336r:0)  0@288r
		LHS = %vreg10 [272r,288r:0)  0@272r
		merge %vreg11:0@288r into %vreg10:0@272r --> @272r
		erased:	288r	%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
		updated: 336B	%AL<def> = COPY %vreg10:sub_8bit; GR32:%vreg10
	Joined. Result = %vreg10 [272r,336r:0)  0@272r
320B	%ESI<def> = COPY %vreg0; GR32:%vreg0
	Considering merging %vreg0 with %ESI
	Can only merge into reserved registers.
336B	%AL<def> = COPY %vreg10:sub_8bit; GR32:%vreg10
	Considering merging %vreg10 with %EAX
	Can only merge into reserved registers.
Remat: %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
Shrink: %vreg10 [272r,336r:0)  0@272r
All defs dead: 272r	%vreg10<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
Shrunk: %vreg10 [272r,272d:0)  0@272r
Deleting dead def 272r	%vreg10<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
320B	%ESI<def> = COPY %vreg0; GR32:%vreg0
	Considering merging %vreg0 with %ESI
	Can only merge into reserved registers.
Trying to inflate 0 regs.
********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
%vreg0 [16r,320r:0)  0@16r
%vreg6 [112r,176r:0)  0@112r
%vreg9 [256r,352r:0)  0@256r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
320B		%ESI<def> = COPY %vreg0; GR32:%vreg0
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

Before MISsched:
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

BB#0: derived from LLVM BB %entry
    Live Ins: %EDI
	%vreg0<def> = COPY %EDI; GR32:%vreg0
	ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
	%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
	%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
	CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
	ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
	ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
	%RDI<def> = MOV64ri <ga:@.str>
	%ESI<def> = COPY %vreg0; GR32:%vreg0
	%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
	CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
	ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	RET

# End machine code for function func.

********** MI Scheduling **********
func:BB#0 entry
  From: %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
    To: CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
 RegionInstrs: 4 Remaining: 9
Disabled scoreboard hazard recognizer
Disabled scoreboard hazard recognizer
SU(0):   %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   val SU(4294967295): Latency=1 Reg=%vreg9

SU(1):   %RDI<def> = MOV64ri <ga:@.str>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

SU(2):   %ESI<def> = COPY %vreg0; GR32:%vreg0
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
   ch  SU(4294967295) *: Latency=0

SU(3):   %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

Critical Path: 1
BotQ.A: 0 3 2 1 
  SU(0) ORDER                              
  SU(3) ORDER                              
  SU(2) PREG-COPY                         
Pick Bot PREG-COPY
Scheduling SU(2) %ESI<def> = COPY %vreg0; GR32:%vreg0
handleMove 320B -> 344B: %ESI<def> = COPY %vreg0; GR32:%vreg0
     SIL:	[160r,176r:0)[344r,352r:1)  0@160r 1@344r
        -->	[160r,176r:0)[344r,352r:1)  0@160r 1@344r
     %vreg0:	[16r,320r:0)  0@16r
        -->	[16r,344r:0)  0@16r
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
BotQ.A: 0 3 1 
  SU(0) ORDER                              
  SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
  Ready @1c
  BotQ.A BotLatency SU(3) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
BotQ.A: 0 1 
  SU(0) ORDER                              
  SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %RDI<def> = MOV64ri <ga:@.str>
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
Scheduling SU(0) %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
*** Final schedule for BB#0 ***
SU(0):   %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
SU(1):   %RDI<def> = MOV64ri <ga:@.str>
SU(3):   %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
SU(2):   %ESI<def> = COPY %vreg0; GR32:%vreg0

********** MI Scheduling **********
func:BB#0 entry
  From: %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
    To: CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
 RegionInstrs: 3 Remaining: 2
SU(0):   %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   val SU(4294967295): Latency=1 Reg=%vreg6

SU(1):   %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

SU(2):   %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

Critical Path: 1
BotQ.A: 0 2 1 
  SU(0) ORDER                              
  SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
  Ready @1c
  SBPort015 +1x4u
  *** Critical resource SBPort015: 0c
  SBPortAny +1x2u
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
BotQ.A: 0 1 
  SU(0) ORDER                              
  SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
Scheduling SU(0) %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 3
  Executed: 1c
  Critical: 1c, 3 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
*** Final schedule for BB#0 ***
SU(0):   %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
SU(1):   %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
SU(2):   %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>

********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
SIL [160r,176r:0)[344r,352r:1)  0@160r 1@344r
%vreg0 [16r,344r:0)  0@16r
%vreg6 [112r,176r:0)  0@112r
%vreg9 [256r,352r:0)  0@256r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
344B		%ESI<def> = COPY %vreg0; GR32:%vreg0
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

RPO[BB#0 derived from LLVM BB entry] = 1
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#0 derived from LLVM BB entry)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0.0
Frequency(BB#0 derived from LLVM BB entry) = 1.0
LoopExitProb[BB#0 derived from LLVM BB entry] = 16383 / 16384 = 99.9939% from 1 - 0.0 / 1.0.
********** COMPUTING LIVE DEBUG VARIABLES: func **********
********** DEBUG VARIABLES **********
********** GREEDY REGISTER ALLOCATION **********
********** Function: func
********** Compute Spill Weights **********
********** Function: func
********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
SIL [160r,176r:0)[344r,352r:1)  0@160r 1@344r
%vreg0 [16r,344r:0)  0@16r
%vreg6 [112r,176r:0)  0@112r
%vreg9 [256r,352r:0)  0@256r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
344B		%ESI<def> = COPY %vreg0; GR32:%vreg0
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.


selectOrSplit GR32:%vreg0 [16r,344r:0)  0@16r
hints: %EDI
missed hint %EDI
assigning %vreg0 to %EBX: BH BL

selectOrSplit GR64_with_sub_8bit:%vreg6 [112r,176r:0)  0@112r
assigning %vreg6 to %RAX: AH AL

selectOrSplit GR64:%vreg9 [256r,352r:0)  0@256r
assigning %vreg9 to %RCX: CH CL
********** REWRITE VIRTUAL REGISTERS **********
********** Function: func
********** REGISTER MAP **********
[%vreg0 -> %EBX] GR32
[%vreg6 -> %RAX] GR64_with_sub_8bit
[%vreg9 -> %RCX] GR64

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
344B		%ESI<def> = COPY %vreg0<kill>; GR32:%vreg0
352B		CALL64r %vreg9<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET
> %EBX<def> = COPY %EDI
> ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> %EAX<def> = MOV32ri64 8971440, %RAX<imp-def>
> %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
> %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
> CALL64r %RAX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>
> ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %EBX; mem:ST4[%i.addr]
> ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> %RCX<def> = MOV64ri <ga:@printf>
> %RDI<def> = MOV64ri <ga:@.str>
> %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
> %ESI<def> = COPY %EBX<kill>
> CALL64r %RCX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def,dead>
> ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> RET
********** EMITTING LIVE DEBUG VARIABLES **********
********** Stack Slot Coloring **********
********** Function: func
******** Post-regalloc Machine LICM: func ********

Setting up live-ins for BB#0 derived from entry.
Block has no FP live-ins.

FPInst:	RET
Stack contents:
Inserted instructions:
	RET
Stack contents:
alloc FI(0) at SP[-28]
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: func
real copy:   %EBX<def> = COPY %EDI
replaced by: %EBX<def> = MOV32rr %EDI
real copy:   %ESI<def> = COPY %EBX<kill>
replaced by: %ESI<def> = MOV32rr %EBX<kill>
RPO[BB#0 derived from LLVM BB entry] = 1
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#0 derived from LLVM BB entry)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0.0
Frequency(BB#0 derived from LLVM BB entry) = 1.0
LoopExitProb[BB#0 derived from LLVM BB entry] = 16383 / 16384 = 99.9939% from 1 - 0.0 / 1.0.
********** FIX EXECUTION DEPENDENCIES: VR128 **********
BB#0: entry
JITTing function 'func'
JIT: Starting CodeGen of Function func
JIT: Emitting BB0 at [0x7f7e4367b1f0]
PUSH64r %RBP<kill>, %RSP<imp-def>, %RSP<imp-use>; flags: FrameSetup
PROLOG_LABEL <MCSym=.Ltmp18>
%RBP<def> = MOV64rr %RSP; flags: FrameSetup
PROLOG_LABEL <MCSym=.Ltmp19>
PUSH64r %RBX<kill>, %RSP<imp-def>, %RSP<imp-use>; flags: FrameSetup
PUSH64r %RAX<undef>, %RSP<imp-def>, %RSP<imp-use>; flags: FrameSetup
PROLOG_LABEL <MCSym=.Ltmp20>
%EBX<def> = MOV32rr %EDI
%EAX<def> = MOV32ri64 8971440, %RAX<imp-def>
%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
CALL64r %RAX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>
MOV32mr %RBP, 1, %noreg, -12, %noreg, %EBX; mem:ST4[%i.addr]
%RCX<def> = MOV64ri <ga:@printf>
%RDI<def> = MOV64ri <ga:@.str>
%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
%ESI<def> = MOV32rr %EBX<kill>
CALL64r %RCX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def,dead>
%RSP<def,tied1> = ADD64ri8 %RSP<tied0>, 8, %EFLAGS<imp-def,dead>
%RBX<def> = POP64r %RSP<imp-def>, %RSP<imp-use>
%RBP<def> = POP64r %RSP<imp-def>, %RSP<imp-use>
RET
JIT: Finished CodeGen of [0x7f7e4367b1f0] Function: func: 61 bytes of text, 2 relocations
JIT: Binary code:
JIT: 0: 2291377285 2511378083 136228176184 941601910 
JIT: 16: 1601902231 2552226126 24493137208 24324018572 
JIT: 32: 05350132 1917200 6710217616 00127126 
JIT: 48: 22213719249 13172209255 93918196 195
Inside Func callback func
JIT: Map 'func' to [0x0]
CGP: Found      local addrmode: [Base:%i.addr]
CGP: Found      local addrmode: [Base:%i.addr]
Computing probabilities for entry



=== func
Initial selection DAG: BB#0 'func:entry'
SelectionDAG has 37 nodes:
  0x2e5c478: ch = EntryToken

  0x2e84540: i64 = TargetConstant<0>

  0x2e84140: i64 = Register %RDI

      0x2e5c478: <multiple use>
      0x2e84540: <multiple use>
    0x2e84440: ch,glue = callseq_start 0x2e5c478, 0x2e84540 [ORD=74]

    0x2e84140: <multiple use>
    0x2e7ffb0: i64 = Constant<48717472>

  0x2eaa480: ch,glue = CopyToReg 0x2e84440, 0x2e84140, 0x2e7ffb0 [ORD=74]

  0x2ea9a80: i64 = Register %RSI

    0x2eaa480: <multiple use>
    0x2ea9a80: <multiple use>
    0x2e84940: i64 = Constant<48397984>

    0x2eaa480: <multiple use>
  0x2e84640: ch,glue = CopyToReg 0x2eaa480, 0x2ea9a80, 0x2e84940, 0x2eaa480:1 [ORD=74]

  0x2e84240: Untyped = RegisterMask

    0x2e84640: <multiple use>
    0x2e7f9b0: i64 = Constant<8971440>

    0x2e84140: <multiple use>
    0x2ea9a80: <multiple use>
    0x2e84240: <multiple use>
    0x2e84640: <multiple use>
  0x2ea9680: ch,glue = X86ISD::CALL 0x2e84640, 0x2e7f9b0, 0x2e84140, 0x2ea9a80, 0x2e84240, 0x2e84640:1 [ORD=74]

    0x2ea9680: <multiple use>
    0x2e84540: <multiple use>
    0x2e84540: <multiple use>
    0x2ea9680: <multiple use>
  0x2e83c40: ch,glue = callseq_end 0x2ea9680, 0x2e84540, 0x2e84540, 0x2ea9680:1 [ORD=74]

  0x2e7feb0: i64 = FrameIndex<0>

  0x2e7f3b0: i64 = Constant<0>

  0x2e84340: i64 = undef

        0x2e83c40: <multiple use>
        0x2ea9e80: i64 = Register %RAX

        0x2e83c40: <multiple use>
      0x2e7f8b0: i64,ch,glue = CopyFromReg 0x2e83c40, 0x2ea9e80, 0x2e83c40:1 [ORD=74]

        0x2e5c478: <multiple use>
        0x2e7fab0: i32 = Register %vreg0

      0x2e7fcb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=70]

      0x2e7feb0: <multiple use>
      0x2e84340: <multiple use>
    0x2eaa8d0: ch = store 0x2e7f8b0:1, 0x2e7fcb0, 0x2e7feb0, 0x2e84340<ST4[%i.addr]> [ORD=76]

    0x2e7feb0: <multiple use>
    0x2e84340: <multiple use>
  0x2ea9980: i32,ch = load 0x2eaa8d0, 0x2e7feb0, 0x2e84340<LD4[%i.addr]> [ORD=77]

      0x2ea9980: <multiple use>
      0x2e84540: <multiple use>
    0x2eaa080: ch,glue = callseq_start 0x2ea9980:1, 0x2e84540 [ORD=78]

    0x2e84140: <multiple use>
    0x2e7fdb0: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=78]

  0x2e83d40: ch,glue = CopyToReg 0x2eaa080, 0x2e84140, 0x2e7fdb0 [ORD=78]

  0x2ea9c80: i32 = Register %ESI

    0x2e83d40: <multiple use>
    0x2ea9c80: <multiple use>
    0x2ea9980: <multiple use>
    0x2e83d40: <multiple use>
  0x2e83b40: ch,glue = CopyToReg 0x2e83d40, 0x2ea9c80, 0x2ea9980, 0x2e83d40:1 [ORD=78]

  0x2ea9b80: i8 = Register %AL

    0x2e83b40: <multiple use>
    0x2ea9b80: <multiple use>
    0x2e84740: i8 = Constant<0>

    0x2e83b40: <multiple use>
  0x2e7f5b0: ch,glue = CopyToReg 0x2e83b40, 0x2ea9b80, 0x2e84740, 0x2e83b40:1 [ORD=78]

    0x2e7f5b0: <multiple use>
    0x2e800b0: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=78]

    0x2e84140: <multiple use>
    0x2ea9c80: <multiple use>
    0x2ea9b80: <multiple use>
    0x2e84240: <multiple use>
    0x2e7f5b0: <multiple use>
  0x2ea9d80: ch,glue = X86ISD::CALL 0x2e7f5b0, 0x2e800b0, 0x2e84140, 0x2ea9c80, 0x2ea9b80, 0x2e84240, 0x2e7f5b0:1 [ORD=78]

    0x2ea9d80: <multiple use>
    0x2e84540: <multiple use>
    0x2e84540: <multiple use>
    0x2ea9d80: <multiple use>
  0x2eaa380: ch,glue = callseq_end 0x2ea9d80, 0x2e84540, 0x2e84540, 0x2ea9d80:1 [ORD=78]

      0x2eaa380: <multiple use>
      0x2ea9780: i32 = Register %EAX

      0x2eaa380: <multiple use>
    0x2ea9f80: i32,ch,glue = CopyFromReg 0x2eaa380, 0x2ea9780, 0x2eaa380:1 [ORD=78]

    0x2e7f6b0: i16 = TargetConstant<0>

  0x2e801b0: ch = X86ISD::RET_FLAG 0x2ea9f80:1, 0x2e7f6b0 [ORD=79]



Replacing.1 0x2ea9980: i32,ch = load 0x2eaa8d0, 0x2e7feb0, 0x2e84340<LD4[%i.addr]> [ORD=77]

With: 0x2e7fcb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=70]
 and 1 other values
Optimized lowered selection DAG: BB#0 'func:entry'
SelectionDAG has 35 nodes:
  0x2e5c478: ch = EntryToken

    0x2e5c478: <multiple use>
    0x2e7fab0: i32 = Register %vreg0

  0x2e7fcb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=70]

  0x2e84540: i64 = TargetConstant<0>

  0x2e84140: i64 = Register %RDI

      0x2e5c478: <multiple use>
      0x2e84540: <multiple use>
    0x2e84440: ch,glue = callseq_start 0x2e5c478, 0x2e84540 [ORD=74]

    0x2e84140: <multiple use>
    0x2e7ffb0: i64 = Constant<48717472>

  0x2eaa480: ch,glue = CopyToReg 0x2e84440, 0x2e84140, 0x2e7ffb0 [ORD=74]

  0x2ea9a80: i64 = Register %RSI

    0x2eaa480: <multiple use>
    0x2ea9a80: <multiple use>
    0x2e84940: i64 = Constant<48397984>

    0x2eaa480: <multiple use>
  0x2e84640: ch,glue = CopyToReg 0x2eaa480, 0x2ea9a80, 0x2e84940, 0x2eaa480:1 [ORD=74]

  0x2e84240: Untyped = RegisterMask

    0x2e84640: <multiple use>
    0x2e7f9b0: i64 = Constant<8971440>

    0x2e84140: <multiple use>
    0x2ea9a80: <multiple use>
    0x2e84240: <multiple use>
    0x2e84640: <multiple use>
  0x2ea9680: ch,glue = X86ISD::CALL 0x2e84640, 0x2e7f9b0, 0x2e84140, 0x2ea9a80, 0x2e84240, 0x2e84640:1 [ORD=74]

    0x2ea9680: <multiple use>
    0x2e84540: <multiple use>
    0x2e84540: <multiple use>
    0x2ea9680: <multiple use>
  0x2e83c40: ch,glue = callseq_end 0x2ea9680, 0x2e84540, 0x2e84540, 0x2ea9680:1 [ORD=74]

          0x2e83c40: <multiple use>
          0x2ea9e80: i64 = Register %RAX

          0x2e83c40: <multiple use>
        0x2e7f8b0: i64,ch,glue = CopyFromReg 0x2e83c40, 0x2ea9e80, 0x2e83c40:1 [ORD=74]

        0x2e7fcb0: <multiple use>
        0x2e7feb0: i64 = FrameIndex<0>

        0x2e84340: i64 = undef

      0x2eaa8d0: ch = store 0x2e7f8b0:1, 0x2e7fcb0, 0x2e7feb0, 0x2e84340<ST4[%i.addr]> [ORD=76]

      0x2e84540: <multiple use>
    0x2eaa080: ch,glue = callseq_start 0x2eaa8d0, 0x2e84540 [ORD=78]

    0x2e84140: <multiple use>
    0x2e7fdb0: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=78]

  0x2e83d40: ch,glue = CopyToReg 0x2eaa080, 0x2e84140, 0x2e7fdb0 [ORD=78]

  0x2ea9c80: i32 = Register %ESI

    0x2e83d40: <multiple use>
    0x2ea9c80: <multiple use>
    0x2e7fcb0: <multiple use>
    0x2e83d40: <multiple use>
  0x2e83b40: ch,glue = CopyToReg 0x2e83d40, 0x2ea9c80, 0x2e7fcb0, 0x2e83d40:1 [ORD=78]

  0x2ea9b80: i8 = Register %AL

    0x2e83b40: <multiple use>
    0x2ea9b80: <multiple use>
    0x2e84740: i8 = Constant<0>

    0x2e83b40: <multiple use>
  0x2e7f5b0: ch,glue = CopyToReg 0x2e83b40, 0x2ea9b80, 0x2e84740, 0x2e83b40:1 [ORD=78]

    0x2e7f5b0: <multiple use>
    0x2e800b0: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=78]

    0x2e84140: <multiple use>
    0x2ea9c80: <multiple use>
    0x2ea9b80: <multiple use>
    0x2e84240: <multiple use>
    0x2e7f5b0: <multiple use>
  0x2ea9d80: ch,glue = X86ISD::CALL 0x2e7f5b0, 0x2e800b0, 0x2e84140, 0x2ea9c80, 0x2ea9b80, 0x2e84240, 0x2e7f5b0:1 [ORD=78]

    0x2ea9d80: <multiple use>
    0x2e84540: <multiple use>
    0x2e84540: <multiple use>
    0x2ea9d80: <multiple use>
  0x2eaa380: ch,glue = callseq_end 0x2ea9d80, 0x2e84540, 0x2e84540, 0x2ea9d80:1 [ORD=78]

      0x2eaa380: <multiple use>
      0x2ea9780: i32 = Register %EAX

      0x2eaa380: <multiple use>
    0x2ea9f80: i32,ch,glue = CopyFromReg 0x2eaa380, 0x2ea9780, 0x2eaa380:1 [ORD=78]

    0x2e7f6b0: i16 = TargetConstant<0>

  0x2e801b0: ch = X86ISD::RET_FLAG 0x2ea9f80:1, 0x2e7f6b0 [ORD=79]


Legally typed node: 0x2e7f6b0: i16 = TargetConstant<0> [ID=0]

Legally typed node: 0x2ea9780: i32 = Register %EAX [ID=0]

Legally typed node: 0x2ea9b80: i8 = Register %AL [ID=0]

Legally typed node: 0x2ea9c80: i32 = Register %ESI [ID=0]

Legally typed node: 0x2e84740: i8 = Constant<0> [ID=0]

Legally typed node: 0x2e7fdb0: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=78] [ID=0]

Legally typed node: 0x2e800b0: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=78] [ID=0]

Legally typed node: 0x2e84340: i64 = undef [ID=0]

Legally typed node: 0x2e7feb0: i64 = FrameIndex<0> [ID=0]

Legally typed node: 0x2ea9e80: i64 = Register %RAX [ID=0]

Legally typed node: 0x2e84240: Untyped = RegisterMask [ID=0]

Legally typed node: 0x2ea9a80: i64 = Register %RSI [ID=0]

Legally typed node: 0x2e84140: i64 = Register %RDI [ID=0]

Legally typed node: 0x2e84540: i64 = TargetConstant<0> [ID=0]

Legally typed node: 0x2e84940: i64 = Constant<48397984> [ID=0]

Legally typed node: 0x2e7ffb0: i64 = Constant<48717472> [ID=0]

Legally typed node: 0x2e7f9b0: i64 = Constant<8971440> [ID=0]

Legally typed node: 0x2e7fab0: i32 = Register %vreg0 [ID=0]

Legally typed node: 0x2e5c478: ch = EntryToken [ID=0]

Legally typed node: 0x2e7fcb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=70] [ID=0]

Legally typed node: 0x2e84440: ch,glue = callseq_start 0x2e5c478, 0x2e84540 [ORD=74] [ID=0]

Legally typed node: 0x2eaa480: ch,glue = CopyToReg 0x2e84440, 0x2e84140, 0x2e7ffb0 [ORD=74] [ID=0]

Legally typed node: 0x2e84640: ch,glue = CopyToReg 0x2eaa480, 0x2ea9a80, 0x2e84940, 0x2eaa480:1 [ORD=74] [ID=0]

Legally typed node: 0x2ea9680: ch,glue = X86ISD::CALL 0x2e84640, 0x2e7f9b0, 0x2e84140, 0x2ea9a80, 0x2e84240, 0x2e84640:1 [ORD=74] [ID=0]

Legally typed node: 0x2e83c40: ch,glue = callseq_end 0x2ea9680, 0x2e84540, 0x2e84540, 0x2ea9680:1 [ORD=74] [ID=0]

Legally typed node: 0x2e7f8b0: i64,ch,glue = CopyFromReg 0x2e83c40, 0x2ea9e80, 0x2e83c40:1 [ORD=74] [ID=0]

Legally typed node: 0x2eaa8d0: ch = store 0x2e7f8b0:1, 0x2e7fcb0, 0x2e7feb0, 0x2e84340<ST4[%i.addr]> [ORD=76] [ID=0]

Legally typed node: 0x2eaa080: ch,glue = callseq_start 0x2eaa8d0, 0x2e84540 [ORD=78] [ID=0]

Legally typed node: 0x2e83d40: ch,glue = CopyToReg 0x2eaa080, 0x2e84140, 0x2e7fdb0 [ORD=78] [ID=0]

Legally typed node: 0x2e83b40: ch,glue = CopyToReg 0x2e83d40, 0x2ea9c80, 0x2e7fcb0, 0x2e83d40:1 [ORD=78] [ID=0]

Legally typed node: 0x2e7f5b0: ch,glue = CopyToReg 0x2e83b40, 0x2ea9b80, 0x2e84740, 0x2e83b40:1 [ORD=78] [ID=0]

Legally typed node: 0x2ea9d80: ch,glue = X86ISD::CALL 0x2e7f5b0, 0x2e800b0, 0x2e84140, 0x2ea9c80, 0x2ea9b80, 0x2e84240, 0x2e7f5b0:1 [ORD=78] [ID=0]

Legally typed node: 0x2eaa380: ch,glue = callseq_end 0x2ea9d80, 0x2e84540, 0x2e84540, 0x2ea9d80:1 [ORD=78] [ID=0]

Legally typed node: 0x2ea9f80: i32,ch,glue = CopyFromReg 0x2eaa380, 0x2ea9780, 0x2eaa380:1 [ORD=78] [ID=0]

Legally typed node: 0x2e801b0: ch = X86ISD::RET_FLAG 0x2ea9f80:1, 0x2e7f6b0 [ORD=79] [ID=0]

Legally typed node: 0x7fff29e7ba10: ch = handlenode 0x2e801b0 [ID=0]

Type-legalized selection DAG: BB#0 'func:entry'
SelectionDAG has 35 nodes:
  0x2e5c478: ch = EntryToken [ID=-3]

    0x2e5c478: <multiple use>
    0x2e7fab0: i32 = Register %vreg0 [ID=-3]

  0x2e7fcb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=70] [ID=-3]

  0x2e84540: i64 = TargetConstant<0> [ID=-3]

  0x2e84140: i64 = Register %RDI [ID=-3]

      0x2e5c478: <multiple use>
      0x2e84540: <multiple use>
    0x2e84440: ch,glue = callseq_start 0x2e5c478, 0x2e84540 [ORD=74] [ID=-3]

    0x2e84140: <multiple use>
    0x2e7ffb0: i64 = Constant<48717472> [ID=-3]

  0x2eaa480: ch,glue = CopyToReg 0x2e84440, 0x2e84140, 0x2e7ffb0 [ORD=74] [ID=-3]

  0x2ea9a80: i64 = Register %RSI [ID=-3]

    0x2eaa480: <multiple use>
    0x2ea9a80: <multiple use>
    0x2e84940: i64 = Constant<48397984> [ID=-3]

    0x2eaa480: <multiple use>
  0x2e84640: ch,glue = CopyToReg 0x2eaa480, 0x2ea9a80, 0x2e84940, 0x2eaa480:1 [ORD=74] [ID=-3]

  0x2e84240: Untyped = RegisterMask [ID=-3]

    0x2e84640: <multiple use>
    0x2e7f9b0: i64 = Constant<8971440> [ID=-3]

    0x2e84140: <multiple use>
    0x2ea9a80: <multiple use>
    0x2e84240: <multiple use>
    0x2e84640: <multiple use>
  0x2ea9680: ch,glue = X86ISD::CALL 0x2e84640, 0x2e7f9b0, 0x2e84140, 0x2ea9a80, 0x2e84240, 0x2e84640:1 [ORD=74] [ID=-3]

    0x2ea9680: <multiple use>
    0x2e84540: <multiple use>
    0x2e84540: <multiple use>
    0x2ea9680: <multiple use>
  0x2e83c40: ch,glue = callseq_end 0x2ea9680, 0x2e84540, 0x2e84540, 0x2ea9680:1 [ORD=74] [ID=-3]

          0x2e83c40: <multiple use>
          0x2ea9e80: i64 = Register %RAX [ID=-3]

          0x2e83c40: <multiple use>
        0x2e7f8b0: i64,ch,glue = CopyFromReg 0x2e83c40, 0x2ea9e80, 0x2e83c40:1 [ORD=74] [ID=-3]

        0x2e7fcb0: <multiple use>
        0x2e7feb0: i64 = FrameIndex<0> [ID=-3]

        0x2e84340: i64 = undef [ID=-3]

      0x2eaa8d0: ch = store 0x2e7f8b0:1, 0x2e7fcb0, 0x2e7feb0, 0x2e84340<ST4[%i.addr]> [ORD=76] [ID=-3]

      0x2e84540: <multiple use>
    0x2eaa080: ch,glue = callseq_start 0x2eaa8d0, 0x2e84540 [ORD=78] [ID=-3]

    0x2e84140: <multiple use>
    0x2e7fdb0: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=78] [ID=-3]

  0x2e83d40: ch,glue = CopyToReg 0x2eaa080, 0x2e84140, 0x2e7fdb0 [ORD=78] [ID=-3]

  0x2ea9c80: i32 = Register %ESI [ID=-3]

    0x2e83d40: <multiple use>
    0x2ea9c80: <multiple use>
    0x2e7fcb0: <multiple use>
    0x2e83d40: <multiple use>
  0x2e83b40: ch,glue = CopyToReg 0x2e83d40, 0x2ea9c80, 0x2e7fcb0, 0x2e83d40:1 [ORD=78] [ID=-3]

  0x2ea9b80: i8 = Register %AL [ID=-3]

    0x2e83b40: <multiple use>
    0x2ea9b80: <multiple use>
    0x2e84740: i8 = Constant<0> [ID=-3]

    0x2e83b40: <multiple use>
  0x2e7f5b0: ch,glue = CopyToReg 0x2e83b40, 0x2ea9b80, 0x2e84740, 0x2e83b40:1 [ORD=78] [ID=-3]

    0x2e7f5b0: <multiple use>
    0x2e800b0: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=78] [ID=-3]

    0x2e84140: <multiple use>
    0x2ea9c80: <multiple use>
    0x2ea9b80: <multiple use>
    0x2e84240: <multiple use>
    0x2e7f5b0: <multiple use>
  0x2ea9d80: ch,glue = X86ISD::CALL 0x2e7f5b0, 0x2e800b0, 0x2e84140, 0x2ea9c80, 0x2ea9b80, 0x2e84240, 0x2e7f5b0:1 [ORD=78] [ID=-3]

    0x2ea9d80: <multiple use>
    0x2e84540: <multiple use>
    0x2e84540: <multiple use>
    0x2ea9d80: <multiple use>
  0x2eaa380: ch,glue = callseq_end 0x2ea9d80, 0x2e84540, 0x2e84540, 0x2ea9d80:1 [ORD=78] [ID=-3]

      0x2eaa380: <multiple use>
      0x2ea9780: i32 = Register %EAX [ID=-3]

      0x2eaa380: <multiple use>
    0x2ea9f80: i32,ch,glue = CopyFromReg 0x2eaa380, 0x2ea9780, 0x2eaa380:1 [ORD=78] [ID=-3]

    0x2e7f6b0: i16 = TargetConstant<0> [ID=-3]

  0x2e801b0: ch = X86ISD::RET_FLAG 0x2ea9f80:1, 0x2e7f6b0 [ORD=79] [ID=-3]


Legalized selection DAG: BB#0 'func:entry'
SelectionDAG has 37 nodes:
  0x2e5c478: ch = EntryToken [ID=0]

  0x2e84540: i64 = TargetConstant<0> [ID=5]

  0x2e84140: i64 = Register %RDI [ID=6]

  0x2ea9a80: i64 = Register %RSI [ID=7]

  0x2e84240: Untyped = RegisterMask [ID=8]

  0x2ea9c80: i32 = Register %ESI [ID=15]

  0x2ea9b80: i8 = Register %AL [ID=16]

    0x2e5c478: <multiple use>
    0x2e7fab0: i32 = Register %vreg0 [ID=1]

  0x2e7fcb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=70] [ID=19]

      0x2e5c478: <multiple use>
      0x2e84540: <multiple use>
    0x2e84440: ch,glue = callseq_start 0x2e5c478, 0x2e84540 [ORD=74] [ID=20]

    0x2e84140: <multiple use>
    0x2e7ffb0: i64 = Constant<48717472> [ID=3]

  0x2eaa480: ch,glue = CopyToReg 0x2e84440, 0x2e84140, 0x2e7ffb0 [ORD=74] [ID=21]

    0x2eaa480: <multiple use>
    0x2ea9a80: <multiple use>
    0x2e84940: i64 = Constant<48397984> [ID=4]

    0x2eaa480: <multiple use>
  0x2e84640: ch,glue = CopyToReg 0x2eaa480, 0x2ea9a80, 0x2e84940, 0x2eaa480:1 [ORD=74] [ID=22]

    0x2e84640: <multiple use>
    0x2e7f9b0: i64 = Constant<8971440> [ID=2]

    0x2e84140: <multiple use>
    0x2ea9a80: <multiple use>
    0x2e84240: <multiple use>
    0x2e84640: <multiple use>
  0x2ea9680: ch,glue = X86ISD::CALL 0x2e84640, 0x2e7f9b0, 0x2e84140, 0x2ea9a80, 0x2e84240, 0x2e84640:1 [ORD=74] [ID=23]

    0x2ea9680: <multiple use>
    0x2e84540: <multiple use>
    0x2e84540: <multiple use>
    0x2ea9680: <multiple use>
  0x2e83c40: ch,glue = callseq_end 0x2ea9680, 0x2e84540, 0x2e84540, 0x2ea9680:1 [ORD=74] [ID=24]

          0x2e83c40: <multiple use>
          0x2ea9e80: i64 = Register %RAX [ID=9]

          0x2e83c40: <multiple use>
        0x2e7f8b0: i64,ch,glue = CopyFromReg 0x2e83c40, 0x2ea9e80, 0x2e83c40:1 [ORD=74] [ID=25]

        0x2e7fcb0: <multiple use>
        0x2e7feb0: i64 = FrameIndex<0> [ID=10]

        0x2e84340: i64 = undef [ID=11]

      0x2eaa8d0: ch = store 0x2e7f8b0:1, 0x2e7fcb0, 0x2e7feb0, 0x2e84340<ST4[%i.addr]> [ORD=76] [ID=26]

      0x2e84540: <multiple use>
    0x2eaa080: ch,glue = callseq_start 0x2eaa8d0, 0x2e84540 [ORD=78] [ID=27]

    0x2e84140: <multiple use>
      0x2e7f3b0: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=78]

    0x2ea9980: i64 = X86ISD::Wrapper 0x2e7f3b0 [ORD=78]

  0x2e83d40: ch,glue = CopyToReg 0x2eaa080, 0x2e84140, 0x2ea9980 [ORD=78] [ID=28]

    0x2e83d40: <multiple use>
    0x2ea9c80: <multiple use>
    0x2e7fcb0: <multiple use>
    0x2e83d40: <multiple use>
  0x2e83b40: ch,glue = CopyToReg 0x2e83d40, 0x2ea9c80, 0x2e7fcb0, 0x2e83d40:1 [ORD=78] [ID=29]

    0x2e83b40: <multiple use>
    0x2ea9b80: <multiple use>
    0x2e84740: i8 = Constant<0> [ID=14]

    0x2e83b40: <multiple use>
  0x2e7f5b0: ch,glue = CopyToReg 0x2e83b40, 0x2ea9b80, 0x2e84740, 0x2e83b40:1 [ORD=78] [ID=30]

    0x2e7f5b0: <multiple use>
      0x2e7fdb0: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=78]

    0x2e84840: i64 = X86ISD::Wrapper 0x2e7fdb0 [ORD=78]

    0x2e84140: <multiple use>
    0x2ea9c80: <multiple use>
    0x2ea9b80: <multiple use>
    0x2e84240: <multiple use>
    0x2e7f5b0: <multiple use>
  0x2ea9d80: ch,glue = X86ISD::CALL 0x2e7f5b0, 0x2e84840, 0x2e84140, 0x2ea9c80, 0x2ea9b80, 0x2e84240, 0x2e7f5b0:1 [ORD=78] [ID=31]

    0x2ea9d80: <multiple use>
    0x2e84540: <multiple use>
    0x2e84540: <multiple use>
    0x2ea9d80: <multiple use>
  0x2eaa380: ch,glue = callseq_end 0x2ea9d80, 0x2e84540, 0x2e84540, 0x2ea9d80:1 [ORD=78] [ID=32]

      0x2eaa380: <multiple use>
      0x2ea9780: i32 = Register %EAX [ID=17]

      0x2eaa380: <multiple use>
    0x2ea9f80: i32,ch,glue = CopyFromReg 0x2eaa380, 0x2ea9780, 0x2eaa380:1 [ORD=78] [ID=33]

    0x2e7f6b0: i16 = TargetConstant<0> [ID=18]

  0x2e801b0: ch = X86ISD::RET_FLAG 0x2ea9f80:1, 0x2e7f6b0 [ORD=79] [ID=34]


Optimized legalized selection DAG: BB#0 'func:entry'
SelectionDAG has 37 nodes:
  0x2e5c478: ch = EntryToken [ID=0]

  0x2e84540: i64 = TargetConstant<0> [ID=5]

  0x2e84140: i64 = Register %RDI [ID=6]

  0x2ea9a80: i64 = Register %RSI [ID=7]

  0x2e84240: Untyped = RegisterMask [ID=8]

  0x2ea9c80: i32 = Register %ESI [ID=15]

  0x2ea9b80: i8 = Register %AL [ID=16]

    0x2e5c478: <multiple use>
    0x2e7fab0: i32 = Register %vreg0 [ID=1]

  0x2e7fcb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=70] [ID=19]

      0x2e5c478: <multiple use>
      0x2e84540: <multiple use>
    0x2e84440: ch,glue = callseq_start 0x2e5c478, 0x2e84540 [ORD=74] [ID=20]

    0x2e84140: <multiple use>
    0x2e7ffb0: i64 = Constant<48717472> [ID=3]

  0x2eaa480: ch,glue = CopyToReg 0x2e84440, 0x2e84140, 0x2e7ffb0 [ORD=74] [ID=21]

    0x2eaa480: <multiple use>
    0x2ea9a80: <multiple use>
    0x2e84940: i64 = Constant<48397984> [ID=4]

    0x2eaa480: <multiple use>
  0x2e84640: ch,glue = CopyToReg 0x2eaa480, 0x2ea9a80, 0x2e84940, 0x2eaa480:1 [ORD=74] [ID=22]

    0x2e84640: <multiple use>
    0x2e7f9b0: i64 = Constant<8971440> [ID=2]

    0x2e84140: <multiple use>
    0x2ea9a80: <multiple use>
    0x2e84240: <multiple use>
    0x2e84640: <multiple use>
  0x2ea9680: ch,glue = X86ISD::CALL 0x2e84640, 0x2e7f9b0, 0x2e84140, 0x2ea9a80, 0x2e84240, 0x2e84640:1 [ORD=74] [ID=23]

    0x2ea9680: <multiple use>
    0x2e84540: <multiple use>
    0x2e84540: <multiple use>
    0x2ea9680: <multiple use>
  0x2e83c40: ch,glue = callseq_end 0x2ea9680, 0x2e84540, 0x2e84540, 0x2ea9680:1 [ORD=74] [ID=24]

          0x2e83c40: <multiple use>
          0x2ea9e80: i64 = Register %RAX [ID=9]

          0x2e83c40: <multiple use>
        0x2e7f8b0: i64,ch,glue = CopyFromReg 0x2e83c40, 0x2ea9e80, 0x2e83c40:1 [ORD=74] [ID=25]

        0x2e7fcb0: <multiple use>
        0x2e7feb0: i64 = FrameIndex<0> [ID=10]

        0x2e84340: i64 = undef [ID=11]

      0x2eaa8d0: ch = store 0x2e7f8b0:1, 0x2e7fcb0, 0x2e7feb0, 0x2e84340<ST4[%i.addr]> [ORD=76] [ID=26]

      0x2e84540: <multiple use>
    0x2eaa080: ch,glue = callseq_start 0x2eaa8d0, 0x2e84540 [ORD=78] [ID=27]

    0x2e84140: <multiple use>
      0x2e7f3b0: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=78]

    0x2ea9980: i64 = X86ISD::Wrapper 0x2e7f3b0 [ORD=78]

  0x2e83d40: ch,glue = CopyToReg 0x2eaa080, 0x2e84140, 0x2ea9980 [ORD=78] [ID=28]

    0x2e83d40: <multiple use>
    0x2ea9c80: <multiple use>
    0x2e7fcb0: <multiple use>
    0x2e83d40: <multiple use>
  0x2e83b40: ch,glue = CopyToReg 0x2e83d40, 0x2ea9c80, 0x2e7fcb0, 0x2e83d40:1 [ORD=78] [ID=29]

    0x2e83b40: <multiple use>
    0x2ea9b80: <multiple use>
    0x2e84740: i8 = Constant<0> [ID=14]

    0x2e83b40: <multiple use>
  0x2e7f5b0: ch,glue = CopyToReg 0x2e83b40, 0x2ea9b80, 0x2e84740, 0x2e83b40:1 [ORD=78] [ID=30]

    0x2e7f5b0: <multiple use>
      0x2e7fdb0: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=78]

    0x2e84840: i64 = X86ISD::Wrapper 0x2e7fdb0 [ORD=78]

    0x2e84140: <multiple use>
    0x2ea9c80: <multiple use>
    0x2ea9b80: <multiple use>
    0x2e84240: <multiple use>
    0x2e7f5b0: <multiple use>
  0x2ea9d80: ch,glue = X86ISD::CALL 0x2e7f5b0, 0x2e84840, 0x2e84140, 0x2ea9c80, 0x2ea9b80, 0x2e84240, 0x2e7f5b0:1 [ORD=78] [ID=31]

    0x2ea9d80: <multiple use>
    0x2e84540: <multiple use>
    0x2e84540: <multiple use>
    0x2ea9d80: <multiple use>
  0x2eaa380: ch,glue = callseq_end 0x2ea9d80, 0x2e84540, 0x2e84540, 0x2ea9d80:1 [ORD=78] [ID=32]

      0x2eaa380: <multiple use>
      0x2ea9780: i32 = Register %EAX [ID=17]

      0x2eaa380: <multiple use>
    0x2ea9f80: i32,ch,glue = CopyFromReg 0x2eaa380, 0x2ea9780, 0x2eaa380:1 [ORD=78] [ID=33]

    0x2e7f6b0: i16 = TargetConstant<0> [ID=18]

  0x2e801b0: ch = X86ISD::RET_FLAG 0x2ea9f80:1, 0x2e7f6b0 [ORD=79] [ID=34]


===== Instruction selection begins: BB#0 'entry'
Selecting: 0x2e801b0: ch = X86ISD::RET_FLAG 0x2ea9f80:1, 0x2e7f6b0 [ORD=79] [ID=36]

ISEL: Starting pattern match on root node: 0x2e801b0: ch = X86ISD::RET_FLAG 0x2ea9f80:1, 0x2e7f6b0 [ORD=79] [ID=36]

  Initial Opcode index to 93235
  Morphed node: 0x2e801b0: ch = RET 0x2ea9f80:1 [ORD=79]

ISEL: Match complete!
=> 0x2e801b0: ch = RET 0x2ea9f80:1 [ORD=79]

Selecting: 0x2ea9f80: i32,ch,glue = CopyFromReg 0x2eaa380, 0x2ea9780, 0x2eaa380:1 [ORD=78] [ID=35]

=> 0x2ea9f80: i32,ch,glue = CopyFromReg 0x2eaa380, 0x2ea9780, 0x2eaa380:1 [ORD=78]

Selecting: 0x2eaa380: ch,glue = callseq_end 0x2ea9d80, 0x2e84540, 0x2e84540, 0x2ea9d80:1 [ORD=78] [ID=34]

ISEL: Starting pattern match on root node: 0x2eaa380: ch,glue = callseq_end 0x2ea9d80, 0x2e84540, 0x2e84540, 0x2ea9d80:1 [ORD=78] [ID=34]

  Initial Opcode index to 92907
  Skipped scope entry (due to false predicate) at index 92925, continuing at 92937
  Morphed node: 0x2eaa380: i64,ch,glue = ADJCALLSTACKUP64 0x2e84540, 0x2e84540, 0x2ea9d80, 0x2ea9d80:1 [ORD=78]

ISEL: Match complete!
=> 0x2eaa380: i64,ch,glue = ADJCALLSTACKUP64 0x2e84540, 0x2e84540, 0x2ea9d80, 0x2ea9d80:1 [ORD=78]

Selecting: 0x2ea9d80: ch,glue = X86ISD::CALL 0x2e7f5b0, 0x2e84840, 0x2e84140, 0x2ea9c80, 0x2ea9b80, 0x2e84240, 0x2e7f5b0:1 [ORD=78] [ID=33]

ISEL: Starting pattern match on root node: 0x2ea9d80: ch,glue = X86ISD::CALL 0x2e7f5b0, 0x2e84840, 0x2e84140, 0x2ea9c80, 0x2ea9b80, 0x2e84240, 0x2e7f5b0:1 [ORD=78] [ID=33]

  Initial Opcode index to 69884
  Match failed at index 69890
  Continuing at 69951
  Match failed at index 69957
  Continuing at 70031
  Match failed at index 70032
  Continuing at 70044
  Morphed node: 0x2ea9d80: ch,glue = CALL64r 0x2e84840, 0x2e84140, 0x2ea9c80, 0x2ea9b80, 0x2e84240, 0x2e7f5b0, 0x2e7f5b0:1 [ORD=78]

ISEL: Match complete!
=> 0x2ea9d80: ch,glue = CALL64r 0x2e84840, 0x2e84140, 0x2ea9c80, 0x2ea9b80, 0x2e84240, 0x2e7f5b0, 0x2e7f5b0:1 [ORD=78]

Selecting: 0x2e7f5b0: ch,glue = CopyToReg 0x2e83b40, 0x2ea9b80, 0x2e84740, 0x2e83b40:1 [ORD=78] [ID=32]

=> 0x2e7f5b0: ch,glue = CopyToReg 0x2e83b40, 0x2ea9b80, 0x2e84740, 0x2e83b40:1 [ORD=78]

Selecting: 0x2e83b40: ch,glue = CopyToReg 0x2e83d40, 0x2ea9c80, 0x2e7fcb0, 0x2e83d40:1 [ORD=78] [ID=31]

=> 0x2e83b40: ch,glue = CopyToReg 0x2e83d40, 0x2ea9c80, 0x2e7fcb0, 0x2e83d40:1 [ORD=78]

Selecting: 0x2e83d40: ch,glue = CopyToReg 0x2eaa080, 0x2e84140, 0x2ea9980 [ORD=78] [ID=30]

=> 0x2e83d40: ch,glue = CopyToReg 0x2eaa080, 0x2e84140, 0x2ea9980 [ORD=78]

Selecting: 0x2eaa080: ch,glue = callseq_start 0x2eaa8d0, 0x2e84540 [ORD=78] [ID=29]

ISEL: Starting pattern match on root node: 0x2eaa080: ch,glue = callseq_start 0x2eaa8d0, 0x2e84540 [ORD=78] [ID=29]

  Initial Opcode index to 95380
  Skipped scope entry (due to false predicate) at index 95390, continuing at 95401
  Morphed node: 0x2eaa080: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84540, 0x2eaa8d0 [ORD=78]

ISEL: Match complete!
=> 0x2eaa080: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84540, 0x2eaa8d0 [ORD=78]

Selecting: 0x2eaa8d0: ch = store 0x2e7f8b0:1, 0x2e7fcb0, 0x2e7feb0, 0x2e84340<ST4[%i.addr]> [ORD=76] [ID=28]

ISEL: Starting pattern match on root node: 0x2eaa8d0: ch = store 0x2e7f8b0:1, 0x2e7fcb0, 0x2e7feb0, 0x2e84340<ST4[%i.addr]> [ORD=76] [ID=28]

  Initial Opcode index to 5
  Skipped scope entry (due to false predicate) at index 13, continuing at 58
  Skipped scope entry (due to false predicate) at index 59, continuing at 104
  Skipped scope entry (due to false predicate) at index 105, continuing at 188
  Skipped scope entry (due to false predicate) at index 189, continuing at 212
  Skipped scope entry (due to false predicate) at index 213, continuing at 236
  Skipped scope entry (due to false predicate) at index 237, continuing at 260
  Match failed at index 264
  Continuing at 284
  Match failed at index 285
  Continuing at 308
  Continuing at 309
  Match failed at index 313
  Continuing at 10708
  Match failed at index 10713
  Continuing at 11131
  Match failed at index 11135
  Continuing at 11509
  Match failed at index 11513
  Continuing at 11624
  Match failed at index 11628
  Continuing at 11859
  Skipped scope entry (due to false predicate) at index 11864, continuing at 11950
  Skipped scope entry (due to false predicate) at index 11951, continuing at 12064
  Skipped scope entry (due to false predicate) at index 12065, continuing at 12137
  Skipped scope entry (due to false predicate) at index 12138, continuing at 12161
  Skipped scope entry (due to false predicate) at index 12162, continuing at 12185
MatchAddress: X86ISelAddressMode 0x7fff29e7b560
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
  Morphed node: 0x2eaa8d0: ch = MOV32mr 0x2e800b0, 0x2e83f40, 0x2e7f6b0, 0x2e7f4b0, 0x2ea9880, 0x2e7fcb0, 0x2e7f8b0:1<Mem:ST4[%i.addr]> [ORD=76]

ISEL: Match complete!
=> 0x2eaa8d0: ch = MOV32mr 0x2e800b0, 0x2e83f40, 0x2e7f6b0, 0x2e7f4b0, 0x2ea9880, 0x2e7fcb0, 0x2e7f8b0:1<Mem:ST4[%i.addr]> [ORD=76]

Selecting: 0x2e7f8b0: i64,ch,glue = CopyFromReg 0x2e83c40, 0x2ea9e80, 0x2e83c40:1 [ORD=74] [ID=27]

=> 0x2e7f8b0: i64,ch,glue = CopyFromReg 0x2e83c40, 0x2ea9e80, 0x2e83c40:1 [ORD=74]

Selecting: 0x2e83c40: ch,glue = callseq_end 0x2ea9680, 0x2e84540, 0x2e84540, 0x2ea9680:1 [ORD=74] [ID=26]

ISEL: Starting pattern match on root node: 0x2e83c40: ch,glue = callseq_end 0x2ea9680, 0x2e84540, 0x2e84540, 0x2ea9680:1 [ORD=74] [ID=26]

  Initial Opcode index to 92907
  Skipped scope entry (due to false predicate) at index 92925, continuing at 92937
  Morphed node: 0x2e83c40: i64,ch,glue = ADJCALLSTACKUP64 0x2e84540, 0x2e84540, 0x2ea9680, 0x2ea9680:1 [ORD=74]

ISEL: Match complete!
=> 0x2e83c40: i64,ch,glue = ADJCALLSTACKUP64 0x2e84540, 0x2e84540, 0x2ea9680, 0x2ea9680:1 [ORD=74]

Selecting: 0x2ea9680: ch,glue = X86ISD::CALL 0x2e84640, 0x2e7f9b0, 0x2e84140, 0x2ea9a80, 0x2e84240, 0x2e84640:1 [ORD=74] [ID=25]

ISEL: Starting pattern match on root node: 0x2ea9680: ch,glue = X86ISD::CALL 0x2e84640, 0x2e7f9b0, 0x2e84140, 0x2ea9a80, 0x2e84240, 0x2e84640:1 [ORD=74] [ID=25]

  Initial Opcode index to 69884
  Match failed at index 69890
  Continuing at 69951
  OpcodeSwitch from 69957 to 70015
  Match failed at index 70015
  Continuing at 70031
  Match failed at index 70032
  Continuing at 70044
  Morphed node: 0x2ea9680: ch,glue = CALL64r 0x2e7f9b0, 0x2e84140, 0x2ea9a80, 0x2e84240, 0x2e84640, 0x2e84640:1 [ORD=74]

ISEL: Match complete!
=> 0x2ea9680: ch,glue = CALL64r 0x2e7f9b0, 0x2e84140, 0x2ea9a80, 0x2e84240, 0x2e84640, 0x2e84640:1 [ORD=74]

Selecting: 0x2e84640: ch,glue = CopyToReg 0x2eaa480, 0x2ea9a80, 0x2e84940, 0x2eaa480:1 [ORD=74] [ID=24]

=> 0x2e84640: ch,glue = CopyToReg 0x2eaa480, 0x2ea9a80, 0x2e84940, 0x2eaa480:1 [ORD=74]

Selecting: 0x2eaa480: ch,glue = CopyToReg 0x2e84440, 0x2e84140, 0x2e7ffb0 [ORD=74] [ID=23]

=> 0x2eaa480: ch,glue = CopyToReg 0x2e84440, 0x2e84140, 0x2e7ffb0 [ORD=74]

Selecting: 0x2e84840: i64 = X86ISD::Wrapper 0x2e7fdb0 [ORD=78] [ID=22]

ISEL: Starting pattern match on root node: 0x2e84840: i64 = X86ISD::Wrapper 0x2e7fdb0 [ORD=78] [ID=22]

  Initial Opcode index to 94787
  Match failed at index 94792
  Continuing at 94819
  OpcodeSwitch from 94824 to 94938
  TypeSwitch[i64] from 94939 to 94952
  Morphed node: 0x2e84840: i64 = MOV64ri 0x2e7fdb0 [ORD=78]

ISEL: Match complete!
=> 0x2e84840: i64 = MOV64ri 0x2e7fdb0 [ORD=78]

Selecting: 0x2ea9980: i64 = X86ISD::Wrapper 0x2e7f3b0 [ORD=78] [ID=21]

ISEL: Starting pattern match on root node: 0x2ea9980: i64 = X86ISD::Wrapper 0x2e7f3b0 [ORD=78] [ID=21]

  Initial Opcode index to 94787
  Match failed at index 94792
  Continuing at 94819
  OpcodeSwitch from 94824 to 94938
  TypeSwitch[i64] from 94939 to 94952
  Morphed node: 0x2ea9980: i64 = MOV64ri 0x2e7f3b0 [ORD=78]

ISEL: Match complete!
=> 0x2ea9980: i64 = MOV64ri 0x2e7f3b0 [ORD=78]

Selecting: 0x2e84440: ch,glue = callseq_start 0x2e5c478, 0x2e84540 [ORD=74] [ID=20]

ISEL: Starting pattern match on root node: 0x2e84440: ch,glue = callseq_start 0x2e5c478, 0x2e84540 [ORD=74] [ID=20]

  Initial Opcode index to 95380
  Skipped scope entry (due to false predicate) at index 95390, continuing at 95401
  Morphed node: 0x2e84440: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84540, 0x2e5c478 [ORD=74]

ISEL: Match complete!
=> 0x2e84440: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84540, 0x2e5c478 [ORD=74]

Selecting: 0x2e7fcb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=70] [ID=19]

=> 0x2e7fcb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=70]

Selecting: 0x2e7fdb0: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=78] [ID=18]

=> 0x2e7fdb0: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=78]

Selecting: 0x2e7f3b0: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=78] [ID=17]

=> 0x2e7f3b0: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=78]

Selecting: 0x2ea9780: i32 = Register %EAX [ID=15]

=> 0x2ea9780: i32 = Register %EAX

Selecting: 0x2ea9b80: i8 = Register %AL [ID=14]

=> 0x2ea9b80: i8 = Register %AL

Selecting: 0x2ea9c80: i32 = Register %ESI [ID=13]

=> 0x2ea9c80: i32 = Register %ESI

Selecting: 0x2e84740: i8 = Constant<0> [ID=12]

ISEL: Starting pattern match on root node: 0x2e84740: i8 = Constant<0> [ID=12]

  Initial Opcode index to 82786
  Match failed at index 82790
  Continuing at 82816
  Match failed at index 82818
  Continuing at 82847
  TypeSwitch[i8] from 82850 to 82863
  Created node: 0x2e7feb0: i32,i32 = MOV32r0

  Morphed node: 0x2e84740: i8 = EXTRACT_SUBREG 0x2e7feb0, 0x2e84340

ISEL: Match complete!
=> 0x2e84740: i8 = EXTRACT_SUBREG 0x2e7feb0, 0x2e84340

Selecting: 0x2ea9e80: i64 = Register %RAX [ID=9]

=> 0x2ea9e80: i64 = Register %RAX

Selecting: 0x2e84240: Untyped = RegisterMask [ID=8]

=> 0x2e84240: Untyped = RegisterMask

Selecting: 0x2ea9a80: i64 = Register %RSI [ID=7]

=> 0x2ea9a80: i64 = Register %RSI

Selecting: 0x2e84140: i64 = Register %RDI [ID=6]

=> 0x2e84140: i64 = Register %RDI

Selecting: 0x2e84540: i64 = TargetConstant<0> [ID=5]

=> 0x2e84540: i64 = TargetConstant<0>

Selecting: 0x2e84940: i64 = Constant<48397984> [ID=4]

ISEL: Starting pattern match on root node: 0x2e84940: i64 = Constant<48397984> [ID=4]

  Initial Opcode index to 82786
  Skipped scope entry (due to false predicate) at index 82788, continuing at 82816
  Created node: 0x2e7fbb0: i32 = MOV32ri64 0x2e7f7b0

  Morphed node: 0x2e84940: i64 = SUBREG_TO_REG 0x2e84540, 0x2e7fbb0, 0x2e84040

ISEL: Match complete!
=> 0x2e84940: i64 = SUBREG_TO_REG 0x2e84540, 0x2e7fbb0, 0x2e84040

Selecting: 0x2e7ffb0: i64 = Constant<48717472> [ID=3]

ISEL: Starting pattern match on root node: 0x2e7ffb0: i64 = Constant<48717472> [ID=3]

  Initial Opcode index to 82786
  Skipped scope entry (due to false predicate) at index 82788, continuing at 82816
  Created node: 0x2eaa180: i32 = MOV32ri64 0x2e83e40

  Morphed node: 0x2e7ffb0: i64 = SUBREG_TO_REG 0x2e84540, 0x2eaa180, 0x2e84040

ISEL: Match complete!
=> 0x2e7ffb0: i64 = SUBREG_TO_REG 0x2e84540, 0x2eaa180, 0x2e84040

Selecting: 0x2e7f9b0: i64 = Constant<8971440> [ID=2]

ISEL: Starting pattern match on root node: 0x2e7f9b0: i64 = Constant<8971440> [ID=2]

  Initial Opcode index to 82786
  Skipped scope entry (due to false predicate) at index 82788, continuing at 82816
  Created node: 0x2eaa9d0: i32 = MOV32ri64 0x2eaa280

  Morphed node: 0x2e7f9b0: i64 = SUBREG_TO_REG 0x2e84540, 0x2eaa9d0, 0x2e84040

ISEL: Match complete!
=> 0x2e7f9b0: i64 = SUBREG_TO_REG 0x2e84540, 0x2eaa9d0, 0x2e84040

Selecting: 0x2e7fab0: i32 = Register %vreg0 [ID=1]

=> 0x2e7fab0: i32 = Register %vreg0

Selecting: 0x2e5c478: ch = EntryToken [ID=0]

=> 0x2e5c478: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: BB#0 'func:entry'
SelectionDAG has 48 nodes:
  0x2e5c478: ch = EntryToken

  0x2e84540: i64 = TargetConstant<0>

  0x2e84140: i64 = Register %RDI

  0x2ea9a80: i64 = Register %RSI

  0x2e84240: Untyped = RegisterMask

  0x2ea9c80: i32 = Register %ESI

  0x2ea9b80: i8 = Register %AL

    0x2e5c478: <multiple use>
    0x2e7fab0: i32 = Register %vreg0

  0x2e7fcb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=70]

      0x2e84540: <multiple use>
      0x2e5c478: <multiple use>
    0x2e84440: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84540, 0x2e5c478 [ORD=74]

    0x2e84140: <multiple use>
      0x2e84540: <multiple use>
        0x2e83e40: i64 = TargetConstant<48717472>

      0x2eaa180: i32 = MOV32ri64 0x2e83e40

      0x2e84040: <multiple use>
    0x2e7ffb0: i64 = SUBREG_TO_REG 0x2e84540, 0x2eaa180, 0x2e84040

  0x2eaa480: ch,glue = CopyToReg 0x2e84440:1, 0x2e84140, 0x2e7ffb0 [ORD=74]

    0x2eaa480: <multiple use>
    0x2ea9a80: <multiple use>
      0x2e84540: <multiple use>
        0x2e7f7b0: i64 = TargetConstant<48397984>

      0x2e7fbb0: i32 = MOV32ri64 0x2e7f7b0

      0x2e84040: <multiple use>
    0x2e84940: i64 = SUBREG_TO_REG 0x2e84540, 0x2e7fbb0, 0x2e84040

    0x2eaa480: <multiple use>
  0x2e84640: ch,glue = CopyToReg 0x2eaa480, 0x2ea9a80, 0x2e84940, 0x2eaa480:1 [ORD=74]

      0x2e84540: <multiple use>
        0x2eaa280: i64 = TargetConstant<8971440>

      0x2eaa9d0: i32 = MOV32ri64 0x2eaa280

      0x2e84040: <multiple use>
    0x2e7f9b0: i64 = SUBREG_TO_REG 0x2e84540, 0x2eaa9d0, 0x2e84040

    0x2e84140: <multiple use>
    0x2ea9a80: <multiple use>
    0x2e84240: <multiple use>
    0x2e84640: <multiple use>
    0x2e84640: <multiple use>
  0x2ea9680: ch,glue = CALL64r 0x2e7f9b0, 0x2e84140, 0x2ea9a80, 0x2e84240, 0x2e84640, 0x2e84640:1 [ORD=74]

    0x2e84540: <multiple use>
    0x2e84540: <multiple use>
    0x2ea9680: <multiple use>
    0x2ea9680: <multiple use>
  0x2e83c40: i64,ch,glue = ADJCALLSTACKUP64 0x2e84540, 0x2e84540, 0x2ea9680, 0x2ea9680:1 [ORD=74]

      0x2e84540: <multiple use>
        0x2e800b0: i64 = TargetFrameIndex<0>

        0x2e83f40: i8 = TargetConstant<1>

        0x2e7f6b0: i64 = Register %noreg

        0x2e7f4b0: i32 = TargetConstant<0>

        0x2ea9880: i32 = Register %noreg

        0x2e7fcb0: <multiple use>
          0x2e83c40: <multiple use>
          0x2ea9e80: i64 = Register %RAX

          0x2e83c40: <multiple use>
        0x2e7f8b0: i64,ch,glue = CopyFromReg 0x2e83c40:1, 0x2ea9e80, 0x2e83c40:2 [ORD=74]

      0x2eaa8d0: ch = MOV32mr 0x2e800b0, 0x2e83f40, 0x2e7f6b0, 0x2e7f4b0, 0x2ea9880, 0x2e7fcb0, 0x2e7f8b0:1<Mem:ST4[%i.addr]> [ORD=76]

    0x2eaa080: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84540, 0x2eaa8d0 [ORD=78]

    0x2e84140: <multiple use>
      0x2e7f3b0: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=78]

    0x2ea9980: i64 = MOV64ri 0x2e7f3b0 [ORD=78]

  0x2e83d40: ch,glue = CopyToReg 0x2eaa080:1, 0x2e84140, 0x2ea9980 [ORD=78]

    0x2e83d40: <multiple use>
    0x2ea9c80: <multiple use>
    0x2e7fcb0: <multiple use>
    0x2e83d40: <multiple use>
  0x2e83b40: ch,glue = CopyToReg 0x2e83d40, 0x2ea9c80, 0x2e7fcb0, 0x2e83d40:1 [ORD=78]

    0x2e83b40: <multiple use>
    0x2ea9b80: <multiple use>
      0x2e7feb0: i32,i32 = MOV32r0

      0x2e84340: i32 = TargetConstant<1>

    0x2e84740: i8 = EXTRACT_SUBREG 0x2e7feb0, 0x2e84340

    0x2e83b40: <multiple use>
  0x2e7f5b0: ch,glue = CopyToReg 0x2e83b40, 0x2ea9b80, 0x2e84740, 0x2e83b40:1 [ORD=78]

      0x2e7fdb0: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=78]

    0x2e84840: i64 = MOV64ri 0x2e7fdb0 [ORD=78]

    0x2e84140: <multiple use>
    0x2ea9c80: <multiple use>
    0x2ea9b80: <multiple use>
    0x2e84240: <multiple use>
    0x2e7f5b0: <multiple use>
    0x2e7f5b0: <multiple use>
  0x2ea9d80: ch,glue = CALL64r 0x2e84840, 0x2e84140, 0x2ea9c80, 0x2ea9b80, 0x2e84240, 0x2e7f5b0, 0x2e7f5b0:1 [ORD=78]

    0x2e84540: <multiple use>
    0x2e84540: <multiple use>
    0x2ea9d80: <multiple use>
    0x2ea9d80: <multiple use>
  0x2eaa380: i64,ch,glue = ADJCALLSTACKUP64 0x2e84540, 0x2e84540, 0x2ea9d80, 0x2ea9d80:1 [ORD=78]

  0x2e84040: i32 = TargetConstant<4>

      0x2eaa380: <multiple use>
      0x2ea9780: i32 = Register %EAX

      0x2eaa380: <multiple use>
    0x2ea9f80: i32,ch,glue = CopyFromReg 0x2eaa380:1, 0x2ea9780, 0x2eaa380:2 [ORD=78]

  0x2e801b0: ch = RET 0x2ea9f80:1 [ORD=79]


********** List Scheduling BB#0 'entry' **********
SU(0): 0x2e801b0: ch = RET 0x2ea9f80:1 [ORD=79] [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 0
  Predecessors:
   ch  SU(1): Latency=1

SU(1): 0x2ea9f80: i32,ch,glue = CopyFromReg 0x2eaa380:1, 0x2ea9780, 0x2eaa380:2 [ORD=78] [ID=1]

    0x2e83d40: ch,glue = CopyToReg 0x2eaa080:1, 0x2e84140, 0x2ea9980 [ORD=78] [ID=1]

    0x2e83b40: ch,glue = CopyToReg 0x2e83d40, 0x2ea9c80, 0x2e7fcb0, 0x2e83d40:1 [ORD=78] [ID=1]

    0x2e7f5b0: ch,glue = CopyToReg 0x2e83b40, 0x2ea9b80, 0x2e84740, 0x2e83b40:1 [ORD=78] [ID=1]

    0x2ea9d80: ch,glue = CALL64r 0x2e84840, 0x2e84140, 0x2ea9c80, 0x2ea9b80, 0x2e84240, 0x2e7f5b0, 0x2e7f5b0:1 [ORD=78] [ID=1]

    0x2eaa380: i64,ch,glue = ADJCALLSTACKUP64 0x2e84540, 0x2e84540, 0x2ea9d80, 0x2ea9d80:1 [ORD=78] [ID=1]

  # preds left       : 5
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 1
  Predecessors:
   val SU(16): Latency=1
   val SU(2): Latency=1
   val SU(4): Latency=1
   ch  SU(6): Latency=1
   val SU(5): Latency=1
  Successors:
   ch  SU(0): Latency=1

SU(2): 0x2e84740: i8 = EXTRACT_SUBREG 0x2e7feb0, 0x2e84340 [ID=2]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
   val SU(3): Latency=1
  Successors:
   val SU(1): Latency=1

SU(3): 0x2e7feb0: i32,i32 = MOV32r0 [ID=3]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
   val SU(2): Latency=1

SU(4): 0x2e7fcb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=70] [ID=4]

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
   val SU(1): Latency=1
   val SU(7): Latency=1

SU(5): 0x2ea9980: i64 = MOV64ri 0x2e7f3b0 [ORD=78] [ID=5]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
   val SU(1): Latency=1

SU(6): 0x2eaa080: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84540, 0x2eaa8d0 [ORD=78] [ID=6]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 2
  Predecessors:
   ch  SU(7): Latency=1
  Successors:
   ch  SU(1): Latency=1

SU(7): 0x2eaa8d0: ch = MOV32mr 0x2e800b0, 0x2e83f40, 0x2e7f6b0, 0x2e7f4b0, 0x2ea9880, 0x2e7fcb0, 0x2e7f8b0:1<Mem:ST4[%i.addr]> [ORD=76] [ID=7]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 3
  Predecessors:
   val SU(4): Latency=1
   ch  SU(8): Latency=1
  Successors:
   ch  SU(6): Latency=1

SU(8): 0x2e7f8b0: i64,ch,glue = CopyFromReg 0x2e83c40:1, 0x2ea9e80, 0x2e83c40:2 [ORD=74] [ID=8]

    0x2eaa480: ch,glue = CopyToReg 0x2e84440:1, 0x2e84140, 0x2e7ffb0 [ORD=74] [ID=8]

    0x2e84640: ch,glue = CopyToReg 0x2eaa480, 0x2ea9a80, 0x2e84940, 0x2eaa480:1 [ORD=74] [ID=8]

    0x2ea9680: ch,glue = CALL64r 0x2e7f9b0, 0x2e84140, 0x2ea9a80, 0x2e84240, 0x2e84640, 0x2e84640:1 [ORD=74] [ID=8]

    0x2e83c40: i64,ch,glue = ADJCALLSTACKUP64 0x2e84540, 0x2e84540, 0x2ea9680, 0x2ea9680:1 [ORD=74] [ID=8]

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 4
  Predecessors:
   val SU(14): Latency=1
   val SU(9): Latency=1
   ch  SU(13): Latency=1
   val SU(11): Latency=1
  Successors:
   ch  SU(7): Latency=1

SU(9): 0x2e84940: i64 = SUBREG_TO_REG 0x2e84540, 0x2e7fbb0, 0x2e84040 [ID=9]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
   val SU(10): Latency=1
  Successors:
   val SU(8): Latency=1

SU(10): 0x2e7fbb0: i32 = MOV32ri64 0x2e7f7b0 [ID=10]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
   val SU(9): Latency=1

SU(11): 0x2e7ffb0: i64 = SUBREG_TO_REG 0x2e84540, 0x2eaa180, 0x2e84040 [ID=11]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
   val SU(12): Latency=1
  Successors:
   val SU(8): Latency=1

SU(12): 0x2eaa180: i32 = MOV32ri64 0x2e83e40 [ID=12]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
   val SU(11): Latency=1

SU(13): 0x2e84440: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84540, 0x2e5c478 [ORD=74] [ID=13]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
   ch  SU(8): Latency=1

SU(14): 0x2e7f9b0: i64 = SUBREG_TO_REG 0x2e84540, 0x2eaa9d0, 0x2e84040 [ID=14]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
   val SU(15): Latency=1
  Successors:
   val SU(8): Latency=1

SU(15): 0x2eaa9d0: i32 = MOV32ri64 0x2eaa280 [ID=15]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
   val SU(14): Latency=1

SU(16): 0x2e84840: i64 = MOV64ri 0x2e7fdb0 [ORD=78] [ID=16]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
   val SU(1): Latency=1


Examining Available:
Height 0: SU(0): 0x2e801b0: ch = RET 0x2ea9f80:1 [ORD=79] [ID=0]


*** Scheduling [0]: SU(0): 0x2e801b0: ch = RET 0x2ea9f80:1 [ORD=79] [ID=0]


Examining Available:
Height 1: SU(1): 0x2ea9f80: i32,ch,glue = CopyFromReg 0x2eaa380:1, 0x2ea9780, 0x2eaa380:2 [ORD=78] [ID=1]

    0x2e83d40: ch,glue = CopyToReg 0x2eaa080:1, 0x2e84140, 0x2ea9980 [ORD=78] [ID=1]

    0x2e83b40: ch,glue = CopyToReg 0x2e83d40, 0x2ea9c80, 0x2e7fcb0, 0x2e83d40:1 [ORD=78] [ID=1]

    0x2e7f5b0: ch,glue = CopyToReg 0x2e83b40, 0x2ea9b80, 0x2e84740, 0x2e83b40:1 [ORD=78] [ID=1]

    0x2ea9d80: ch,glue = CALL64r 0x2e84840, 0x2e84140, 0x2ea9c80, 0x2ea9b80, 0x2e84240, 0x2e7f5b0, 0x2e7f5b0:1 [ORD=78] [ID=1]

    0x2eaa380: i64,ch,glue = ADJCALLSTACKUP64 0x2e84540, 0x2e84540, 0x2ea9d80, 0x2ea9d80:1 [ORD=78] [ID=1]


*** Scheduling [1]: SU(1): 0x2ea9f80: i32,ch,glue = CopyFromReg 0x2eaa380:1, 0x2ea9780, 0x2eaa380:2 [ORD=78] [ID=1]

    0x2e83d40: ch,glue = CopyToReg 0x2eaa080:1, 0x2e84140, 0x2ea9980 [ORD=78] [ID=1]

    0x2e83b40: ch,glue = CopyToReg 0x2e83d40, 0x2ea9c80, 0x2e7fcb0, 0x2e83d40:1 [ORD=78] [ID=1]

    0x2e7f5b0: ch,glue = CopyToReg 0x2e83b40, 0x2ea9b80, 0x2e84740, 0x2e83b40:1 [ORD=78] [ID=1]

    0x2ea9d80: ch,glue = CALL64r 0x2e84840, 0x2e84140, 0x2ea9c80, 0x2ea9b80, 0x2e84240, 0x2e7f5b0, 0x2e7f5b0:1 [ORD=78] [ID=1]

    0x2eaa380: i64,ch,glue = ADJCALLSTACKUP64 0x2e84540, 0x2e84540, 0x2ea9d80, 0x2ea9d80:1 [ORD=78] [ID=1]


Examining Available:
Height 2: SU(2): 0x2e84740: i8 = EXTRACT_SUBREG 0x2e7feb0, 0x2e84340 [ID=2]

Height 2: SU(16): 0x2e84840: i64 = MOV64ri 0x2e7fdb0 [ORD=78] [ID=16]

Height 2: SU(5): 0x2ea9980: i64 = MOV64ri 0x2e7f3b0 [ORD=78] [ID=5]

Height 2: SU(6): 0x2eaa080: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84540, 0x2eaa8d0 [ORD=78] [ID=6]


*** Scheduling [2]: SU(2): 0x2e84740: i8 = EXTRACT_SUBREG 0x2e7feb0, 0x2e84340 [ID=2]


Examining Available:
Height 3: SU(3): 0x2e7feb0: i32,i32 = MOV32r0 [ID=3]

Height 2: SU(16): 0x2e84840: i64 = MOV64ri 0x2e7fdb0 [ORD=78] [ID=16]

Height 2: SU(5): 0x2ea9980: i64 = MOV64ri 0x2e7f3b0 [ORD=78] [ID=5]

Height 2: SU(6): 0x2eaa080: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84540, 0x2eaa8d0 [ORD=78] [ID=6]


*** Scheduling [3]: SU(3): 0x2e7feb0: i32,i32 = MOV32r0 [ID=3]


Examining Available:
Height 2: SU(16): 0x2e84840: i64 = MOV64ri 0x2e7fdb0 [ORD=78] [ID=16]

Height 2: SU(5): 0x2ea9980: i64 = MOV64ri 0x2e7f3b0 [ORD=78] [ID=5]

Height 2: SU(6): 0x2eaa080: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84540, 0x2eaa8d0 [ORD=78] [ID=6]


*** Scheduling [4]: SU(16): 0x2e84840: i64 = MOV64ri 0x2e7fdb0 [ORD=78] [ID=16]


Examining Available:
Height 2: SU(5): 0x2ea9980: i64 = MOV64ri 0x2e7f3b0 [ORD=78] [ID=5]

Height 2: SU(6): 0x2eaa080: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84540, 0x2eaa8d0 [ORD=78] [ID=6]


*** Scheduling [5]: SU(5): 0x2ea9980: i64 = MOV64ri 0x2e7f3b0 [ORD=78] [ID=5]


Examining Available:
Height 2: SU(6): 0x2eaa080: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84540, 0x2eaa8d0 [ORD=78] [ID=6]


*** Scheduling [6]: SU(6): 0x2eaa080: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84540, 0x2eaa8d0 [ORD=78] [ID=6]


Examining Available:
Height 7: SU(7): 0x2eaa8d0: ch = MOV32mr 0x2e800b0, 0x2e83f40, 0x2e7f6b0, 0x2e7f4b0, 0x2ea9880, 0x2e7fcb0, 0x2e7f8b0:1<Mem:ST4[%i.addr]> [ORD=76] [ID=7]


*** Scheduling [7]: SU(7): 0x2eaa8d0: ch = MOV32mr 0x2e800b0, 0x2e83f40, 0x2e7f6b0, 0x2e7f4b0, 0x2ea9880, 0x2e7fcb0, 0x2e7f8b0:1<Mem:ST4[%i.addr]> [ORD=76] [ID=7]


Examining Available:
Height 8: SU(8): 0x2e7f8b0: i64,ch,glue = CopyFromReg 0x2e83c40:1, 0x2ea9e80, 0x2e83c40:2 [ORD=74] [ID=8]

    0x2eaa480: ch,glue = CopyToReg 0x2e84440:1, 0x2e84140, 0x2e7ffb0 [ORD=74] [ID=8]

    0x2e84640: ch,glue = CopyToReg 0x2eaa480, 0x2ea9a80, 0x2e84940, 0x2eaa480:1 [ORD=74] [ID=8]

    0x2ea9680: ch,glue = CALL64r 0x2e7f9b0, 0x2e84140, 0x2ea9a80, 0x2e84240, 0x2e84640, 0x2e84640:1 [ORD=74] [ID=8]

    0x2e83c40: i64,ch,glue = ADJCALLSTACKUP64 0x2e84540, 0x2e84540, 0x2ea9680, 0x2ea9680:1 [ORD=74] [ID=8]

Height 8: SU(4): 0x2e7fcb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=70] [ID=4]


*** Scheduling [8]: SU(8): 0x2e7f8b0: i64,ch,glue = CopyFromReg 0x2e83c40:1, 0x2ea9e80, 0x2e83c40:2 [ORD=74] [ID=8]

    0x2eaa480: ch,glue = CopyToReg 0x2e84440:1, 0x2e84140, 0x2e7ffb0 [ORD=74] [ID=8]

    0x2e84640: ch,glue = CopyToReg 0x2eaa480, 0x2ea9a80, 0x2e84940, 0x2eaa480:1 [ORD=74] [ID=8]

    0x2ea9680: ch,glue = CALL64r 0x2e7f9b0, 0x2e84140, 0x2ea9a80, 0x2e84240, 0x2e84640, 0x2e84640:1 [ORD=74] [ID=8]

    0x2e83c40: i64,ch,glue = ADJCALLSTACKUP64 0x2e84540, 0x2e84540, 0x2ea9680, 0x2ea9680:1 [ORD=74] [ID=8]


Examining Available:
Height 9: SU(14): 0x2e7f9b0: i64 = SUBREG_TO_REG 0x2e84540, 0x2eaa9d0, 0x2e84040 [ID=14]

Height 9: SU(9): 0x2e84940: i64 = SUBREG_TO_REG 0x2e84540, 0x2e7fbb0, 0x2e84040 [ID=9]

Height 9: SU(11): 0x2e7ffb0: i64 = SUBREG_TO_REG 0x2e84540, 0x2eaa180, 0x2e84040 [ID=11]

Height 9: SU(13): 0x2e84440: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84540, 0x2e5c478 [ORD=74] [ID=13]

Height 8: SU(4): 0x2e7fcb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=70] [ID=4]


*** Scheduling [9]: SU(14): 0x2e7f9b0: i64 = SUBREG_TO_REG 0x2e84540, 0x2eaa9d0, 0x2e84040 [ID=14]


Examining Available:
Height 10: SU(15): 0x2eaa9d0: i32 = MOV32ri64 0x2eaa280 [ID=15]

Height 9: SU(9): 0x2e84940: i64 = SUBREG_TO_REG 0x2e84540, 0x2e7fbb0, 0x2e84040 [ID=9]

Height 9: SU(11): 0x2e7ffb0: i64 = SUBREG_TO_REG 0x2e84540, 0x2eaa180, 0x2e84040 [ID=11]

Height 9: SU(13): 0x2e84440: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84540, 0x2e5c478 [ORD=74] [ID=13]

Height 8: SU(4): 0x2e7fcb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=70] [ID=4]


*** Scheduling [10]: SU(15): 0x2eaa9d0: i32 = MOV32ri64 0x2eaa280 [ID=15]


Examining Available:
Height 9: SU(9): 0x2e84940: i64 = SUBREG_TO_REG 0x2e84540, 0x2e7fbb0, 0x2e84040 [ID=9]

Height 9: SU(11): 0x2e7ffb0: i64 = SUBREG_TO_REG 0x2e84540, 0x2eaa180, 0x2e84040 [ID=11]

Height 9: SU(13): 0x2e84440: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84540, 0x2e5c478 [ORD=74] [ID=13]

Height 8: SU(4): 0x2e7fcb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=70] [ID=4]


*** Scheduling [11]: SU(9): 0x2e84940: i64 = SUBREG_TO_REG 0x2e84540, 0x2e7fbb0, 0x2e84040 [ID=9]


Examining Available:
Height 12: SU(10): 0x2e7fbb0: i32 = MOV32ri64 0x2e7f7b0 [ID=10]

Height 9: SU(11): 0x2e7ffb0: i64 = SUBREG_TO_REG 0x2e84540, 0x2eaa180, 0x2e84040 [ID=11]

Height 9: SU(13): 0x2e84440: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84540, 0x2e5c478 [ORD=74] [ID=13]

Height 8: SU(4): 0x2e7fcb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=70] [ID=4]


*** Scheduling [12]: SU(10): 0x2e7fbb0: i32 = MOV32ri64 0x2e7f7b0 [ID=10]


Examining Available:
Height 9: SU(11): 0x2e7ffb0: i64 = SUBREG_TO_REG 0x2e84540, 0x2eaa180, 0x2e84040 [ID=11]

Height 9: SU(13): 0x2e84440: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84540, 0x2e5c478 [ORD=74] [ID=13]

Height 8: SU(4): 0x2e7fcb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=70] [ID=4]


*** Scheduling [13]: SU(11): 0x2e7ffb0: i64 = SUBREG_TO_REG 0x2e84540, 0x2eaa180, 0x2e84040 [ID=11]


Examining Available:
Height 14: SU(12): 0x2eaa180: i32 = MOV32ri64 0x2e83e40 [ID=12]

Height 9: SU(13): 0x2e84440: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84540, 0x2e5c478 [ORD=74] [ID=13]

Height 8: SU(4): 0x2e7fcb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=70] [ID=4]


*** Scheduling [14]: SU(12): 0x2eaa180: i32 = MOV32ri64 0x2e83e40 [ID=12]


Examining Available:
Height 9: SU(13): 0x2e84440: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84540, 0x2e5c478 [ORD=74] [ID=13]

Height 8: SU(4): 0x2e7fcb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=70] [ID=4]


*** Scheduling [15]: SU(13): 0x2e84440: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84540, 0x2e5c478 [ORD=74] [ID=13]


Examining Available:
Height 8: SU(4): 0x2e7fcb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=70] [ID=4]


*** Scheduling [16]: SU(4): 0x2e7fcb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=70] [ID=4]

*** Final schedule ***
SU(4): 0x2e7fcb0: i32,ch = CopyFromReg 0x2e5c478, 0x2e7fab0 [ORD=70] [ID=4]

SU(13): 0x2e84440: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84540, 0x2e5c478 [ORD=74] [ID=13]

SU(12): 0x2eaa180: i32 = MOV32ri64 0x2e83e40 [ID=12]

SU(11): 0x2e7ffb0: i64 = SUBREG_TO_REG 0x2e84540, 0x2eaa180, 0x2e84040 [ID=11]

SU(10): 0x2e7fbb0: i32 = MOV32ri64 0x2e7f7b0 [ID=10]

SU(9): 0x2e84940: i64 = SUBREG_TO_REG 0x2e84540, 0x2e7fbb0, 0x2e84040 [ID=9]

SU(15): 0x2eaa9d0: i32 = MOV32ri64 0x2eaa280 [ID=15]

SU(14): 0x2e7f9b0: i64 = SUBREG_TO_REG 0x2e84540, 0x2eaa9d0, 0x2e84040 [ID=14]

SU(8): 0x2e7f8b0: i64,ch,glue = CopyFromReg 0x2e83c40:1, 0x2ea9e80, 0x2e83c40:2 [ORD=74] [ID=8]

    0x2eaa480: ch,glue = CopyToReg 0x2e84440:1, 0x2e84140, 0x2e7ffb0 [ORD=74] [ID=8]

    0x2e84640: ch,glue = CopyToReg 0x2eaa480, 0x2ea9a80, 0x2e84940, 0x2eaa480:1 [ORD=74] [ID=8]

    0x2ea9680: ch,glue = CALL64r 0x2e7f9b0, 0x2e84140, 0x2ea9a80, 0x2e84240, 0x2e84640, 0x2e84640:1 [ORD=74] [ID=8]

    0x2e83c40: i64,ch,glue = ADJCALLSTACKUP64 0x2e84540, 0x2e84540, 0x2ea9680, 0x2ea9680:1 [ORD=74] [ID=8]

SU(7): 0x2eaa8d0: ch = MOV32mr 0x2e800b0, 0x2e83f40, 0x2e7f6b0, 0x2e7f4b0, 0x2ea9880, 0x2e7fcb0, 0x2e7f8b0:1<Mem:ST4[%i.addr]> [ORD=76] [ID=7]

SU(6): 0x2eaa080: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e84540, 0x2eaa8d0 [ORD=78] [ID=6]

SU(5): 0x2ea9980: i64 = MOV64ri 0x2e7f3b0 [ORD=78] [ID=5]

SU(16): 0x2e84840: i64 = MOV64ri 0x2e7fdb0 [ORD=78] [ID=16]

SU(3): 0x2e7feb0: i32,i32 = MOV32r0 [ID=3]

SU(2): 0x2e84740: i8 = EXTRACT_SUBREG 0x2e7feb0, 0x2e84340 [ID=2]

SU(1): 0x2ea9f80: i32,ch,glue = CopyFromReg 0x2eaa380:1, 0x2ea9780, 0x2eaa380:2 [ORD=78] [ID=1]

    0x2e83d40: ch,glue = CopyToReg 0x2eaa080:1, 0x2e84140, 0x2ea9980 [ORD=78] [ID=1]

    0x2e83b40: ch,glue = CopyToReg 0x2e83d40, 0x2ea9c80, 0x2e7fcb0, 0x2e83d40:1 [ORD=78] [ID=1]

    0x2e7f5b0: ch,glue = CopyToReg 0x2e83b40, 0x2ea9b80, 0x2e84740, 0x2e83b40:1 [ORD=78] [ID=1]

    0x2ea9d80: ch,glue = CALL64r 0x2e84840, 0x2e84140, 0x2ea9c80, 0x2ea9b80, 0x2e84240, 0x2e7f5b0, 0x2e7f5b0:1 [ORD=78] [ID=1]

    0x2eaa380: i64,ch,glue = ADJCALLSTACKUP64 0x2e84540, 0x2e84540, 0x2ea9d80, 0x2ea9d80:1 [ORD=78] [ID=1]

SU(0): 0x2e801b0: ch = RET 0x2ea9f80:1 [ORD=79] [ID=0]


Total amount of phi nodes to update: 0
# Machine code for function func: SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
48B		%vreg1<def> = MOV32ri64 48717472; GR32:%vreg1
64B		%vreg2<def> = SUBREG_TO_REG 0, %vreg1<kill>, 4; GR64:%vreg2 GR32:%vreg1
80B		%vreg3<def> = MOV32ri64 48397984; GR32:%vreg3
96B		%vreg4<def> = SUBREG_TO_REG 0, %vreg3<kill>, 4; GR64:%vreg4 GR32:%vreg3
112B		%vreg5<def> = MOV32ri64 8971440; GR32:%vreg5
128B		%vreg6<def> = SUBREG_TO_REG 0, %vreg5<kill>, 4; GR64:%vreg6 GR32:%vreg5
144B		%RDI<def> = COPY %vreg2; GR64:%vreg2
160B		%RSI<def> = COPY %vreg4; GR64:%vreg4
176B		CALL64r %vreg6<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def>; GR64:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		%vreg7<def> = COPY %RAX; GR64:%vreg7
224B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
240B		ADJCALLSTACKDOWN64 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg8<def> = MOV64ri <ga:@.str>; GR64:%vreg8
272B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
288B		%vreg10<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
304B		%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
320B		%RDI<def> = COPY %vreg8; GR64:%vreg8
336B		%ESI<def> = COPY %vreg0; GR32:%vreg0
352B		%AL<def> = COPY %vreg11; GR8:%vreg11
368B		CALL64r %vreg9<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def>; GR64:%vreg9
384B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
400B		%vreg12<def> = COPY %EAX; GR32:%vreg12
416B		RET

# End machine code for function func.

********** Stack Coloring **********
********** Function: func
Found 0 markers and 1 slots
Slot structure:
Slot #0 - 4 bytes.
Total Stack size: 4 bytes

Will not try to merge slots.
Removed 0 markers.
DeadMachineInstructionElim: DELETING: %vreg12<def> = COPY %EAX; GR32:%vreg12
DeadMachineInstructionElim: DELETING: %vreg7<def> = COPY %RAX; GR64:%vreg7
******** Pre-regalloc Machine LICM: func ********
Entering: entry
Exiting: entry
******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: func
********** PROCESS IMPLICIT DEFS **********
********** Function: func
********** REWRITING TWO-ADDR INSTRS **********
********** Function: func
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI<kill>; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
48B		%vreg1<def> = MOV32ri64 48717472; GR32:%vreg1
64B		%vreg2<def> = SUBREG_TO_REG 0, %vreg1<kill>, 4; GR64:%vreg2 GR32:%vreg1
80B		%vreg3<def> = MOV32ri64 48397984; GR32:%vreg3
96B		%vreg4<def> = SUBREG_TO_REG 0, %vreg3<kill>, 4; GR64:%vreg4 GR32:%vreg3
112B		%vreg5<def> = MOV32ri64 8971440; GR32:%vreg5
128B		%vreg6<def> = SUBREG_TO_REG 0, %vreg5<kill>, 4; GR64:%vreg6 GR32:%vreg5
144B		%RDI<def> = COPY %vreg2<kill>; GR64:%vreg2
160B		%RSI<def> = COPY %vreg4<kill>; GR64:%vreg4
176B		CALL64r %vreg6<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use,kill>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
240B		%vreg8<def> = MOV64ri <ga:@.str>; GR64:%vreg8
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
272B		%vreg10<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
288B		%vreg11<def> = COPY %vreg10:sub_8bit<kill>; GR8:%vreg11 GR32:%vreg10
304B		%RDI<def> = COPY %vreg8<kill>; GR64:%vreg8
320B		%ESI<def> = COPY %vreg0<kill>; GR32:%vreg0
336B		%AL<def> = COPY %vreg11<kill>; GR8:%vreg11
352B		CALL64r %vreg9<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use,kill>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

Computing live-in reg-units in ABI blocks.
0B	BB#0 DIL#0
Created 1 new intervals.
********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
%vreg0 [16r,320r:0)  0@16r
%vreg1 [48r,64r:0)  0@48r
%vreg2 [64r,144r:0)  0@64r
%vreg3 [80r,96r:0)  0@80r
%vreg4 [96r,160r:0)  0@96r
%vreg5 [112r,128r:0)  0@112r
%vreg6 [128r,176r:0)  0@128r
%vreg8 [240r,304r:0)  0@240r
%vreg9 [256r,352r:0)  0@256r
%vreg10 [272r,288r:0)  0@272r
%vreg11 [288r,336r:0)  0@288r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
48B		%vreg1<def> = MOV32ri64 48717472; GR32:%vreg1
64B		%vreg2<def> = SUBREG_TO_REG 0, %vreg1, 4; GR64:%vreg2 GR32:%vreg1
80B		%vreg3<def> = MOV32ri64 48397984; GR32:%vreg3
96B		%vreg4<def> = SUBREG_TO_REG 0, %vreg3, 4; GR64:%vreg4 GR32:%vreg3
112B		%vreg5<def> = MOV32ri64 8971440; GR32:%vreg5
128B		%vreg6<def> = SUBREG_TO_REG 0, %vreg5, 4; GR64:%vreg6 GR32:%vreg5
144B		%RDI<def> = COPY %vreg2; GR64:%vreg2
160B		%RSI<def> = COPY %vreg4; GR64:%vreg4
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
240B		%vreg8<def> = MOV64ri <ga:@.str>; GR64:%vreg8
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
272B		%vreg10<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
288B		%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
304B		%RDI<def> = COPY %vreg8; GR64:%vreg8
320B		%ESI<def> = COPY %vreg0; GR32:%vreg0
336B		%AL<def> = COPY %vreg11; GR8:%vreg11
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

********** SIMPLE REGISTER COALESCING **********
********** Function: func
********** JOINING INTERVALS ***********
entry:
16B	%vreg0<def> = COPY %EDI; GR32:%vreg0
	Considering merging %vreg0 with %EDI
	Can only merge into reserved registers.
64B	%vreg2<def> = SUBREG_TO_REG 0, %vreg1, 4; GR64:%vreg2 GR32:%vreg1
	Considering merging to GR64_with_sub_8bit with %vreg1 in %vreg2:sub_32bit
		RHS = %vreg1 [48r,64r:0)  0@48r
		LHS = %vreg2 [64r,144r:0)  0@64r
		merge %vreg2:0@64r into %vreg1:0@48r --> @48r
		erased:	64r	%vreg2<def> = SUBREG_TO_REG 0, %vreg1, 4; GR64:%vreg2 GR32:%vreg1
		updated: 48B	%vreg2:sub_32bit<def,read-undef> = MOV32ri64 48717472; GR64_with_sub_8bit:%vreg2
	Joined. Result = %vreg2 [48r,144r:0)  0@48r
96B	%vreg4<def> = SUBREG_TO_REG 0, %vreg3, 4; GR64:%vreg4 GR32:%vreg3
	Considering merging to GR64_with_sub_8bit with %vreg3 in %vreg4:sub_32bit
		RHS = %vreg3 [80r,96r:0)  0@80r
		LHS = %vreg4 [96r,160r:0)  0@96r
		merge %vreg4:0@96r into %vreg3:0@80r --> @80r
		erased:	96r	%vreg4<def> = SUBREG_TO_REG 0, %vreg3, 4; GR64:%vreg4 GR32:%vreg3
		updated: 80B	%vreg4:sub_32bit<def,read-undef> = MOV32ri64 48397984; GR64_with_sub_8bit:%vreg4
	Joined. Result = %vreg4 [80r,160r:0)  0@80r
128B	%vreg6<def> = SUBREG_TO_REG 0, %vreg5, 4; GR64:%vreg6 GR32:%vreg5
	Considering merging to GR64_with_sub_8bit with %vreg5 in %vreg6:sub_32bit
		RHS = %vreg5 [112r,128r:0)  0@112r
		LHS = %vreg6 [128r,176r:0)  0@128r
		merge %vreg6:0@128r into %vreg5:0@112r --> @112r
		erased:	128r	%vreg6<def> = SUBREG_TO_REG 0, %vreg5, 4; GR64:%vreg6 GR32:%vreg5
		updated: 112B	%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
	Joined. Result = %vreg6 [112r,176r:0)  0@112r
144B	%RDI<def> = COPY %vreg2; GR64_with_sub_8bit:%vreg2
	Considering merging %vreg2 with %RDI
	Can only merge into reserved registers.
Remat: %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
Shrink: %vreg2 [48r,144r:0)  0@48r
All defs dead: 48r	%vreg2:sub_32bit<def,read-undef,dead> = MOV32ri64 48717472; GR64_with_sub_8bit:%vreg2
Shrunk: %vreg2 [48r,48d:0)  0@48r
Deleting dead def 48r	%vreg2:sub_32bit<def,read-undef,dead> = MOV32ri64 48717472; GR64_with_sub_8bit:%vreg2
160B	%RSI<def> = COPY %vreg4; GR64_with_sub_8bit:%vreg4
	Considering merging %vreg4 with %RSI
	Can only merge into reserved registers.
Remat: %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
Shrink: %vreg4 [80r,160r:0)  0@80r
All defs dead: 80r	%vreg4:sub_32bit<def,read-undef,dead> = MOV32ri64 48397984; GR64_with_sub_8bit:%vreg4
Shrunk: %vreg4 [80r,80d:0)  0@80r
Deleting dead def 80r	%vreg4:sub_32bit<def,read-undef,dead> = MOV32ri64 48397984; GR64_with_sub_8bit:%vreg4
304B	%RDI<def> = COPY %vreg8; GR64:%vreg8
	Considering merging %vreg8 with %RDI
	Can only merge into reserved registers.
Remat: %RDI<def> = MOV64ri <ga:@.str>
Shrink: %vreg8 [240r,304r:0)  0@240r
All defs dead: 240r	%vreg8<def,dead> = MOV64ri <ga:@.str>; GR64:%vreg8
Shrunk: %vreg8 [240r,240d:0)  0@240r
Deleting dead def 240r	%vreg8<def,dead> = MOV64ri <ga:@.str>; GR64:%vreg8
320B	%ESI<def> = COPY %vreg0; GR32:%vreg0
	Considering merging %vreg0 with %ESI
	Can only merge into reserved registers.
336B	%AL<def> = COPY %vreg11; GR8:%vreg11
	Considering merging %vreg11 with %AL
	Can only merge into reserved registers.
288B	%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
	Considering merging to GR32 with %vreg11 in %vreg10:sub_8bit
		RHS = %vreg11 [288r,336r:0)  0@288r
		LHS = %vreg10 [272r,288r:0)  0@272r
		merge %vreg11:0@288r into %vreg10:0@272r --> @272r
		erased:	288r	%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
		updated: 336B	%AL<def> = COPY %vreg10:sub_8bit; GR32:%vreg10
	Joined. Result = %vreg10 [272r,336r:0)  0@272r
320B	%ESI<def> = COPY %vreg0; GR32:%vreg0
	Considering merging %vreg0 with %ESI
	Can only merge into reserved registers.
336B	%AL<def> = COPY %vreg10:sub_8bit; GR32:%vreg10
	Considering merging %vreg10 with %EAX
	Can only merge into reserved registers.
Remat: %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
Shrink: %vreg10 [272r,336r:0)  0@272r
All defs dead: 272r	%vreg10<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
Shrunk: %vreg10 [272r,272d:0)  0@272r
Deleting dead def 272r	%vreg10<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
320B	%ESI<def> = COPY %vreg0; GR32:%vreg0
	Considering merging %vreg0 with %ESI
	Can only merge into reserved registers.
Trying to inflate 0 regs.
********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
%vreg0 [16r,320r:0)  0@16r
%vreg6 [112r,176r:0)  0@112r
%vreg9 [256r,352r:0)  0@256r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
320B		%ESI<def> = COPY %vreg0; GR32:%vreg0
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

Before MISsched:
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

BB#0: derived from LLVM BB %entry
    Live Ins: %EDI
	%vreg0<def> = COPY %EDI; GR32:%vreg0
	ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
	%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
	%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
	CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
	ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
	ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
	%RDI<def> = MOV64ri <ga:@.str>
	%ESI<def> = COPY %vreg0; GR32:%vreg0
	%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
	CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
	ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	RET

# End machine code for function func.

********** MI Scheduling **********
func:BB#0 entry
  From: %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
    To: CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
 RegionInstrs: 4 Remaining: 9
Disabled scoreboard hazard recognizer
Disabled scoreboard hazard recognizer
SU(0):   %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   val SU(4294967295): Latency=1 Reg=%vreg9

SU(1):   %RDI<def> = MOV64ri <ga:@.str>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

SU(2):   %ESI<def> = COPY %vreg0; GR32:%vreg0
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
   ch  SU(4294967295) *: Latency=0

SU(3):   %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

Critical Path: 1
BotQ.A: 0 3 2 1 
  SU(0) ORDER                              
  SU(3) ORDER                              
  SU(2) PREG-COPY                         
Pick Bot PREG-COPY
Scheduling SU(2) %ESI<def> = COPY %vreg0; GR32:%vreg0
handleMove 320B -> 344B: %ESI<def> = COPY %vreg0; GR32:%vreg0
     SIL:	[160r,176r:0)[344r,352r:1)  0@160r 1@344r
        -->	[160r,176r:0)[344r,352r:1)  0@160r 1@344r
     %vreg0:	[16r,320r:0)  0@16r
        -->	[16r,344r:0)  0@16r
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
BotQ.A: 0 3 1 
  SU(0) ORDER                              
  SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
  Ready @1c
  BotQ.A BotLatency SU(3) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
BotQ.A: 0 1 
  SU(0) ORDER                              
  SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %RDI<def> = MOV64ri <ga:@.str>
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
Scheduling SU(0) %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
*** Final schedule for BB#0 ***
SU(0):   %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
SU(1):   %RDI<def> = MOV64ri <ga:@.str>
SU(3):   %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
SU(2):   %ESI<def> = COPY %vreg0; GR32:%vreg0

********** MI Scheduling **********
func:BB#0 entry
  From: %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
    To: CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
 RegionInstrs: 3 Remaining: 2
SU(0):   %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   val SU(4294967295): Latency=1 Reg=%vreg6

SU(1):   %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

SU(2):   %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

Critical Path: 1
BotQ.A: 0 2 1 
  SU(0) ORDER                              
  SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
  Ready @1c
  SBPort015 +1x4u
  *** Critical resource SBPort015: 0c
  SBPortAny +1x2u
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
BotQ.A: 0 1 
  SU(0) ORDER                              
  SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
Scheduling SU(0) %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 3
  Executed: 1c
  Critical: 1c, 3 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
*** Final schedule for BB#0 ***
SU(0):   %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
SU(1):   %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
SU(2):   %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>

********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
SIL [160r,176r:0)[344r,352r:1)  0@160r 1@344r
%vreg0 [16r,344r:0)  0@16r
%vreg6 [112r,176r:0)  0@112r
%vreg9 [256r,352r:0)  0@256r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
344B		%ESI<def> = COPY %vreg0; GR32:%vreg0
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

RPO[BB#0 derived from LLVM BB entry] = 1
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#0 derived from LLVM BB entry)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0.0
Frequency(BB#0 derived from LLVM BB entry) = 1.0
LoopExitProb[BB#0 derived from LLVM BB entry] = 16383 / 16384 = 99.9939% from 1 - 0.0 / 1.0.
********** COMPUTING LIVE DEBUG VARIABLES: func **********
********** DEBUG VARIABLES **********
********** GREEDY REGISTER ALLOCATION **********
********** Function: func
********** Compute Spill Weights **********
********** Function: func
********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
SIL [160r,176r:0)[344r,352r:1)  0@160r 1@344r
%vreg0 [16r,344r:0)  0@16r
%vreg6 [112r,176r:0)  0@112r
%vreg9 [256r,352r:0)  0@256r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
344B		%ESI<def> = COPY %vreg0; GR32:%vreg0
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.


selectOrSplit GR32:%vreg0 [16r,344r:0)  0@16r
hints: %EDI
missed hint %EDI
assigning %vreg0 to %EBX: BH BL

selectOrSplit GR64_with_sub_8bit:%vreg6 [112r,176r:0)  0@112r
assigning %vreg6 to %RAX: AH AL

selectOrSplit GR64:%vreg9 [256r,352r:0)  0@256r
assigning %vreg9 to %RCX: CH CL
********** REWRITE VIRTUAL REGISTERS **********
********** Function: func
********** REGISTER MAP **********
[%vreg0 -> %EBX] GR32
[%vreg6 -> %RAX] GR64_with_sub_8bit
[%vreg9 -> %RCX] GR64

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
344B		%ESI<def> = COPY %vreg0<kill>; GR32:%vreg0
352B		CALL64r %vreg9<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET
> %EBX<def> = COPY %EDI
> ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> %EAX<def> = MOV32ri64 8971440, %RAX<imp-def>
> %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
> %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
> CALL64r %RAX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>
> ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %EBX; mem:ST4[%i.addr]
> ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> %RCX<def> = MOV64ri <ga:@printf>
> %RDI<def> = MOV64ri <ga:@.str>
> %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
> %ESI<def> = COPY %EBX<kill>
> CALL64r %RCX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def,dead>
> ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> RET
********** EMITTING LIVE DEBUG VARIABLES **********
********** Stack Slot Coloring **********
********** Function: func
******** Post-regalloc Machine LICM: func ********

Setting up live-ins for BB#0 derived from entry.
Block has no FP live-ins.

FPInst:	RET
Stack contents:
Inserted instructions:
	RET
Stack contents:
alloc FI(0) at SP[-28]
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: func
real copy:   %EBX<def> = COPY %EDI
replaced by: %EBX<def> = MOV32rr %EDI
real copy:   %ESI<def> = COPY %EBX<kill>
replaced by: %ESI<def> = MOV32rr %EBX<kill>
RPO[BB#0 derived from LLVM BB entry] = 1
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#0 derived from LLVM BB entry)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0.0
Frequency(BB#0 derived from LLVM BB entry) = 1.0
LoopExitProb[BB#0 derived from LLVM BB entry] = 16383 / 16384 = 99.9939% from 1 - 0.0 / 1.0.
********** FIX EXECUTION DEPENDENCIES: VR128 **********
BB#0: entry
JITTing function 'func'
JIT: Starting CodeGen of Function func
JIT: Emitting BB0 at [0x7f7e4367b240]
PUSH64r %RBP<kill>, %RSP<imp-def>, %RSP<imp-use>; flags: FrameSetup
PROLOG_LABEL <MCSym=.Ltmp21>
%RBP<def> = MOV64rr %RSP; flags: FrameSetup
PROLOG_LABEL <MCSym=.Ltmp22>
PUSH64r %RBX<kill>, %RSP<imp-def>, %RSP<imp-use>; flags: FrameSetup
PUSH64r %RAX<undef>, %RSP<imp-def>, %RSP<imp-use>; flags: FrameSetup
PROLOG_LABEL <MCSym=.Ltmp23>
%EBX<def> = MOV32rr %EDI
%EAX<def> = MOV32ri64 8971440, %RAX<imp-def>
%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
CALL64r %RAX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>
MOV32mr %RBP, 1, %noreg, -12, %noreg, %EBX; mem:ST4[%i.addr]
%RCX<def> = MOV64ri <ga:@printf>
%RDI<def> = MOV64ri <ga:@.str>
%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
%ESI<def> = MOV32rr %EBX<kill>
CALL64r %RCX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def,dead>
%RSP<def,tied1> = ADD64ri8 %RSP<tied0>, 8, %EFLAGS<imp-def,dead>
%RBX<def> = POP64r %RSP<imp-def>, %RSP<imp-use>
%RBP<def> = POP64r %RSP<imp-def>, %RSP<imp-use>
RET
JIT: Finished CodeGen of [0x7f7e4367b240] Function: func: 61 bytes of text, 2 relocations
JIT: Binary code:
JIT: 0: 2291377285 2511378083 136228176184 941601910 
JIT: 16: 1601902231 2552226126 24493137208 24324018572 
JIT: 32: 05350132 1917200 6710217616 00127126 
JIT: 48: 22213719249 13172209255 93918196 195
Inside Func callback func
JIT: Map 'func' to [0x0]
CGP: Found      local addrmode: [Base:%i.addr]
CGP: Found      local addrmode: [Base:%i.addr]
Computing probabilities for entry



=== func
Initial selection DAG: BB#0 'func:entry'
SelectionDAG has 37 nodes:
  0x2e5c478: ch = EntryToken

  0x2e7fbb0: i64 = TargetConstant<0>

  0x2e84340: i64 = Register %RDI

      0x2e5c478: <multiple use>
      0x2e7fbb0: <multiple use>
    0x2e7f7b0: ch,glue = callseq_start 0x2e5c478, 0x2e7fbb0 [ORD=83]

    0x2e84340: <multiple use>
    0x2e83e40: i64 = Constant<48717472>

  0x2e7feb0: ch,glue = CopyToReg 0x2e7f7b0, 0x2e84340, 0x2e83e40 [ORD=83]

  0x2ea9880: i64 = Register %RSI

    0x2e7feb0: <multiple use>
    0x2ea9880: <multiple use>
    0x2e84040: i64 = Constant<48397984>

    0x2e7feb0: <multiple use>
  0x2e7f4b0: ch,glue = CopyToReg 0x2e7feb0, 0x2ea9880, 0x2e84040, 0x2e7feb0:1 [ORD=83]

  0x2e83f40: Untyped = RegisterMask

    0x2e7f4b0: <multiple use>
    0x2eaa180: i64 = Constant<8971440>

    0x2e84340: <multiple use>
    0x2ea9880: <multiple use>
    0x2e83f40: <multiple use>
    0x2e7f4b0: <multiple use>
  0x2e800b0: ch,glue = X86ISD::CALL 0x2e7f4b0, 0x2eaa180, 0x2e84340, 0x2ea9880, 0x2e83f40, 0x2e7f4b0:1 [ORD=83]

    0x2e800b0: <multiple use>
    0x2e7fbb0: <multiple use>
    0x2e7fbb0: <multiple use>
    0x2e800b0: <multiple use>
  0x2e7f6b0: ch,glue = callseq_end 0x2e800b0, 0x2e7fbb0, 0x2e7fbb0, 0x2e800b0:1 [ORD=83]

  0x2eaa380: i64 = FrameIndex<0>

  0x2ea9d80: i64 = Constant<0>

  0x2e7f5b0: i64 = undef

        0x2e7f6b0: <multiple use>
        0x2e801b0: i64 = Register %RAX

        0x2e7f6b0: <multiple use>
      0x2ea9f80: i64,ch,glue = CopyFromReg 0x2e7f6b0, 0x2e801b0, 0x2e7f6b0:1 [ORD=83]

        0x2e5c478: <multiple use>
        0x2eaa9d0: i32 = Register %vreg0

      0x2eaa280: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=79]

      0x2eaa380: <multiple use>
      0x2e7f5b0: <multiple use>
    0x2e83b40: ch = store 0x2ea9f80:1, 0x2eaa280, 0x2eaa380, 0x2e7f5b0<ST4[%i.addr]> [ORD=85]

    0x2eaa380: <multiple use>
    0x2e7f5b0: <multiple use>
  0x2e83d40: i32,ch = load 0x2e83b40, 0x2eaa380, 0x2e7f5b0<LD4[%i.addr]> [ORD=86]

      0x2e83d40: <multiple use>
      0x2e7fbb0: <multiple use>
    0x2e7f8b0: ch,glue = callseq_start 0x2e83d40:1, 0x2e7fbb0 [ORD=87]

    0x2e84340: <multiple use>
    0x2eaa8d0: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=87]

  0x2ea9680: ch,glue = CopyToReg 0x2e7f8b0, 0x2e84340, 0x2eaa8d0 [ORD=87]

  0x2e84640: i32 = Register %ESI

    0x2ea9680: <multiple use>
    0x2e84640: <multiple use>
    0x2e83d40: <multiple use>
    0x2ea9680: <multiple use>
  0x2eaa480: ch,glue = CopyToReg 0x2ea9680, 0x2e84640, 0x2e83d40, 0x2ea9680:1 [ORD=87]

  0x2e84840: i8 = Register %AL

    0x2eaa480: <multiple use>
    0x2e84840: <multiple use>
    0x2e83c40: i8 = Constant<0>

    0x2eaa480: <multiple use>
  0x2ea9980: ch,glue = CopyToReg 0x2eaa480, 0x2e84840, 0x2e83c40, 0x2eaa480:1 [ORD=87]

    0x2ea9980: <multiple use>
    0x2eaa080: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=87]

    0x2e84340: <multiple use>
    0x2e84640: <multiple use>
    0x2e84840: <multiple use>
    0x2e83f40: <multiple use>
    0x2ea9980: <multiple use>
  0x2e84440: ch,glue = X86ISD::CALL 0x2ea9980, 0x2eaa080, 0x2e84340, 0x2e84640, 0x2e84840, 0x2e83f40, 0x2ea9980:1 [ORD=87]

    0x2e84440: <multiple use>
    0x2e7fbb0: <multiple use>
    0x2e7fbb0: <multiple use>
    0x2e84440: <multiple use>
  0x2e7fcb0: ch,glue = callseq_end 0x2e84440, 0x2e7fbb0, 0x2e7fbb0, 0x2e84440:1 [ORD=87]

      0x2e7fcb0: <multiple use>
      0x2e7fdb0: i32 = Register %EAX

      0x2e7fcb0: <multiple use>
    0x2e7f3b0: i32,ch,glue = CopyFromReg 0x2e7fcb0, 0x2e7fdb0, 0x2e7fcb0:1 [ORD=87]

    0x2ea9780: i16 = TargetConstant<0>

  0x2ea9b80: ch = X86ISD::RET_FLAG 0x2e7f3b0:1, 0x2ea9780 [ORD=88]



Replacing.1 0x2e83d40: i32,ch = load 0x2e83b40, 0x2eaa380, 0x2e7f5b0<LD4[%i.addr]> [ORD=86]

With: 0x2eaa280: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=79]
 and 1 other values
Optimized lowered selection DAG: BB#0 'func:entry'
SelectionDAG has 35 nodes:
  0x2e5c478: ch = EntryToken

    0x2e5c478: <multiple use>
    0x2eaa9d0: i32 = Register %vreg0

  0x2eaa280: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=79]

  0x2e7fbb0: i64 = TargetConstant<0>

  0x2e84340: i64 = Register %RDI

      0x2e5c478: <multiple use>
      0x2e7fbb0: <multiple use>
    0x2e7f7b0: ch,glue = callseq_start 0x2e5c478, 0x2e7fbb0 [ORD=83]

    0x2e84340: <multiple use>
    0x2e83e40: i64 = Constant<48717472>

  0x2e7feb0: ch,glue = CopyToReg 0x2e7f7b0, 0x2e84340, 0x2e83e40 [ORD=83]

  0x2ea9880: i64 = Register %RSI

    0x2e7feb0: <multiple use>
    0x2ea9880: <multiple use>
    0x2e84040: i64 = Constant<48397984>

    0x2e7feb0: <multiple use>
  0x2e7f4b0: ch,glue = CopyToReg 0x2e7feb0, 0x2ea9880, 0x2e84040, 0x2e7feb0:1 [ORD=83]

  0x2e83f40: Untyped = RegisterMask

    0x2e7f4b0: <multiple use>
    0x2eaa180: i64 = Constant<8971440>

    0x2e84340: <multiple use>
    0x2ea9880: <multiple use>
    0x2e83f40: <multiple use>
    0x2e7f4b0: <multiple use>
  0x2e800b0: ch,glue = X86ISD::CALL 0x2e7f4b0, 0x2eaa180, 0x2e84340, 0x2ea9880, 0x2e83f40, 0x2e7f4b0:1 [ORD=83]

    0x2e800b0: <multiple use>
    0x2e7fbb0: <multiple use>
    0x2e7fbb0: <multiple use>
    0x2e800b0: <multiple use>
  0x2e7f6b0: ch,glue = callseq_end 0x2e800b0, 0x2e7fbb0, 0x2e7fbb0, 0x2e800b0:1 [ORD=83]

          0x2e7f6b0: <multiple use>
          0x2e801b0: i64 = Register %RAX

          0x2e7f6b0: <multiple use>
        0x2ea9f80: i64,ch,glue = CopyFromReg 0x2e7f6b0, 0x2e801b0, 0x2e7f6b0:1 [ORD=83]

        0x2eaa280: <multiple use>
        0x2eaa380: i64 = FrameIndex<0>

        0x2e7f5b0: i64 = undef

      0x2e83b40: ch = store 0x2ea9f80:1, 0x2eaa280, 0x2eaa380, 0x2e7f5b0<ST4[%i.addr]> [ORD=85]

      0x2e7fbb0: <multiple use>
    0x2e7f8b0: ch,glue = callseq_start 0x2e83b40, 0x2e7fbb0 [ORD=87]

    0x2e84340: <multiple use>
    0x2eaa8d0: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=87]

  0x2ea9680: ch,glue = CopyToReg 0x2e7f8b0, 0x2e84340, 0x2eaa8d0 [ORD=87]

  0x2e84640: i32 = Register %ESI

    0x2ea9680: <multiple use>
    0x2e84640: <multiple use>
    0x2eaa280: <multiple use>
    0x2ea9680: <multiple use>
  0x2eaa480: ch,glue = CopyToReg 0x2ea9680, 0x2e84640, 0x2eaa280, 0x2ea9680:1 [ORD=87]

  0x2e84840: i8 = Register %AL

    0x2eaa480: <multiple use>
    0x2e84840: <multiple use>
    0x2e83c40: i8 = Constant<0>

    0x2eaa480: <multiple use>
  0x2ea9980: ch,glue = CopyToReg 0x2eaa480, 0x2e84840, 0x2e83c40, 0x2eaa480:1 [ORD=87]

    0x2ea9980: <multiple use>
    0x2eaa080: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=87]

    0x2e84340: <multiple use>
    0x2e84640: <multiple use>
    0x2e84840: <multiple use>
    0x2e83f40: <multiple use>
    0x2ea9980: <multiple use>
  0x2e84440: ch,glue = X86ISD::CALL 0x2ea9980, 0x2eaa080, 0x2e84340, 0x2e84640, 0x2e84840, 0x2e83f40, 0x2ea9980:1 [ORD=87]

    0x2e84440: <multiple use>
    0x2e7fbb0: <multiple use>
    0x2e7fbb0: <multiple use>
    0x2e84440: <multiple use>
  0x2e7fcb0: ch,glue = callseq_end 0x2e84440, 0x2e7fbb0, 0x2e7fbb0, 0x2e84440:1 [ORD=87]

      0x2e7fcb0: <multiple use>
      0x2e7fdb0: i32 = Register %EAX

      0x2e7fcb0: <multiple use>
    0x2e7f3b0: i32,ch,glue = CopyFromReg 0x2e7fcb0, 0x2e7fdb0, 0x2e7fcb0:1 [ORD=87]

    0x2ea9780: i16 = TargetConstant<0>

  0x2ea9b80: ch = X86ISD::RET_FLAG 0x2e7f3b0:1, 0x2ea9780 [ORD=88]


Legally typed node: 0x2ea9780: i16 = TargetConstant<0> [ID=0]

Legally typed node: 0x2e7fdb0: i32 = Register %EAX [ID=0]

Legally typed node: 0x2e84840: i8 = Register %AL [ID=0]

Legally typed node: 0x2e84640: i32 = Register %ESI [ID=0]

Legally typed node: 0x2e83c40: i8 = Constant<0> [ID=0]

Legally typed node: 0x2eaa8d0: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=87] [ID=0]

Legally typed node: 0x2eaa080: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=87] [ID=0]

Legally typed node: 0x2e7f5b0: i64 = undef [ID=0]

Legally typed node: 0x2eaa380: i64 = FrameIndex<0> [ID=0]

Legally typed node: 0x2e801b0: i64 = Register %RAX [ID=0]

Legally typed node: 0x2e83f40: Untyped = RegisterMask [ID=0]

Legally typed node: 0x2ea9880: i64 = Register %RSI [ID=0]

Legally typed node: 0x2e84340: i64 = Register %RDI [ID=0]

Legally typed node: 0x2e7fbb0: i64 = TargetConstant<0> [ID=0]

Legally typed node: 0x2e84040: i64 = Constant<48397984> [ID=0]

Legally typed node: 0x2e83e40: i64 = Constant<48717472> [ID=0]

Legally typed node: 0x2eaa180: i64 = Constant<8971440> [ID=0]

Legally typed node: 0x2eaa9d0: i32 = Register %vreg0 [ID=0]

Legally typed node: 0x2e5c478: ch = EntryToken [ID=0]

Legally typed node: 0x2eaa280: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=79] [ID=0]

Legally typed node: 0x2e7f7b0: ch,glue = callseq_start 0x2e5c478, 0x2e7fbb0 [ORD=83] [ID=0]

Legally typed node: 0x2e7feb0: ch,glue = CopyToReg 0x2e7f7b0, 0x2e84340, 0x2e83e40 [ORD=83] [ID=0]

Legally typed node: 0x2e7f4b0: ch,glue = CopyToReg 0x2e7feb0, 0x2ea9880, 0x2e84040, 0x2e7feb0:1 [ORD=83] [ID=0]

Legally typed node: 0x2e800b0: ch,glue = X86ISD::CALL 0x2e7f4b0, 0x2eaa180, 0x2e84340, 0x2ea9880, 0x2e83f40, 0x2e7f4b0:1 [ORD=83] [ID=0]

Legally typed node: 0x2e7f6b0: ch,glue = callseq_end 0x2e800b0, 0x2e7fbb0, 0x2e7fbb0, 0x2e800b0:1 [ORD=83] [ID=0]

Legally typed node: 0x2ea9f80: i64,ch,glue = CopyFromReg 0x2e7f6b0, 0x2e801b0, 0x2e7f6b0:1 [ORD=83] [ID=0]

Legally typed node: 0x2e83b40: ch = store 0x2ea9f80:1, 0x2eaa280, 0x2eaa380, 0x2e7f5b0<ST4[%i.addr]> [ORD=85] [ID=0]

Legally typed node: 0x2e7f8b0: ch,glue = callseq_start 0x2e83b40, 0x2e7fbb0 [ORD=87] [ID=0]

Legally typed node: 0x2ea9680: ch,glue = CopyToReg 0x2e7f8b0, 0x2e84340, 0x2eaa8d0 [ORD=87] [ID=0]

Legally typed node: 0x2eaa480: ch,glue = CopyToReg 0x2ea9680, 0x2e84640, 0x2eaa280, 0x2ea9680:1 [ORD=87] [ID=0]

Legally typed node: 0x2ea9980: ch,glue = CopyToReg 0x2eaa480, 0x2e84840, 0x2e83c40, 0x2eaa480:1 [ORD=87] [ID=0]

Legally typed node: 0x2e84440: ch,glue = X86ISD::CALL 0x2ea9980, 0x2eaa080, 0x2e84340, 0x2e84640, 0x2e84840, 0x2e83f40, 0x2ea9980:1 [ORD=87] [ID=0]

Legally typed node: 0x2e7fcb0: ch,glue = callseq_end 0x2e84440, 0x2e7fbb0, 0x2e7fbb0, 0x2e84440:1 [ORD=87] [ID=0]

Legally typed node: 0x2e7f3b0: i32,ch,glue = CopyFromReg 0x2e7fcb0, 0x2e7fdb0, 0x2e7fcb0:1 [ORD=87] [ID=0]

Legally typed node: 0x2ea9b80: ch = X86ISD::RET_FLAG 0x2e7f3b0:1, 0x2ea9780 [ORD=88] [ID=0]

Legally typed node: 0x7fff29e7ba10: ch = handlenode 0x2ea9b80 [ID=0]

Type-legalized selection DAG: BB#0 'func:entry'
SelectionDAG has 35 nodes:
  0x2e5c478: ch = EntryToken [ID=-3]

    0x2e5c478: <multiple use>
    0x2eaa9d0: i32 = Register %vreg0 [ID=-3]

  0x2eaa280: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=79] [ID=-3]

  0x2e7fbb0: i64 = TargetConstant<0> [ID=-3]

  0x2e84340: i64 = Register %RDI [ID=-3]

      0x2e5c478: <multiple use>
      0x2e7fbb0: <multiple use>
    0x2e7f7b0: ch,glue = callseq_start 0x2e5c478, 0x2e7fbb0 [ORD=83] [ID=-3]

    0x2e84340: <multiple use>
    0x2e83e40: i64 = Constant<48717472> [ID=-3]

  0x2e7feb0: ch,glue = CopyToReg 0x2e7f7b0, 0x2e84340, 0x2e83e40 [ORD=83] [ID=-3]

  0x2ea9880: i64 = Register %RSI [ID=-3]

    0x2e7feb0: <multiple use>
    0x2ea9880: <multiple use>
    0x2e84040: i64 = Constant<48397984> [ID=-3]

    0x2e7feb0: <multiple use>
  0x2e7f4b0: ch,glue = CopyToReg 0x2e7feb0, 0x2ea9880, 0x2e84040, 0x2e7feb0:1 [ORD=83] [ID=-3]

  0x2e83f40: Untyped = RegisterMask [ID=-3]

    0x2e7f4b0: <multiple use>
    0x2eaa180: i64 = Constant<8971440> [ID=-3]

    0x2e84340: <multiple use>
    0x2ea9880: <multiple use>
    0x2e83f40: <multiple use>
    0x2e7f4b0: <multiple use>
  0x2e800b0: ch,glue = X86ISD::CALL 0x2e7f4b0, 0x2eaa180, 0x2e84340, 0x2ea9880, 0x2e83f40, 0x2e7f4b0:1 [ORD=83] [ID=-3]

    0x2e800b0: <multiple use>
    0x2e7fbb0: <multiple use>
    0x2e7fbb0: <multiple use>
    0x2e800b0: <multiple use>
  0x2e7f6b0: ch,glue = callseq_end 0x2e800b0, 0x2e7fbb0, 0x2e7fbb0, 0x2e800b0:1 [ORD=83] [ID=-3]

          0x2e7f6b0: <multiple use>
          0x2e801b0: i64 = Register %RAX [ID=-3]

          0x2e7f6b0: <multiple use>
        0x2ea9f80: i64,ch,glue = CopyFromReg 0x2e7f6b0, 0x2e801b0, 0x2e7f6b0:1 [ORD=83] [ID=-3]

        0x2eaa280: <multiple use>
        0x2eaa380: i64 = FrameIndex<0> [ID=-3]

        0x2e7f5b0: i64 = undef [ID=-3]

      0x2e83b40: ch = store 0x2ea9f80:1, 0x2eaa280, 0x2eaa380, 0x2e7f5b0<ST4[%i.addr]> [ORD=85] [ID=-3]

      0x2e7fbb0: <multiple use>
    0x2e7f8b0: ch,glue = callseq_start 0x2e83b40, 0x2e7fbb0 [ORD=87] [ID=-3]

    0x2e84340: <multiple use>
    0x2eaa8d0: i64 = GlobalAddress<[4 x i8]* @.str> 0 [ORD=87] [ID=-3]

  0x2ea9680: ch,glue = CopyToReg 0x2e7f8b0, 0x2e84340, 0x2eaa8d0 [ORD=87] [ID=-3]

  0x2e84640: i32 = Register %ESI [ID=-3]

    0x2ea9680: <multiple use>
    0x2e84640: <multiple use>
    0x2eaa280: <multiple use>
    0x2ea9680: <multiple use>
  0x2eaa480: ch,glue = CopyToReg 0x2ea9680, 0x2e84640, 0x2eaa280, 0x2ea9680:1 [ORD=87] [ID=-3]

  0x2e84840: i8 = Register %AL [ID=-3]

    0x2eaa480: <multiple use>
    0x2e84840: <multiple use>
    0x2e83c40: i8 = Constant<0> [ID=-3]

    0x2eaa480: <multiple use>
  0x2ea9980: ch,glue = CopyToReg 0x2eaa480, 0x2e84840, 0x2e83c40, 0x2eaa480:1 [ORD=87] [ID=-3]

    0x2ea9980: <multiple use>
    0x2eaa080: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=87] [ID=-3]

    0x2e84340: <multiple use>
    0x2e84640: <multiple use>
    0x2e84840: <multiple use>
    0x2e83f40: <multiple use>
    0x2ea9980: <multiple use>
  0x2e84440: ch,glue = X86ISD::CALL 0x2ea9980, 0x2eaa080, 0x2e84340, 0x2e84640, 0x2e84840, 0x2e83f40, 0x2ea9980:1 [ORD=87] [ID=-3]

    0x2e84440: <multiple use>
    0x2e7fbb0: <multiple use>
    0x2e7fbb0: <multiple use>
    0x2e84440: <multiple use>
  0x2e7fcb0: ch,glue = callseq_end 0x2e84440, 0x2e7fbb0, 0x2e7fbb0, 0x2e84440:1 [ORD=87] [ID=-3]

      0x2e7fcb0: <multiple use>
      0x2e7fdb0: i32 = Register %EAX [ID=-3]

      0x2e7fcb0: <multiple use>
    0x2e7f3b0: i32,ch,glue = CopyFromReg 0x2e7fcb0, 0x2e7fdb0, 0x2e7fcb0:1 [ORD=87] [ID=-3]

    0x2ea9780: i16 = TargetConstant<0> [ID=-3]

  0x2ea9b80: ch = X86ISD::RET_FLAG 0x2e7f3b0:1, 0x2ea9780 [ORD=88] [ID=-3]


Legalized selection DAG: BB#0 'func:entry'
SelectionDAG has 37 nodes:
  0x2e5c478: ch = EntryToken [ID=0]

  0x2e7fbb0: i64 = TargetConstant<0> [ID=5]

  0x2e84340: i64 = Register %RDI [ID=6]

  0x2ea9880: i64 = Register %RSI [ID=7]

  0x2e83f40: Untyped = RegisterMask [ID=8]

  0x2e84640: i32 = Register %ESI [ID=15]

  0x2e84840: i8 = Register %AL [ID=16]

    0x2e5c478: <multiple use>
    0x2eaa9d0: i32 = Register %vreg0 [ID=1]

  0x2eaa280: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=79] [ID=19]

      0x2e5c478: <multiple use>
      0x2e7fbb0: <multiple use>
    0x2e7f7b0: ch,glue = callseq_start 0x2e5c478, 0x2e7fbb0 [ORD=83] [ID=20]

    0x2e84340: <multiple use>
    0x2e83e40: i64 = Constant<48717472> [ID=3]

  0x2e7feb0: ch,glue = CopyToReg 0x2e7f7b0, 0x2e84340, 0x2e83e40 [ORD=83] [ID=21]

    0x2e7feb0: <multiple use>
    0x2ea9880: <multiple use>
    0x2e84040: i64 = Constant<48397984> [ID=4]

    0x2e7feb0: <multiple use>
  0x2e7f4b0: ch,glue = CopyToReg 0x2e7feb0, 0x2ea9880, 0x2e84040, 0x2e7feb0:1 [ORD=83] [ID=22]

    0x2e7f4b0: <multiple use>
    0x2eaa180: i64 = Constant<8971440> [ID=2]

    0x2e84340: <multiple use>
    0x2ea9880: <multiple use>
    0x2e83f40: <multiple use>
    0x2e7f4b0: <multiple use>
  0x2e800b0: ch,glue = X86ISD::CALL 0x2e7f4b0, 0x2eaa180, 0x2e84340, 0x2ea9880, 0x2e83f40, 0x2e7f4b0:1 [ORD=83] [ID=23]

    0x2e800b0: <multiple use>
    0x2e7fbb0: <multiple use>
    0x2e7fbb0: <multiple use>
    0x2e800b0: <multiple use>
  0x2e7f6b0: ch,glue = callseq_end 0x2e800b0, 0x2e7fbb0, 0x2e7fbb0, 0x2e800b0:1 [ORD=83] [ID=24]

          0x2e7f6b0: <multiple use>
          0x2e801b0: i64 = Register %RAX [ID=9]

          0x2e7f6b0: <multiple use>
        0x2ea9f80: i64,ch,glue = CopyFromReg 0x2e7f6b0, 0x2e801b0, 0x2e7f6b0:1 [ORD=83] [ID=25]

        0x2eaa280: <multiple use>
        0x2eaa380: i64 = FrameIndex<0> [ID=10]

        0x2e7f5b0: i64 = undef [ID=11]

      0x2e83b40: ch = store 0x2ea9f80:1, 0x2eaa280, 0x2eaa380, 0x2e7f5b0<ST4[%i.addr]> [ORD=85] [ID=26]

      0x2e7fbb0: <multiple use>
    0x2e7f8b0: ch,glue = callseq_start 0x2e83b40, 0x2e7fbb0 [ORD=87] [ID=27]

    0x2e84340: <multiple use>
      0x2ea9d80: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=87]

    0x2e83d40: i64 = X86ISD::Wrapper 0x2ea9d80 [ORD=87]

  0x2ea9680: ch,glue = CopyToReg 0x2e7f8b0, 0x2e84340, 0x2e83d40 [ORD=87] [ID=28]

    0x2ea9680: <multiple use>
    0x2e84640: <multiple use>
    0x2eaa280: <multiple use>
    0x2ea9680: <multiple use>
  0x2eaa480: ch,glue = CopyToReg 0x2ea9680, 0x2e84640, 0x2eaa280, 0x2ea9680:1 [ORD=87] [ID=29]

    0x2eaa480: <multiple use>
    0x2e84840: <multiple use>
    0x2e83c40: i8 = Constant<0> [ID=14]

    0x2eaa480: <multiple use>
  0x2ea9980: ch,glue = CopyToReg 0x2eaa480, 0x2e84840, 0x2e83c40, 0x2eaa480:1 [ORD=87] [ID=30]

    0x2ea9980: <multiple use>
      0x2eaa8d0: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=87]

    0x2ea9c80: i64 = X86ISD::Wrapper 0x2eaa8d0 [ORD=87]

    0x2e84340: <multiple use>
    0x2e84640: <multiple use>
    0x2e84840: <multiple use>
    0x2e83f40: <multiple use>
    0x2ea9980: <multiple use>
  0x2e84440: ch,glue = X86ISD::CALL 0x2ea9980, 0x2ea9c80, 0x2e84340, 0x2e84640, 0x2e84840, 0x2e83f40, 0x2ea9980:1 [ORD=87] [ID=31]

    0x2e84440: <multiple use>
    0x2e7fbb0: <multiple use>
    0x2e7fbb0: <multiple use>
    0x2e84440: <multiple use>
  0x2e7fcb0: ch,glue = callseq_end 0x2e84440, 0x2e7fbb0, 0x2e7fbb0, 0x2e84440:1 [ORD=87] [ID=32]

      0x2e7fcb0: <multiple use>
      0x2e7fdb0: i32 = Register %EAX [ID=17]

      0x2e7fcb0: <multiple use>
    0x2e7f3b0: i32,ch,glue = CopyFromReg 0x2e7fcb0, 0x2e7fdb0, 0x2e7fcb0:1 [ORD=87] [ID=33]

    0x2ea9780: i16 = TargetConstant<0> [ID=18]

  0x2ea9b80: ch = X86ISD::RET_FLAG 0x2e7f3b0:1, 0x2ea9780 [ORD=88] [ID=34]


Optimized legalized selection DAG: BB#0 'func:entry'
SelectionDAG has 37 nodes:
  0x2e5c478: ch = EntryToken [ID=0]

  0x2e7fbb0: i64 = TargetConstant<0> [ID=5]

  0x2e84340: i64 = Register %RDI [ID=6]

  0x2ea9880: i64 = Register %RSI [ID=7]

  0x2e83f40: Untyped = RegisterMask [ID=8]

  0x2e84640: i32 = Register %ESI [ID=15]

  0x2e84840: i8 = Register %AL [ID=16]

    0x2e5c478: <multiple use>
    0x2eaa9d0: i32 = Register %vreg0 [ID=1]

  0x2eaa280: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=79] [ID=19]

      0x2e5c478: <multiple use>
      0x2e7fbb0: <multiple use>
    0x2e7f7b0: ch,glue = callseq_start 0x2e5c478, 0x2e7fbb0 [ORD=83] [ID=20]

    0x2e84340: <multiple use>
    0x2e83e40: i64 = Constant<48717472> [ID=3]

  0x2e7feb0: ch,glue = CopyToReg 0x2e7f7b0, 0x2e84340, 0x2e83e40 [ORD=83] [ID=21]

    0x2e7feb0: <multiple use>
    0x2ea9880: <multiple use>
    0x2e84040: i64 = Constant<48397984> [ID=4]

    0x2e7feb0: <multiple use>
  0x2e7f4b0: ch,glue = CopyToReg 0x2e7feb0, 0x2ea9880, 0x2e84040, 0x2e7feb0:1 [ORD=83] [ID=22]

    0x2e7f4b0: <multiple use>
    0x2eaa180: i64 = Constant<8971440> [ID=2]

    0x2e84340: <multiple use>
    0x2ea9880: <multiple use>
    0x2e83f40: <multiple use>
    0x2e7f4b0: <multiple use>
  0x2e800b0: ch,glue = X86ISD::CALL 0x2e7f4b0, 0x2eaa180, 0x2e84340, 0x2ea9880, 0x2e83f40, 0x2e7f4b0:1 [ORD=83] [ID=23]

    0x2e800b0: <multiple use>
    0x2e7fbb0: <multiple use>
    0x2e7fbb0: <multiple use>
    0x2e800b0: <multiple use>
  0x2e7f6b0: ch,glue = callseq_end 0x2e800b0, 0x2e7fbb0, 0x2e7fbb0, 0x2e800b0:1 [ORD=83] [ID=24]

          0x2e7f6b0: <multiple use>
          0x2e801b0: i64 = Register %RAX [ID=9]

          0x2e7f6b0: <multiple use>
        0x2ea9f80: i64,ch,glue = CopyFromReg 0x2e7f6b0, 0x2e801b0, 0x2e7f6b0:1 [ORD=83] [ID=25]

        0x2eaa280: <multiple use>
        0x2eaa380: i64 = FrameIndex<0> [ID=10]

        0x2e7f5b0: i64 = undef [ID=11]

      0x2e83b40: ch = store 0x2ea9f80:1, 0x2eaa280, 0x2eaa380, 0x2e7f5b0<ST4[%i.addr]> [ORD=85] [ID=26]

      0x2e7fbb0: <multiple use>
    0x2e7f8b0: ch,glue = callseq_start 0x2e83b40, 0x2e7fbb0 [ORD=87] [ID=27]

    0x2e84340: <multiple use>
      0x2ea9d80: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=87]

    0x2e83d40: i64 = X86ISD::Wrapper 0x2ea9d80 [ORD=87]

  0x2ea9680: ch,glue = CopyToReg 0x2e7f8b0, 0x2e84340, 0x2e83d40 [ORD=87] [ID=28]

    0x2ea9680: <multiple use>
    0x2e84640: <multiple use>
    0x2eaa280: <multiple use>
    0x2ea9680: <multiple use>
  0x2eaa480: ch,glue = CopyToReg 0x2ea9680, 0x2e84640, 0x2eaa280, 0x2ea9680:1 [ORD=87] [ID=29]

    0x2eaa480: <multiple use>
    0x2e84840: <multiple use>
    0x2e83c40: i8 = Constant<0> [ID=14]

    0x2eaa480: <multiple use>
  0x2ea9980: ch,glue = CopyToReg 0x2eaa480, 0x2e84840, 0x2e83c40, 0x2eaa480:1 [ORD=87] [ID=30]

    0x2ea9980: <multiple use>
      0x2eaa8d0: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=87]

    0x2ea9c80: i64 = X86ISD::Wrapper 0x2eaa8d0 [ORD=87]

    0x2e84340: <multiple use>
    0x2e84640: <multiple use>
    0x2e84840: <multiple use>
    0x2e83f40: <multiple use>
    0x2ea9980: <multiple use>
  0x2e84440: ch,glue = X86ISD::CALL 0x2ea9980, 0x2ea9c80, 0x2e84340, 0x2e84640, 0x2e84840, 0x2e83f40, 0x2ea9980:1 [ORD=87] [ID=31]

    0x2e84440: <multiple use>
    0x2e7fbb0: <multiple use>
    0x2e7fbb0: <multiple use>
    0x2e84440: <multiple use>
  0x2e7fcb0: ch,glue = callseq_end 0x2e84440, 0x2e7fbb0, 0x2e7fbb0, 0x2e84440:1 [ORD=87] [ID=32]

      0x2e7fcb0: <multiple use>
      0x2e7fdb0: i32 = Register %EAX [ID=17]

      0x2e7fcb0: <multiple use>
    0x2e7f3b0: i32,ch,glue = CopyFromReg 0x2e7fcb0, 0x2e7fdb0, 0x2e7fcb0:1 [ORD=87] [ID=33]

    0x2ea9780: i16 = TargetConstant<0> [ID=18]

  0x2ea9b80: ch = X86ISD::RET_FLAG 0x2e7f3b0:1, 0x2ea9780 [ORD=88] [ID=34]


===== Instruction selection begins: BB#0 'entry'
Selecting: 0x2ea9b80: ch = X86ISD::RET_FLAG 0x2e7f3b0:1, 0x2ea9780 [ORD=88] [ID=36]

ISEL: Starting pattern match on root node: 0x2ea9b80: ch = X86ISD::RET_FLAG 0x2e7f3b0:1, 0x2ea9780 [ORD=88] [ID=36]

  Initial Opcode index to 93235
  Morphed node: 0x2ea9b80: ch = RET 0x2e7f3b0:1 [ORD=88]

ISEL: Match complete!
=> 0x2ea9b80: ch = RET 0x2e7f3b0:1 [ORD=88]

Selecting: 0x2e7f3b0: i32,ch,glue = CopyFromReg 0x2e7fcb0, 0x2e7fdb0, 0x2e7fcb0:1 [ORD=87] [ID=35]

=> 0x2e7f3b0: i32,ch,glue = CopyFromReg 0x2e7fcb0, 0x2e7fdb0, 0x2e7fcb0:1 [ORD=87]

Selecting: 0x2e7fcb0: ch,glue = callseq_end 0x2e84440, 0x2e7fbb0, 0x2e7fbb0, 0x2e84440:1 [ORD=87] [ID=34]

ISEL: Starting pattern match on root node: 0x2e7fcb0: ch,glue = callseq_end 0x2e84440, 0x2e7fbb0, 0x2e7fbb0, 0x2e84440:1 [ORD=87] [ID=34]

  Initial Opcode index to 92907
  Skipped scope entry (due to false predicate) at index 92925, continuing at 92937
  Morphed node: 0x2e7fcb0: i64,ch,glue = ADJCALLSTACKUP64 0x2e7fbb0, 0x2e7fbb0, 0x2e84440, 0x2e84440:1 [ORD=87]

ISEL: Match complete!
=> 0x2e7fcb0: i64,ch,glue = ADJCALLSTACKUP64 0x2e7fbb0, 0x2e7fbb0, 0x2e84440, 0x2e84440:1 [ORD=87]

Selecting: 0x2e84440: ch,glue = X86ISD::CALL 0x2ea9980, 0x2ea9c80, 0x2e84340, 0x2e84640, 0x2e84840, 0x2e83f40, 0x2ea9980:1 [ORD=87] [ID=33]

ISEL: Starting pattern match on root node: 0x2e84440: ch,glue = X86ISD::CALL 0x2ea9980, 0x2ea9c80, 0x2e84340, 0x2e84640, 0x2e84840, 0x2e83f40, 0x2ea9980:1 [ORD=87] [ID=33]

  Initial Opcode index to 69884
  Match failed at index 69890
  Continuing at 69951
  Match failed at index 69957
  Continuing at 70031
  Match failed at index 70032
  Continuing at 70044
  Morphed node: 0x2e84440: ch,glue = CALL64r 0x2ea9c80, 0x2e84340, 0x2e84640, 0x2e84840, 0x2e83f40, 0x2ea9980, 0x2ea9980:1 [ORD=87]

ISEL: Match complete!
=> 0x2e84440: ch,glue = CALL64r 0x2ea9c80, 0x2e84340, 0x2e84640, 0x2e84840, 0x2e83f40, 0x2ea9980, 0x2ea9980:1 [ORD=87]

Selecting: 0x2ea9980: ch,glue = CopyToReg 0x2eaa480, 0x2e84840, 0x2e83c40, 0x2eaa480:1 [ORD=87] [ID=32]

=> 0x2ea9980: ch,glue = CopyToReg 0x2eaa480, 0x2e84840, 0x2e83c40, 0x2eaa480:1 [ORD=87]

Selecting: 0x2eaa480: ch,glue = CopyToReg 0x2ea9680, 0x2e84640, 0x2eaa280, 0x2ea9680:1 [ORD=87] [ID=31]

=> 0x2eaa480: ch,glue = CopyToReg 0x2ea9680, 0x2e84640, 0x2eaa280, 0x2ea9680:1 [ORD=87]

Selecting: 0x2ea9680: ch,glue = CopyToReg 0x2e7f8b0, 0x2e84340, 0x2e83d40 [ORD=87] [ID=30]

=> 0x2ea9680: ch,glue = CopyToReg 0x2e7f8b0, 0x2e84340, 0x2e83d40 [ORD=87]

Selecting: 0x2e7f8b0: ch,glue = callseq_start 0x2e83b40, 0x2e7fbb0 [ORD=87] [ID=29]

ISEL: Starting pattern match on root node: 0x2e7f8b0: ch,glue = callseq_start 0x2e83b40, 0x2e7fbb0 [ORD=87] [ID=29]

  Initial Opcode index to 95380
  Skipped scope entry (due to false predicate) at index 95390, continuing at 95401
  Morphed node: 0x2e7f8b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7fbb0, 0x2e83b40 [ORD=87]

ISEL: Match complete!
=> 0x2e7f8b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7fbb0, 0x2e83b40 [ORD=87]

Selecting: 0x2e83b40: ch = store 0x2ea9f80:1, 0x2eaa280, 0x2eaa380, 0x2e7f5b0<ST4[%i.addr]> [ORD=85] [ID=28]

ISEL: Starting pattern match on root node: 0x2e83b40: ch = store 0x2ea9f80:1, 0x2eaa280, 0x2eaa380, 0x2e7f5b0<ST4[%i.addr]> [ORD=85] [ID=28]

  Initial Opcode index to 5
  Skipped scope entry (due to false predicate) at index 13, continuing at 58
  Skipped scope entry (due to false predicate) at index 59, continuing at 104
  Skipped scope entry (due to false predicate) at index 105, continuing at 188
  Skipped scope entry (due to false predicate) at index 189, continuing at 212
  Skipped scope entry (due to false predicate) at index 213, continuing at 236
  Skipped scope entry (due to false predicate) at index 237, continuing at 260
  Match failed at index 264
  Continuing at 284
  Match failed at index 285
  Continuing at 308
  Continuing at 309
  Match failed at index 313
  Continuing at 10708
  Match failed at index 10713
  Continuing at 11131
  Match failed at index 11135
  Continuing at 11509
  Match failed at index 11513
  Continuing at 11624
  Match failed at index 11628
  Continuing at 11859
  Skipped scope entry (due to false predicate) at index 11864, continuing at 11950
  Skipped scope entry (due to false predicate) at index 11951, continuing at 12064
  Skipped scope entry (due to false predicate) at index 12065, continuing at 12137
  Skipped scope entry (due to false predicate) at index 12138, continuing at 12161
  Skipped scope entry (due to false predicate) at index 12162, continuing at 12185
MatchAddress: X86ISelAddressMode 0x7fff29e7b560
Base_Reg nul Base.FrameIndex 0
 Scale1
IndexReg nul Disp 0
GV nul CP nul
ES nul JT-1 Align0
  Morphed node: 0x2e83b40: ch = MOV32mr 0x2eaa080, 0x2e84740, 0x2ea9780, 0x2ea9e80, 0x2e84240, 0x2eaa280, 0x2ea9f80:1<Mem:ST4[%i.addr]> [ORD=85]

ISEL: Match complete!
=> 0x2e83b40: ch = MOV32mr 0x2eaa080, 0x2e84740, 0x2ea9780, 0x2ea9e80, 0x2e84240, 0x2eaa280, 0x2ea9f80:1<Mem:ST4[%i.addr]> [ORD=85]

Selecting: 0x2ea9f80: i64,ch,glue = CopyFromReg 0x2e7f6b0, 0x2e801b0, 0x2e7f6b0:1 [ORD=83] [ID=27]

=> 0x2ea9f80: i64,ch,glue = CopyFromReg 0x2e7f6b0, 0x2e801b0, 0x2e7f6b0:1 [ORD=83]

Selecting: 0x2e7f6b0: ch,glue = callseq_end 0x2e800b0, 0x2e7fbb0, 0x2e7fbb0, 0x2e800b0:1 [ORD=83] [ID=26]

ISEL: Starting pattern match on root node: 0x2e7f6b0: ch,glue = callseq_end 0x2e800b0, 0x2e7fbb0, 0x2e7fbb0, 0x2e800b0:1 [ORD=83] [ID=26]

  Initial Opcode index to 92907
  Skipped scope entry (due to false predicate) at index 92925, continuing at 92937
  Morphed node: 0x2e7f6b0: i64,ch,glue = ADJCALLSTACKUP64 0x2e7fbb0, 0x2e7fbb0, 0x2e800b0, 0x2e800b0:1 [ORD=83]

ISEL: Match complete!
=> 0x2e7f6b0: i64,ch,glue = ADJCALLSTACKUP64 0x2e7fbb0, 0x2e7fbb0, 0x2e800b0, 0x2e800b0:1 [ORD=83]

Selecting: 0x2e800b0: ch,glue = X86ISD::CALL 0x2e7f4b0, 0x2eaa180, 0x2e84340, 0x2ea9880, 0x2e83f40, 0x2e7f4b0:1 [ORD=83] [ID=25]

ISEL: Starting pattern match on root node: 0x2e800b0: ch,glue = X86ISD::CALL 0x2e7f4b0, 0x2eaa180, 0x2e84340, 0x2ea9880, 0x2e83f40, 0x2e7f4b0:1 [ORD=83] [ID=25]

  Initial Opcode index to 69884
  Match failed at index 69890
  Continuing at 69951
  OpcodeSwitch from 69957 to 70015
  Match failed at index 70015
  Continuing at 70031
  Match failed at index 70032
  Continuing at 70044
  Morphed node: 0x2e800b0: ch,glue = CALL64r 0x2eaa180, 0x2e84340, 0x2ea9880, 0x2e83f40, 0x2e7f4b0, 0x2e7f4b0:1 [ORD=83]

ISEL: Match complete!
=> 0x2e800b0: ch,glue = CALL64r 0x2eaa180, 0x2e84340, 0x2ea9880, 0x2e83f40, 0x2e7f4b0, 0x2e7f4b0:1 [ORD=83]

Selecting: 0x2e7f4b0: ch,glue = CopyToReg 0x2e7feb0, 0x2ea9880, 0x2e84040, 0x2e7feb0:1 [ORD=83] [ID=24]

=> 0x2e7f4b0: ch,glue = CopyToReg 0x2e7feb0, 0x2ea9880, 0x2e84040, 0x2e7feb0:1 [ORD=83]

Selecting: 0x2e7feb0: ch,glue = CopyToReg 0x2e7f7b0, 0x2e84340, 0x2e83e40 [ORD=83] [ID=23]

=> 0x2e7feb0: ch,glue = CopyToReg 0x2e7f7b0, 0x2e84340, 0x2e83e40 [ORD=83]

Selecting: 0x2ea9c80: i64 = X86ISD::Wrapper 0x2eaa8d0 [ORD=87] [ID=22]

ISEL: Starting pattern match on root node: 0x2ea9c80: i64 = X86ISD::Wrapper 0x2eaa8d0 [ORD=87] [ID=22]

  Initial Opcode index to 94787
  Match failed at index 94792
  Continuing at 94819
  OpcodeSwitch from 94824 to 94938
  TypeSwitch[i64] from 94939 to 94952
  Morphed node: 0x2ea9c80: i64 = MOV64ri 0x2eaa8d0 [ORD=87]

ISEL: Match complete!
=> 0x2ea9c80: i64 = MOV64ri 0x2eaa8d0 [ORD=87]

Selecting: 0x2e83d40: i64 = X86ISD::Wrapper 0x2ea9d80 [ORD=87] [ID=21]

ISEL: Starting pattern match on root node: 0x2e83d40: i64 = X86ISD::Wrapper 0x2ea9d80 [ORD=87] [ID=21]

  Initial Opcode index to 94787
  Match failed at index 94792
  Continuing at 94819
  OpcodeSwitch from 94824 to 94938
  TypeSwitch[i64] from 94939 to 94952
  Morphed node: 0x2e83d40: i64 = MOV64ri 0x2ea9d80 [ORD=87]

ISEL: Match complete!
=> 0x2e83d40: i64 = MOV64ri 0x2ea9d80 [ORD=87]

Selecting: 0x2e7f7b0: ch,glue = callseq_start 0x2e5c478, 0x2e7fbb0 [ORD=83] [ID=20]

ISEL: Starting pattern match on root node: 0x2e7f7b0: ch,glue = callseq_start 0x2e5c478, 0x2e7fbb0 [ORD=83] [ID=20]

  Initial Opcode index to 95380
  Skipped scope entry (due to false predicate) at index 95390, continuing at 95401
  Morphed node: 0x2e7f7b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7fbb0, 0x2e5c478 [ORD=83]

ISEL: Match complete!
=> 0x2e7f7b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7fbb0, 0x2e5c478 [ORD=83]

Selecting: 0x2eaa280: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=79] [ID=19]

=> 0x2eaa280: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=79]

Selecting: 0x2eaa8d0: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=87] [ID=18]

=> 0x2eaa8d0: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=87]

Selecting: 0x2ea9d80: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=87] [ID=17]

=> 0x2ea9d80: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=87]

Selecting: 0x2e7fdb0: i32 = Register %EAX [ID=15]

=> 0x2e7fdb0: i32 = Register %EAX

Selecting: 0x2e84840: i8 = Register %AL [ID=14]

=> 0x2e84840: i8 = Register %AL

Selecting: 0x2e84640: i32 = Register %ESI [ID=13]

=> 0x2e84640: i32 = Register %ESI

Selecting: 0x2e83c40: i8 = Constant<0> [ID=12]

ISEL: Starting pattern match on root node: 0x2e83c40: i8 = Constant<0> [ID=12]

  Initial Opcode index to 82786
  Match failed at index 82790
  Continuing at 82816
  Match failed at index 82818
  Continuing at 82847
  TypeSwitch[i8] from 82850 to 82863
  Created node: 0x2eaa380: i32,i32 = MOV32r0

  Morphed node: 0x2e83c40: i8 = EXTRACT_SUBREG 0x2eaa380, 0x2e7f5b0

ISEL: Match complete!
=> 0x2e83c40: i8 = EXTRACT_SUBREG 0x2eaa380, 0x2e7f5b0

Selecting: 0x2e801b0: i64 = Register %RAX [ID=9]

=> 0x2e801b0: i64 = Register %RAX

Selecting: 0x2e83f40: Untyped = RegisterMask [ID=8]

=> 0x2e83f40: Untyped = RegisterMask

Selecting: 0x2ea9880: i64 = Register %RSI [ID=7]

=> 0x2ea9880: i64 = Register %RSI

Selecting: 0x2e84340: i64 = Register %RDI [ID=6]

=> 0x2e84340: i64 = Register %RDI

Selecting: 0x2e7fbb0: i64 = TargetConstant<0> [ID=5]

=> 0x2e7fbb0: i64 = TargetConstant<0>

Selecting: 0x2e84040: i64 = Constant<48397984> [ID=4]

ISEL: Starting pattern match on root node: 0x2e84040: i64 = Constant<48397984> [ID=4]

  Initial Opcode index to 82786
  Skipped scope entry (due to false predicate) at index 82788, continuing at 82816
  Created node: 0x2e84140: i32 = MOV32ri64 0x2ea9a80

  Morphed node: 0x2e84040: i64 = SUBREG_TO_REG 0x2e7fbb0, 0x2e84140, 0x2e84540

ISEL: Match complete!
=> 0x2e84040: i64 = SUBREG_TO_REG 0x2e7fbb0, 0x2e84140, 0x2e84540

Selecting: 0x2e83e40: i64 = Constant<48717472> [ID=3]

ISEL: Starting pattern match on root node: 0x2e83e40: i64 = Constant<48717472> [ID=3]

  Initial Opcode index to 82786
  Skipped scope entry (due to false predicate) at index 82788, continuing at 82816
  Created node: 0x2e7ffb0: i32 = MOV32ri64 0x2e84940

  Morphed node: 0x2e83e40: i64 = SUBREG_TO_REG 0x2e7fbb0, 0x2e7ffb0, 0x2e84540

ISEL: Match complete!
=> 0x2e83e40: i64 = SUBREG_TO_REG 0x2e7fbb0, 0x2e7ffb0, 0x2e84540

Selecting: 0x2eaa180: i64 = Constant<8971440> [ID=2]

ISEL: Starting pattern match on root node: 0x2eaa180: i64 = Constant<8971440> [ID=2]

  Initial Opcode index to 82786
  Skipped scope entry (due to false predicate) at index 82788, continuing at 82816
  Created node: 0x2e7fab0: i32 = MOV32ri64 0x2e7f9b0

  Morphed node: 0x2eaa180: i64 = SUBREG_TO_REG 0x2e7fbb0, 0x2e7fab0, 0x2e84540

ISEL: Match complete!
=> 0x2eaa180: i64 = SUBREG_TO_REG 0x2e7fbb0, 0x2e7fab0, 0x2e84540

Selecting: 0x2eaa9d0: i32 = Register %vreg0 [ID=1]

=> 0x2eaa9d0: i32 = Register %vreg0

Selecting: 0x2e5c478: ch = EntryToken [ID=0]

=> 0x2e5c478: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: BB#0 'func:entry'
SelectionDAG has 48 nodes:
  0x2e5c478: ch = EntryToken

  0x2e7fbb0: i64 = TargetConstant<0>

  0x2e84340: i64 = Register %RDI

  0x2ea9880: i64 = Register %RSI

  0x2e83f40: Untyped = RegisterMask

  0x2e84640: i32 = Register %ESI

  0x2e84840: i8 = Register %AL

    0x2e5c478: <multiple use>
    0x2eaa9d0: i32 = Register %vreg0

  0x2eaa280: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=79]

      0x2e7fbb0: <multiple use>
      0x2e5c478: <multiple use>
    0x2e7f7b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7fbb0, 0x2e5c478 [ORD=83]

    0x2e84340: <multiple use>
      0x2e7fbb0: <multiple use>
        0x2e84940: i64 = TargetConstant<48717472>

      0x2e7ffb0: i32 = MOV32ri64 0x2e84940

      0x2e84540: <multiple use>
    0x2e83e40: i64 = SUBREG_TO_REG 0x2e7fbb0, 0x2e7ffb0, 0x2e84540

  0x2e7feb0: ch,glue = CopyToReg 0x2e7f7b0:1, 0x2e84340, 0x2e83e40 [ORD=83]

    0x2e7feb0: <multiple use>
    0x2ea9880: <multiple use>
      0x2e7fbb0: <multiple use>
        0x2ea9a80: i64 = TargetConstant<48397984>

      0x2e84140: i32 = MOV32ri64 0x2ea9a80

      0x2e84540: <multiple use>
    0x2e84040: i64 = SUBREG_TO_REG 0x2e7fbb0, 0x2e84140, 0x2e84540

    0x2e7feb0: <multiple use>
  0x2e7f4b0: ch,glue = CopyToReg 0x2e7feb0, 0x2ea9880, 0x2e84040, 0x2e7feb0:1 [ORD=83]

      0x2e7fbb0: <multiple use>
        0x2e7f9b0: i64 = TargetConstant<8971440>

      0x2e7fab0: i32 = MOV32ri64 0x2e7f9b0

      0x2e84540: <multiple use>
    0x2eaa180: i64 = SUBREG_TO_REG 0x2e7fbb0, 0x2e7fab0, 0x2e84540

    0x2e84340: <multiple use>
    0x2ea9880: <multiple use>
    0x2e83f40: <multiple use>
    0x2e7f4b0: <multiple use>
    0x2e7f4b0: <multiple use>
  0x2e800b0: ch,glue = CALL64r 0x2eaa180, 0x2e84340, 0x2ea9880, 0x2e83f40, 0x2e7f4b0, 0x2e7f4b0:1 [ORD=83]

    0x2e7fbb0: <multiple use>
    0x2e7fbb0: <multiple use>
    0x2e800b0: <multiple use>
    0x2e800b0: <multiple use>
  0x2e7f6b0: i64,ch,glue = ADJCALLSTACKUP64 0x2e7fbb0, 0x2e7fbb0, 0x2e800b0, 0x2e800b0:1 [ORD=83]

      0x2e7fbb0: <multiple use>
        0x2eaa080: i64 = TargetFrameIndex<0>

        0x2e84740: i8 = TargetConstant<1>

        0x2ea9780: i64 = Register %noreg

        0x2ea9e80: i32 = TargetConstant<0>

        0x2e84240: i32 = Register %noreg

        0x2eaa280: <multiple use>
          0x2e7f6b0: <multiple use>
          0x2e801b0: i64 = Register %RAX

          0x2e7f6b0: <multiple use>
        0x2ea9f80: i64,ch,glue = CopyFromReg 0x2e7f6b0:1, 0x2e801b0, 0x2e7f6b0:2 [ORD=83]

      0x2e83b40: ch = MOV32mr 0x2eaa080, 0x2e84740, 0x2ea9780, 0x2ea9e80, 0x2e84240, 0x2eaa280, 0x2ea9f80:1<Mem:ST4[%i.addr]> [ORD=85]

    0x2e7f8b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7fbb0, 0x2e83b40 [ORD=87]

    0x2e84340: <multiple use>
      0x2ea9d80: i64 = TargetGlobalAddress<[4 x i8]* @.str> 0 [ORD=87]

    0x2e83d40: i64 = MOV64ri 0x2ea9d80 [ORD=87]

  0x2ea9680: ch,glue = CopyToReg 0x2e7f8b0:1, 0x2e84340, 0x2e83d40 [ORD=87]

    0x2ea9680: <multiple use>
    0x2e84640: <multiple use>
    0x2eaa280: <multiple use>
    0x2ea9680: <multiple use>
  0x2eaa480: ch,glue = CopyToReg 0x2ea9680, 0x2e84640, 0x2eaa280, 0x2ea9680:1 [ORD=87]

    0x2eaa480: <multiple use>
    0x2e84840: <multiple use>
      0x2eaa380: i32,i32 = MOV32r0

      0x2e7f5b0: i32 = TargetConstant<1>

    0x2e83c40: i8 = EXTRACT_SUBREG 0x2eaa380, 0x2e7f5b0

    0x2eaa480: <multiple use>
  0x2ea9980: ch,glue = CopyToReg 0x2eaa480, 0x2e84840, 0x2e83c40, 0x2eaa480:1 [ORD=87]

      0x2eaa8d0: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0 [ORD=87]

    0x2ea9c80: i64 = MOV64ri 0x2eaa8d0 [ORD=87]

    0x2e84340: <multiple use>
    0x2e84640: <multiple use>
    0x2e84840: <multiple use>
    0x2e83f40: <multiple use>
    0x2ea9980: <multiple use>
    0x2ea9980: <multiple use>
  0x2e84440: ch,glue = CALL64r 0x2ea9c80, 0x2e84340, 0x2e84640, 0x2e84840, 0x2e83f40, 0x2ea9980, 0x2ea9980:1 [ORD=87]

    0x2e7fbb0: <multiple use>
    0x2e7fbb0: <multiple use>
    0x2e84440: <multiple use>
    0x2e84440: <multiple use>
  0x2e7fcb0: i64,ch,glue = ADJCALLSTACKUP64 0x2e7fbb0, 0x2e7fbb0, 0x2e84440, 0x2e84440:1 [ORD=87]

  0x2e84540: i32 = TargetConstant<4>

      0x2e7fcb0: <multiple use>
      0x2e7fdb0: i32 = Register %EAX

      0x2e7fcb0: <multiple use>
    0x2e7f3b0: i32,ch,glue = CopyFromReg 0x2e7fcb0:1, 0x2e7fdb0, 0x2e7fcb0:2 [ORD=87]

  0x2ea9b80: ch = RET 0x2e7f3b0:1 [ORD=88]


********** List Scheduling BB#0 'entry' **********
SU(0): 0x2ea9b80: ch = RET 0x2e7f3b0:1 [ORD=88] [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 0
  Predecessors:
   ch  SU(1): Latency=1

SU(1): 0x2e7f3b0: i32,ch,glue = CopyFromReg 0x2e7fcb0:1, 0x2e7fdb0, 0x2e7fcb0:2 [ORD=87] [ID=1]

    0x2ea9680: ch,glue = CopyToReg 0x2e7f8b0:1, 0x2e84340, 0x2e83d40 [ORD=87] [ID=1]

    0x2eaa480: ch,glue = CopyToReg 0x2ea9680, 0x2e84640, 0x2eaa280, 0x2ea9680:1 [ORD=87] [ID=1]

    0x2ea9980: ch,glue = CopyToReg 0x2eaa480, 0x2e84840, 0x2e83c40, 0x2eaa480:1 [ORD=87] [ID=1]

    0x2e84440: ch,glue = CALL64r 0x2ea9c80, 0x2e84340, 0x2e84640, 0x2e84840, 0x2e83f40, 0x2ea9980, 0x2ea9980:1 [ORD=87] [ID=1]

    0x2e7fcb0: i64,ch,glue = ADJCALLSTACKUP64 0x2e7fbb0, 0x2e7fbb0, 0x2e84440, 0x2e84440:1 [ORD=87] [ID=1]

  # preds left       : 5
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 1
  Predecessors:
   val SU(16): Latency=1
   val SU(2): Latency=1
   val SU(4): Latency=1
   ch  SU(6): Latency=1
   val SU(5): Latency=1
  Successors:
   ch  SU(0): Latency=1

SU(2): 0x2e83c40: i8 = EXTRACT_SUBREG 0x2eaa380, 0x2e7f5b0 [ID=2]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
   val SU(3): Latency=1
  Successors:
   val SU(1): Latency=1

SU(3): 0x2eaa380: i32,i32 = MOV32r0 [ID=3]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
   val SU(2): Latency=1

SU(4): 0x2eaa280: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=79] [ID=4]

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
   val SU(1): Latency=1
   val SU(7): Latency=1

SU(5): 0x2e83d40: i64 = MOV64ri 0x2ea9d80 [ORD=87] [ID=5]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
   val SU(1): Latency=1

SU(6): 0x2e7f8b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7fbb0, 0x2e83b40 [ORD=87] [ID=6]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 2
  Predecessors:
   ch  SU(7): Latency=1
  Successors:
   ch  SU(1): Latency=1

SU(7): 0x2e83b40: ch = MOV32mr 0x2eaa080, 0x2e84740, 0x2ea9780, 0x2ea9e80, 0x2e84240, 0x2eaa280, 0x2ea9f80:1<Mem:ST4[%i.addr]> [ORD=85] [ID=7]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 3
  Predecessors:
   val SU(4): Latency=1
   ch  SU(8): Latency=1
  Successors:
   ch  SU(6): Latency=1

SU(8): 0x2ea9f80: i64,ch,glue = CopyFromReg 0x2e7f6b0:1, 0x2e801b0, 0x2e7f6b0:2 [ORD=83] [ID=8]

    0x2e7feb0: ch,glue = CopyToReg 0x2e7f7b0:1, 0x2e84340, 0x2e83e40 [ORD=83] [ID=8]

    0x2e7f4b0: ch,glue = CopyToReg 0x2e7feb0, 0x2ea9880, 0x2e84040, 0x2e7feb0:1 [ORD=83] [ID=8]

    0x2e800b0: ch,glue = CALL64r 0x2eaa180, 0x2e84340, 0x2ea9880, 0x2e83f40, 0x2e7f4b0, 0x2e7f4b0:1 [ORD=83] [ID=8]

    0x2e7f6b0: i64,ch,glue = ADJCALLSTACKUP64 0x2e7fbb0, 0x2e7fbb0, 0x2e800b0, 0x2e800b0:1 [ORD=83] [ID=8]

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 4
  Predecessors:
   val SU(14): Latency=1
   val SU(9): Latency=1
   ch  SU(13): Latency=1
   val SU(11): Latency=1
  Successors:
   ch  SU(7): Latency=1

SU(9): 0x2e84040: i64 = SUBREG_TO_REG 0x2e7fbb0, 0x2e84140, 0x2e84540 [ID=9]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
   val SU(10): Latency=1
  Successors:
   val SU(8): Latency=1

SU(10): 0x2e84140: i32 = MOV32ri64 0x2ea9a80 [ID=10]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
   val SU(9): Latency=1

SU(11): 0x2e83e40: i64 = SUBREG_TO_REG 0x2e7fbb0, 0x2e7ffb0, 0x2e84540 [ID=11]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
   val SU(12): Latency=1
  Successors:
   val SU(8): Latency=1

SU(12): 0x2e7ffb0: i32 = MOV32ri64 0x2e84940 [ID=12]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
   val SU(11): Latency=1

SU(13): 0x2e7f7b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7fbb0, 0x2e5c478 [ORD=83] [ID=13]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
   ch  SU(8): Latency=1

SU(14): 0x2eaa180: i64 = SUBREG_TO_REG 0x2e7fbb0, 0x2e7fab0, 0x2e84540 [ID=14]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
   val SU(15): Latency=1
  Successors:
   val SU(8): Latency=1

SU(15): 0x2e7fab0: i32 = MOV32ri64 0x2e7f9b0 [ID=15]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
   val SU(14): Latency=1

SU(16): 0x2ea9c80: i64 = MOV64ri 0x2eaa8d0 [ORD=87] [ID=16]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
   val SU(1): Latency=1


Examining Available:
Height 0: SU(0): 0x2ea9b80: ch = RET 0x2e7f3b0:1 [ORD=88] [ID=0]


*** Scheduling [0]: SU(0): 0x2ea9b80: ch = RET 0x2e7f3b0:1 [ORD=88] [ID=0]


Examining Available:
Height 1: SU(1): 0x2e7f3b0: i32,ch,glue = CopyFromReg 0x2e7fcb0:1, 0x2e7fdb0, 0x2e7fcb0:2 [ORD=87] [ID=1]

    0x2ea9680: ch,glue = CopyToReg 0x2e7f8b0:1, 0x2e84340, 0x2e83d40 [ORD=87] [ID=1]

    0x2eaa480: ch,glue = CopyToReg 0x2ea9680, 0x2e84640, 0x2eaa280, 0x2ea9680:1 [ORD=87] [ID=1]

    0x2ea9980: ch,glue = CopyToReg 0x2eaa480, 0x2e84840, 0x2e83c40, 0x2eaa480:1 [ORD=87] [ID=1]

    0x2e84440: ch,glue = CALL64r 0x2ea9c80, 0x2e84340, 0x2e84640, 0x2e84840, 0x2e83f40, 0x2ea9980, 0x2ea9980:1 [ORD=87] [ID=1]

    0x2e7fcb0: i64,ch,glue = ADJCALLSTACKUP64 0x2e7fbb0, 0x2e7fbb0, 0x2e84440, 0x2e84440:1 [ORD=87] [ID=1]


*** Scheduling [1]: SU(1): 0x2e7f3b0: i32,ch,glue = CopyFromReg 0x2e7fcb0:1, 0x2e7fdb0, 0x2e7fcb0:2 [ORD=87] [ID=1]

    0x2ea9680: ch,glue = CopyToReg 0x2e7f8b0:1, 0x2e84340, 0x2e83d40 [ORD=87] [ID=1]

    0x2eaa480: ch,glue = CopyToReg 0x2ea9680, 0x2e84640, 0x2eaa280, 0x2ea9680:1 [ORD=87] [ID=1]

    0x2ea9980: ch,glue = CopyToReg 0x2eaa480, 0x2e84840, 0x2e83c40, 0x2eaa480:1 [ORD=87] [ID=1]

    0x2e84440: ch,glue = CALL64r 0x2ea9c80, 0x2e84340, 0x2e84640, 0x2e84840, 0x2e83f40, 0x2ea9980, 0x2ea9980:1 [ORD=87] [ID=1]

    0x2e7fcb0: i64,ch,glue = ADJCALLSTACKUP64 0x2e7fbb0, 0x2e7fbb0, 0x2e84440, 0x2e84440:1 [ORD=87] [ID=1]


Examining Available:
Height 2: SU(2): 0x2e83c40: i8 = EXTRACT_SUBREG 0x2eaa380, 0x2e7f5b0 [ID=2]

Height 2: SU(16): 0x2ea9c80: i64 = MOV64ri 0x2eaa8d0 [ORD=87] [ID=16]

Height 2: SU(5): 0x2e83d40: i64 = MOV64ri 0x2ea9d80 [ORD=87] [ID=5]

Height 2: SU(6): 0x2e7f8b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7fbb0, 0x2e83b40 [ORD=87] [ID=6]


*** Scheduling [2]: SU(2): 0x2e83c40: i8 = EXTRACT_SUBREG 0x2eaa380, 0x2e7f5b0 [ID=2]


Examining Available:
Height 3: SU(3): 0x2eaa380: i32,i32 = MOV32r0 [ID=3]

Height 2: SU(16): 0x2ea9c80: i64 = MOV64ri 0x2eaa8d0 [ORD=87] [ID=16]

Height 2: SU(5): 0x2e83d40: i64 = MOV64ri 0x2ea9d80 [ORD=87] [ID=5]

Height 2: SU(6): 0x2e7f8b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7fbb0, 0x2e83b40 [ORD=87] [ID=6]


*** Scheduling [3]: SU(3): 0x2eaa380: i32,i32 = MOV32r0 [ID=3]


Examining Available:
Height 2: SU(16): 0x2ea9c80: i64 = MOV64ri 0x2eaa8d0 [ORD=87] [ID=16]

Height 2: SU(5): 0x2e83d40: i64 = MOV64ri 0x2ea9d80 [ORD=87] [ID=5]

Height 2: SU(6): 0x2e7f8b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7fbb0, 0x2e83b40 [ORD=87] [ID=6]


*** Scheduling [4]: SU(16): 0x2ea9c80: i64 = MOV64ri 0x2eaa8d0 [ORD=87] [ID=16]


Examining Available:
Height 2: SU(5): 0x2e83d40: i64 = MOV64ri 0x2ea9d80 [ORD=87] [ID=5]

Height 2: SU(6): 0x2e7f8b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7fbb0, 0x2e83b40 [ORD=87] [ID=6]


*** Scheduling [5]: SU(5): 0x2e83d40: i64 = MOV64ri 0x2ea9d80 [ORD=87] [ID=5]


Examining Available:
Height 2: SU(6): 0x2e7f8b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7fbb0, 0x2e83b40 [ORD=87] [ID=6]


*** Scheduling [6]: SU(6): 0x2e7f8b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7fbb0, 0x2e83b40 [ORD=87] [ID=6]


Examining Available:
Height 7: SU(7): 0x2e83b40: ch = MOV32mr 0x2eaa080, 0x2e84740, 0x2ea9780, 0x2ea9e80, 0x2e84240, 0x2eaa280, 0x2ea9f80:1<Mem:ST4[%i.addr]> [ORD=85] [ID=7]


*** Scheduling [7]: SU(7): 0x2e83b40: ch = MOV32mr 0x2eaa080, 0x2e84740, 0x2ea9780, 0x2ea9e80, 0x2e84240, 0x2eaa280, 0x2ea9f80:1<Mem:ST4[%i.addr]> [ORD=85] [ID=7]


Examining Available:
Height 8: SU(8): 0x2ea9f80: i64,ch,glue = CopyFromReg 0x2e7f6b0:1, 0x2e801b0, 0x2e7f6b0:2 [ORD=83] [ID=8]

    0x2e7feb0: ch,glue = CopyToReg 0x2e7f7b0:1, 0x2e84340, 0x2e83e40 [ORD=83] [ID=8]

    0x2e7f4b0: ch,glue = CopyToReg 0x2e7feb0, 0x2ea9880, 0x2e84040, 0x2e7feb0:1 [ORD=83] [ID=8]

    0x2e800b0: ch,glue = CALL64r 0x2eaa180, 0x2e84340, 0x2ea9880, 0x2e83f40, 0x2e7f4b0, 0x2e7f4b0:1 [ORD=83] [ID=8]

    0x2e7f6b0: i64,ch,glue = ADJCALLSTACKUP64 0x2e7fbb0, 0x2e7fbb0, 0x2e800b0, 0x2e800b0:1 [ORD=83] [ID=8]

Height 8: SU(4): 0x2eaa280: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=79] [ID=4]


*** Scheduling [8]: SU(8): 0x2ea9f80: i64,ch,glue = CopyFromReg 0x2e7f6b0:1, 0x2e801b0, 0x2e7f6b0:2 [ORD=83] [ID=8]

    0x2e7feb0: ch,glue = CopyToReg 0x2e7f7b0:1, 0x2e84340, 0x2e83e40 [ORD=83] [ID=8]

    0x2e7f4b0: ch,glue = CopyToReg 0x2e7feb0, 0x2ea9880, 0x2e84040, 0x2e7feb0:1 [ORD=83] [ID=8]

    0x2e800b0: ch,glue = CALL64r 0x2eaa180, 0x2e84340, 0x2ea9880, 0x2e83f40, 0x2e7f4b0, 0x2e7f4b0:1 [ORD=83] [ID=8]

    0x2e7f6b0: i64,ch,glue = ADJCALLSTACKUP64 0x2e7fbb0, 0x2e7fbb0, 0x2e800b0, 0x2e800b0:1 [ORD=83] [ID=8]


Examining Available:
Height 9: SU(14): 0x2eaa180: i64 = SUBREG_TO_REG 0x2e7fbb0, 0x2e7fab0, 0x2e84540 [ID=14]

Height 9: SU(9): 0x2e84040: i64 = SUBREG_TO_REG 0x2e7fbb0, 0x2e84140, 0x2e84540 [ID=9]

Height 9: SU(11): 0x2e83e40: i64 = SUBREG_TO_REG 0x2e7fbb0, 0x2e7ffb0, 0x2e84540 [ID=11]

Height 9: SU(13): 0x2e7f7b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7fbb0, 0x2e5c478 [ORD=83] [ID=13]

Height 8: SU(4): 0x2eaa280: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=79] [ID=4]


*** Scheduling [9]: SU(14): 0x2eaa180: i64 = SUBREG_TO_REG 0x2e7fbb0, 0x2e7fab0, 0x2e84540 [ID=14]


Examining Available:
Height 10: SU(15): 0x2e7fab0: i32 = MOV32ri64 0x2e7f9b0 [ID=15]

Height 9: SU(9): 0x2e84040: i64 = SUBREG_TO_REG 0x2e7fbb0, 0x2e84140, 0x2e84540 [ID=9]

Height 9: SU(11): 0x2e83e40: i64 = SUBREG_TO_REG 0x2e7fbb0, 0x2e7ffb0, 0x2e84540 [ID=11]

Height 9: SU(13): 0x2e7f7b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7fbb0, 0x2e5c478 [ORD=83] [ID=13]

Height 8: SU(4): 0x2eaa280: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=79] [ID=4]


*** Scheduling [10]: SU(15): 0x2e7fab0: i32 = MOV32ri64 0x2e7f9b0 [ID=15]


Examining Available:
Height 9: SU(9): 0x2e84040: i64 = SUBREG_TO_REG 0x2e7fbb0, 0x2e84140, 0x2e84540 [ID=9]

Height 9: SU(11): 0x2e83e40: i64 = SUBREG_TO_REG 0x2e7fbb0, 0x2e7ffb0, 0x2e84540 [ID=11]

Height 9: SU(13): 0x2e7f7b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7fbb0, 0x2e5c478 [ORD=83] [ID=13]

Height 8: SU(4): 0x2eaa280: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=79] [ID=4]


*** Scheduling [11]: SU(9): 0x2e84040: i64 = SUBREG_TO_REG 0x2e7fbb0, 0x2e84140, 0x2e84540 [ID=9]


Examining Available:
Height 12: SU(10): 0x2e84140: i32 = MOV32ri64 0x2ea9a80 [ID=10]

Height 9: SU(11): 0x2e83e40: i64 = SUBREG_TO_REG 0x2e7fbb0, 0x2e7ffb0, 0x2e84540 [ID=11]

Height 9: SU(13): 0x2e7f7b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7fbb0, 0x2e5c478 [ORD=83] [ID=13]

Height 8: SU(4): 0x2eaa280: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=79] [ID=4]


*** Scheduling [12]: SU(10): 0x2e84140: i32 = MOV32ri64 0x2ea9a80 [ID=10]


Examining Available:
Height 9: SU(11): 0x2e83e40: i64 = SUBREG_TO_REG 0x2e7fbb0, 0x2e7ffb0, 0x2e84540 [ID=11]

Height 9: SU(13): 0x2e7f7b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7fbb0, 0x2e5c478 [ORD=83] [ID=13]

Height 8: SU(4): 0x2eaa280: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=79] [ID=4]


*** Scheduling [13]: SU(11): 0x2e83e40: i64 = SUBREG_TO_REG 0x2e7fbb0, 0x2e7ffb0, 0x2e84540 [ID=11]


Examining Available:
Height 14: SU(12): 0x2e7ffb0: i32 = MOV32ri64 0x2e84940 [ID=12]

Height 9: SU(13): 0x2e7f7b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7fbb0, 0x2e5c478 [ORD=83] [ID=13]

Height 8: SU(4): 0x2eaa280: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=79] [ID=4]


*** Scheduling [14]: SU(12): 0x2e7ffb0: i32 = MOV32ri64 0x2e84940 [ID=12]


Examining Available:
Height 9: SU(13): 0x2e7f7b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7fbb0, 0x2e5c478 [ORD=83] [ID=13]

Height 8: SU(4): 0x2eaa280: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=79] [ID=4]


*** Scheduling [15]: SU(13): 0x2e7f7b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7fbb0, 0x2e5c478 [ORD=83] [ID=13]


Examining Available:
Height 8: SU(4): 0x2eaa280: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=79] [ID=4]


*** Scheduling [16]: SU(4): 0x2eaa280: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=79] [ID=4]

*** Final schedule ***
SU(4): 0x2eaa280: i32,ch = CopyFromReg 0x2e5c478, 0x2eaa9d0 [ORD=79] [ID=4]

SU(13): 0x2e7f7b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7fbb0, 0x2e5c478 [ORD=83] [ID=13]

SU(12): 0x2e7ffb0: i32 = MOV32ri64 0x2e84940 [ID=12]

SU(11): 0x2e83e40: i64 = SUBREG_TO_REG 0x2e7fbb0, 0x2e7ffb0, 0x2e84540 [ID=11]

SU(10): 0x2e84140: i32 = MOV32ri64 0x2ea9a80 [ID=10]

SU(9): 0x2e84040: i64 = SUBREG_TO_REG 0x2e7fbb0, 0x2e84140, 0x2e84540 [ID=9]

SU(15): 0x2e7fab0: i32 = MOV32ri64 0x2e7f9b0 [ID=15]

SU(14): 0x2eaa180: i64 = SUBREG_TO_REG 0x2e7fbb0, 0x2e7fab0, 0x2e84540 [ID=14]

SU(8): 0x2ea9f80: i64,ch,glue = CopyFromReg 0x2e7f6b0:1, 0x2e801b0, 0x2e7f6b0:2 [ORD=83] [ID=8]

    0x2e7feb0: ch,glue = CopyToReg 0x2e7f7b0:1, 0x2e84340, 0x2e83e40 [ORD=83] [ID=8]

    0x2e7f4b0: ch,glue = CopyToReg 0x2e7feb0, 0x2ea9880, 0x2e84040, 0x2e7feb0:1 [ORD=83] [ID=8]

    0x2e800b0: ch,glue = CALL64r 0x2eaa180, 0x2e84340, 0x2ea9880, 0x2e83f40, 0x2e7f4b0, 0x2e7f4b0:1 [ORD=83] [ID=8]

    0x2e7f6b0: i64,ch,glue = ADJCALLSTACKUP64 0x2e7fbb0, 0x2e7fbb0, 0x2e800b0, 0x2e800b0:1 [ORD=83] [ID=8]

SU(7): 0x2e83b40: ch = MOV32mr 0x2eaa080, 0x2e84740, 0x2ea9780, 0x2ea9e80, 0x2e84240, 0x2eaa280, 0x2ea9f80:1<Mem:ST4[%i.addr]> [ORD=85] [ID=7]

SU(6): 0x2e7f8b0: i64,ch,glue = ADJCALLSTACKDOWN64 0x2e7fbb0, 0x2e83b40 [ORD=87] [ID=6]

SU(5): 0x2e83d40: i64 = MOV64ri 0x2ea9d80 [ORD=87] [ID=5]

SU(16): 0x2ea9c80: i64 = MOV64ri 0x2eaa8d0 [ORD=87] [ID=16]

SU(3): 0x2eaa380: i32,i32 = MOV32r0 [ID=3]

SU(2): 0x2e83c40: i8 = EXTRACT_SUBREG 0x2eaa380, 0x2e7f5b0 [ID=2]

SU(1): 0x2e7f3b0: i32,ch,glue = CopyFromReg 0x2e7fcb0:1, 0x2e7fdb0, 0x2e7fcb0:2 [ORD=87] [ID=1]

    0x2ea9680: ch,glue = CopyToReg 0x2e7f8b0:1, 0x2e84340, 0x2e83d40 [ORD=87] [ID=1]

    0x2eaa480: ch,glue = CopyToReg 0x2ea9680, 0x2e84640, 0x2eaa280, 0x2ea9680:1 [ORD=87] [ID=1]

    0x2ea9980: ch,glue = CopyToReg 0x2eaa480, 0x2e84840, 0x2e83c40, 0x2eaa480:1 [ORD=87] [ID=1]

    0x2e84440: ch,glue = CALL64r 0x2ea9c80, 0x2e84340, 0x2e84640, 0x2e84840, 0x2e83f40, 0x2ea9980, 0x2ea9980:1 [ORD=87] [ID=1]

    0x2e7fcb0: i64,ch,glue = ADJCALLSTACKUP64 0x2e7fbb0, 0x2e7fbb0, 0x2e84440, 0x2e84440:1 [ORD=87] [ID=1]

SU(0): 0x2ea9b80: ch = RET 0x2e7f3b0:1 [ORD=88] [ID=0]


Total amount of phi nodes to update: 0
# Machine code for function func: SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
48B		%vreg1<def> = MOV32ri64 48717472; GR32:%vreg1
64B		%vreg2<def> = SUBREG_TO_REG 0, %vreg1<kill>, 4; GR64:%vreg2 GR32:%vreg1
80B		%vreg3<def> = MOV32ri64 48397984; GR32:%vreg3
96B		%vreg4<def> = SUBREG_TO_REG 0, %vreg3<kill>, 4; GR64:%vreg4 GR32:%vreg3
112B		%vreg5<def> = MOV32ri64 8971440; GR32:%vreg5
128B		%vreg6<def> = SUBREG_TO_REG 0, %vreg5<kill>, 4; GR64:%vreg6 GR32:%vreg5
144B		%RDI<def> = COPY %vreg2; GR64:%vreg2
160B		%RSI<def> = COPY %vreg4; GR64:%vreg4
176B		CALL64r %vreg6<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def>; GR64:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		%vreg7<def> = COPY %RAX; GR64:%vreg7
224B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
240B		ADJCALLSTACKDOWN64 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg8<def> = MOV64ri <ga:@.str>; GR64:%vreg8
272B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
288B		%vreg10<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
304B		%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
320B		%RDI<def> = COPY %vreg8; GR64:%vreg8
336B		%ESI<def> = COPY %vreg0; GR32:%vreg0
352B		%AL<def> = COPY %vreg11; GR8:%vreg11
368B		CALL64r %vreg9<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def>; GR64:%vreg9
384B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def,dead>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
400B		%vreg12<def> = COPY %EAX; GR32:%vreg12
416B		RET

# End machine code for function func.

********** Stack Coloring **********
********** Function: func
Found 0 markers and 1 slots
Slot structure:
Slot #0 - 4 bytes.
Total Stack size: 4 bytes

Will not try to merge slots.
Removed 0 markers.
DeadMachineInstructionElim: DELETING: %vreg12<def> = COPY %EAX; GR32:%vreg12
DeadMachineInstructionElim: DELETING: %vreg7<def> = COPY %RAX; GR64:%vreg7
******** Pre-regalloc Machine LICM: func ********
Entering: entry
Exiting: entry
******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: func
********** PROCESS IMPLICIT DEFS **********
********** Function: func
********** REWRITING TWO-ADDR INSTRS **********
********** Function: func
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI<kill>; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
48B		%vreg1<def> = MOV32ri64 48717472; GR32:%vreg1
64B		%vreg2<def> = SUBREG_TO_REG 0, %vreg1<kill>, 4; GR64:%vreg2 GR32:%vreg1
80B		%vreg3<def> = MOV32ri64 48397984; GR32:%vreg3
96B		%vreg4<def> = SUBREG_TO_REG 0, %vreg3<kill>, 4; GR64:%vreg4 GR32:%vreg3
112B		%vreg5<def> = MOV32ri64 8971440; GR32:%vreg5
128B		%vreg6<def> = SUBREG_TO_REG 0, %vreg5<kill>, 4; GR64:%vreg6 GR32:%vreg5
144B		%RDI<def> = COPY %vreg2<kill>; GR64:%vreg2
160B		%RSI<def> = COPY %vreg4<kill>; GR64:%vreg4
176B		CALL64r %vreg6<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use,kill>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
240B		%vreg8<def> = MOV64ri <ga:@.str>; GR64:%vreg8
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
272B		%vreg10<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
288B		%vreg11<def> = COPY %vreg10:sub_8bit<kill>; GR8:%vreg11 GR32:%vreg10
304B		%RDI<def> = COPY %vreg8<kill>; GR64:%vreg8
320B		%ESI<def> = COPY %vreg0<kill>; GR32:%vreg0
336B		%AL<def> = COPY %vreg11<kill>; GR8:%vreg11
352B		CALL64r %vreg9<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use,kill>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

Computing live-in reg-units in ABI blocks.
0B	BB#0 DIL#0
Created 1 new intervals.
********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
%vreg0 [16r,320r:0)  0@16r
%vreg1 [48r,64r:0)  0@48r
%vreg2 [64r,144r:0)  0@64r
%vreg3 [80r,96r:0)  0@80r
%vreg4 [96r,160r:0)  0@96r
%vreg5 [112r,128r:0)  0@112r
%vreg6 [128r,176r:0)  0@128r
%vreg8 [240r,304r:0)  0@240r
%vreg9 [256r,352r:0)  0@256r
%vreg10 [272r,288r:0)  0@272r
%vreg11 [288r,336r:0)  0@288r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
48B		%vreg1<def> = MOV32ri64 48717472; GR32:%vreg1
64B		%vreg2<def> = SUBREG_TO_REG 0, %vreg1, 4; GR64:%vreg2 GR32:%vreg1
80B		%vreg3<def> = MOV32ri64 48397984; GR32:%vreg3
96B		%vreg4<def> = SUBREG_TO_REG 0, %vreg3, 4; GR64:%vreg4 GR32:%vreg3
112B		%vreg5<def> = MOV32ri64 8971440; GR32:%vreg5
128B		%vreg6<def> = SUBREG_TO_REG 0, %vreg5, 4; GR64:%vreg6 GR32:%vreg5
144B		%RDI<def> = COPY %vreg2; GR64:%vreg2
160B		%RSI<def> = COPY %vreg4; GR64:%vreg4
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
240B		%vreg8<def> = MOV64ri <ga:@.str>; GR64:%vreg8
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
272B		%vreg10<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
288B		%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
304B		%RDI<def> = COPY %vreg8; GR64:%vreg8
320B		%ESI<def> = COPY %vreg0; GR32:%vreg0
336B		%AL<def> = COPY %vreg11; GR8:%vreg11
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

********** SIMPLE REGISTER COALESCING **********
********** Function: func
********** JOINING INTERVALS ***********
entry:
16B	%vreg0<def> = COPY %EDI; GR32:%vreg0
	Considering merging %vreg0 with %EDI
	Can only merge into reserved registers.
64B	%vreg2<def> = SUBREG_TO_REG 0, %vreg1, 4; GR64:%vreg2 GR32:%vreg1
	Considering merging to GR64_with_sub_8bit with %vreg1 in %vreg2:sub_32bit
		RHS = %vreg1 [48r,64r:0)  0@48r
		LHS = %vreg2 [64r,144r:0)  0@64r
		merge %vreg2:0@64r into %vreg1:0@48r --> @48r
		erased:	64r	%vreg2<def> = SUBREG_TO_REG 0, %vreg1, 4; GR64:%vreg2 GR32:%vreg1
		updated: 48B	%vreg2:sub_32bit<def,read-undef> = MOV32ri64 48717472; GR64_with_sub_8bit:%vreg2
	Joined. Result = %vreg2 [48r,144r:0)  0@48r
96B	%vreg4<def> = SUBREG_TO_REG 0, %vreg3, 4; GR64:%vreg4 GR32:%vreg3
	Considering merging to GR64_with_sub_8bit with %vreg3 in %vreg4:sub_32bit
		RHS = %vreg3 [80r,96r:0)  0@80r
		LHS = %vreg4 [96r,160r:0)  0@96r
		merge %vreg4:0@96r into %vreg3:0@80r --> @80r
		erased:	96r	%vreg4<def> = SUBREG_TO_REG 0, %vreg3, 4; GR64:%vreg4 GR32:%vreg3
		updated: 80B	%vreg4:sub_32bit<def,read-undef> = MOV32ri64 48397984; GR64_with_sub_8bit:%vreg4
	Joined. Result = %vreg4 [80r,160r:0)  0@80r
128B	%vreg6<def> = SUBREG_TO_REG 0, %vreg5, 4; GR64:%vreg6 GR32:%vreg5
	Considering merging to GR64_with_sub_8bit with %vreg5 in %vreg6:sub_32bit
		RHS = %vreg5 [112r,128r:0)  0@112r
		LHS = %vreg6 [128r,176r:0)  0@128r
		merge %vreg6:0@128r into %vreg5:0@112r --> @112r
		erased:	128r	%vreg6<def> = SUBREG_TO_REG 0, %vreg5, 4; GR64:%vreg6 GR32:%vreg5
		updated: 112B	%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
	Joined. Result = %vreg6 [112r,176r:0)  0@112r
144B	%RDI<def> = COPY %vreg2; GR64_with_sub_8bit:%vreg2
	Considering merging %vreg2 with %RDI
	Can only merge into reserved registers.
Remat: %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
Shrink: %vreg2 [48r,144r:0)  0@48r
All defs dead: 48r	%vreg2:sub_32bit<def,read-undef,dead> = MOV32ri64 48717472; GR64_with_sub_8bit:%vreg2
Shrunk: %vreg2 [48r,48d:0)  0@48r
Deleting dead def 48r	%vreg2:sub_32bit<def,read-undef,dead> = MOV32ri64 48717472; GR64_with_sub_8bit:%vreg2
160B	%RSI<def> = COPY %vreg4; GR64_with_sub_8bit:%vreg4
	Considering merging %vreg4 with %RSI
	Can only merge into reserved registers.
Remat: %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
Shrink: %vreg4 [80r,160r:0)  0@80r
All defs dead: 80r	%vreg4:sub_32bit<def,read-undef,dead> = MOV32ri64 48397984; GR64_with_sub_8bit:%vreg4
Shrunk: %vreg4 [80r,80d:0)  0@80r
Deleting dead def 80r	%vreg4:sub_32bit<def,read-undef,dead> = MOV32ri64 48397984; GR64_with_sub_8bit:%vreg4
304B	%RDI<def> = COPY %vreg8; GR64:%vreg8
	Considering merging %vreg8 with %RDI
	Can only merge into reserved registers.
Remat: %RDI<def> = MOV64ri <ga:@.str>
Shrink: %vreg8 [240r,304r:0)  0@240r
All defs dead: 240r	%vreg8<def,dead> = MOV64ri <ga:@.str>; GR64:%vreg8
Shrunk: %vreg8 [240r,240d:0)  0@240r
Deleting dead def 240r	%vreg8<def,dead> = MOV64ri <ga:@.str>; GR64:%vreg8
320B	%ESI<def> = COPY %vreg0; GR32:%vreg0
	Considering merging %vreg0 with %ESI
	Can only merge into reserved registers.
336B	%AL<def> = COPY %vreg11; GR8:%vreg11
	Considering merging %vreg11 with %AL
	Can only merge into reserved registers.
288B	%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
	Considering merging to GR32 with %vreg11 in %vreg10:sub_8bit
		RHS = %vreg11 [288r,336r:0)  0@288r
		LHS = %vreg10 [272r,288r:0)  0@272r
		merge %vreg11:0@288r into %vreg10:0@272r --> @272r
		erased:	288r	%vreg11<def> = COPY %vreg10:sub_8bit; GR8:%vreg11 GR32:%vreg10
		updated: 336B	%AL<def> = COPY %vreg10:sub_8bit; GR32:%vreg10
	Joined. Result = %vreg10 [272r,336r:0)  0@272r
320B	%ESI<def> = COPY %vreg0; GR32:%vreg0
	Considering merging %vreg0 with %ESI
	Can only merge into reserved registers.
336B	%AL<def> = COPY %vreg10:sub_8bit; GR32:%vreg10
	Considering merging %vreg10 with %EAX
	Can only merge into reserved registers.
Remat: %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
Shrink: %vreg10 [272r,336r:0)  0@272r
All defs dead: 272r	%vreg10<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
Shrunk: %vreg10 [272r,272d:0)  0@272r
Deleting dead def 272r	%vreg10<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg10
320B	%ESI<def> = COPY %vreg0; GR32:%vreg0
	Considering merging %vreg0 with %ESI
	Can only merge into reserved registers.
Trying to inflate 0 regs.
********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
%vreg0 [16r,320r:0)  0@16r
%vreg6 [112r,176r:0)  0@112r
%vreg9 [256r,352r:0)  0@256r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
320B		%ESI<def> = COPY %vreg0; GR32:%vreg0
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

Before MISsched:
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

BB#0: derived from LLVM BB %entry
    Live Ins: %EDI
	%vreg0<def> = COPY %EDI; GR32:%vreg0
	ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
	%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
	%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
	CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use,kill>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
	ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
	ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
	%RDI<def> = MOV64ri <ga:@.str>
	%ESI<def> = COPY %vreg0; GR32:%vreg0
	%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
	CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
	ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
	RET

# End machine code for function func.

********** MI Scheduling **********
func:BB#0 entry
  From: %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
    To: CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
 RegionInstrs: 4 Remaining: 9
Disabled scoreboard hazard recognizer
Disabled scoreboard hazard recognizer
SU(0):   %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   val SU(4294967295): Latency=1 Reg=%vreg9

SU(1):   %RDI<def> = MOV64ri <ga:@.str>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

SU(2):   %ESI<def> = COPY %vreg0; GR32:%vreg0
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
   ch  SU(4294967295) *: Latency=0

SU(3):   %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

Critical Path: 1
BotQ.A: 0 3 2 1 
  SU(0) ORDER                              
  SU(3) ORDER                              
  SU(2) PREG-COPY                         
Pick Bot PREG-COPY
Scheduling SU(2) %ESI<def> = COPY %vreg0; GR32:%vreg0
handleMove 320B -> 344B: %ESI<def> = COPY %vreg0; GR32:%vreg0
     SIL:	[160r,176r:0)[344r,352r:1)  0@160r 1@344r
        -->	[160r,176r:0)[344r,352r:1)  0@160r 1@344r
     %vreg0:	[16r,320r:0)  0@16r
        -->	[16r,344r:0)  0@16r
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
BotQ.A: 0 3 1 
  SU(0) ORDER                              
  SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
  Ready @1c
  BotQ.A BotLatency SU(3) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
BotQ.A: 0 1 
  SU(0) ORDER                              
  SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %RDI<def> = MOV64ri <ga:@.str>
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
Scheduling SU(0) %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 3 MOps
  ExpectedLatency: 1c
  - Latency limited.
*** Final schedule for BB#0 ***
SU(0):   %vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
SU(1):   %RDI<def> = MOV64ri <ga:@.str>
SU(3):   %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
SU(2):   %ESI<def> = COPY %vreg0; GR32:%vreg0

********** MI Scheduling **********
func:BB#0 entry
  From: %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
    To: CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
 RegionInstrs: 3 Remaining: 2
SU(0):   %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   val SU(4294967295): Latency=1 Reg=%vreg6

SU(1):   %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

SU(2):   %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   ch  SU(4294967295) *: Latency=1

Critical Path: 1
BotQ.A: 0 2 1 
  SU(0) ORDER                              
  SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
  Ready @1c
  SBPort015 +1x4u
  *** Critical resource SBPort015: 0c
  SBPortAny +1x2u
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
BotQ.A: 0 1 
  SU(0) ORDER                              
  SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
Scheduling SU(0) %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 3
  Executed: 1c
  Critical: 1c, 3 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
*** Final schedule for BB#0 ***
SU(0):   %vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
SU(1):   %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
SU(2):   %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>

********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
SIL [160r,176r:0)[344r,352r:1)  0@160r 1@344r
%vreg0 [16r,344r:0)  0@16r
%vreg6 [112r,176r:0)  0@112r
%vreg9 [256r,352r:0)  0@256r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
344B		%ESI<def> = COPY %vreg0; GR32:%vreg0
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.

RPO[BB#0 derived from LLVM BB entry] = 1
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#0 derived from LLVM BB entry)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0.0
Frequency(BB#0 derived from LLVM BB entry) = 1.0
LoopExitProb[BB#0 derived from LLVM BB entry] = 16383 / 16384 = 99.9939% from 1 - 0.0 / 1.0.
********** COMPUTING LIVE DEBUG VARIABLES: func **********
********** DEBUG VARIABLES **********
********** GREEDY REGISTER ALLOCATION **********
********** Function: func
********** Compute Spill Weights **********
********** Function: func
********** INTERVALS **********
DIL [0B,16r:0)[144r,176r:2)[304r,352r:1)  0@0B-phi 1@304r 2@144r
SIL [160r,176r:0)[344r,352r:1)  0@160r 1@344r
%vreg0 [16r,344r:0)  0@16r
%vreg6 [112r,176r:0)  0@112r
%vreg9 [256r,352r:0)  0@256r
RegMasks: 176r 352r
********** MACHINEINSTRS **********
# Machine code for function func: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
344B		%ESI<def> = COPY %vreg0; GR32:%vreg0
352B		CALL64r %vreg9, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET

# End machine code for function func.


selectOrSplit GR32:%vreg0 [16r,344r:0)  0@16r
hints: %EDI
missed hint %EDI
assigning %vreg0 to %EBX: BH BL

selectOrSplit GR64_with_sub_8bit:%vreg6 [112r,176r:0)  0@112r
assigning %vreg6 to %RAX: AH AL

selectOrSplit GR64:%vreg9 [256r,352r:0)  0@256r
assigning %vreg9 to %RCX: CH CL
********** REWRITE VIRTUAL REGISTERS **********
********** Function: func
********** REGISTER MAP **********
[%vreg0 -> %EBX] GR32
[%vreg6 -> %RAX] GR64_with_sub_8bit
[%vreg9 -> %RCX] GR64

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI
16B		%vreg0<def> = COPY %EDI; GR32:%vreg0
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
112B		%vreg6:sub_32bit<def,read-undef> = MOV32ri64 8971440; GR64_with_sub_8bit:%vreg6
144B		%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
160B		%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
176B		CALL64r %vreg6<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>; GR64_with_sub_8bit:%vreg6
192B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
208B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%i.addr] GR32:%vreg0
224B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
256B		%vreg9<def> = MOV64ri <ga:@printf>; GR64:%vreg9
304B		%RDI<def> = MOV64ri <ga:@.str>
336B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
344B		%ESI<def> = COPY %vreg0<kill>; GR32:%vreg0
352B		CALL64r %vreg9<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def,dead>; GR64:%vreg9
368B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
384B		RET
> %EBX<def> = COPY %EDI
> ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> %EAX<def> = MOV32ri64 8971440, %RAX<imp-def>
> %EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
> %ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
> CALL64r %RAX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>
> ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %EBX; mem:ST4[%i.addr]
> ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> %RCX<def> = MOV64ri <ga:@printf>
> %RDI<def> = MOV64ri <ga:@.str>
> %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
> %ESI<def> = COPY %EBX<kill>
> CALL64r %RCX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def,dead>
> ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> RET
********** EMITTING LIVE DEBUG VARIABLES **********
********** Stack Slot Coloring **********
********** Function: func
******** Post-regalloc Machine LICM: func ********

Setting up live-ins for BB#0 derived from entry.
Block has no FP live-ins.

FPInst:	RET
Stack contents:
Inserted instructions:
	RET
Stack contents:
alloc FI(0) at SP[-28]
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: func
real copy:   %EBX<def> = COPY %EDI
replaced by: %EBX<def> = MOV32rr %EDI
real copy:   %ESI<def> = COPY %EBX<kill>
replaced by: %ESI<def> = MOV32rr %EBX<kill>
RPO[BB#0 derived from LLVM BB entry] = 1
POT: BB#0 derived from LLVM BB entry
doLoop(BB#0 derived from LLVM BB entry, BB#0 derived from LLVM BB entry)
doBlock(BB#0 derived from LLVM BB entry)
Frequency(BB#0 derived from LLVM BB entry) = 0.0
Frequency(BB#0 derived from LLVM BB entry) = 1.0
LoopExitProb[BB#0 derived from LLVM BB entry] = 16383 / 16384 = 99.9939% from 1 - 0.0 / 1.0.
********** FIX EXECUTION DEPENDENCIES: VR128 **********
BB#0: entry
JITTing function 'func'
JIT: Starting CodeGen of Function func
JIT: Emitting BB0 at [0x7f7e4367b290]
PUSH64r %RBP<kill>, %RSP<imp-def>, %RSP<imp-use>; flags: FrameSetup
PROLOG_LABEL <MCSym=.Ltmp24>
%RBP<def> = MOV64rr %RSP; flags: FrameSetup
PROLOG_LABEL <MCSym=.Ltmp25>
PUSH64r %RBX<kill>, %RSP<imp-def>, %RSP<imp-use>; flags: FrameSetup
PUSH64r %RAX<undef>, %RSP<imp-def>, %RSP<imp-use>; flags: FrameSetup
PROLOG_LABEL <MCSym=.Ltmp26>
%EBX<def> = MOV32rr %EDI
%EAX<def> = MOV32ri64 8971440, %RAX<imp-def>
%EDI<def,dead> = MOV32ri64 48717472, %RDI<imp-def>
%ESI<def,dead> = MOV32ri64 48397984, %RSI<imp-def>
CALL64r %RAX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %RSI<imp-use>, %RSP<imp-def>, %RAX<imp-def,dead>
MOV32mr %RBP, 1, %noreg, -12, %noreg, %EBX; mem:ST4[%i.addr]
%RCX<def> = MOV64ri <ga:@printf>
%RDI<def> = MOV64ri <ga:@.str>
%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
%ESI<def> = MOV32rr %EBX<kill>
CALL64r %RCX<kill>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use>, %RSP<imp-def>, %EAX<imp-def,dead>
%RSP<def,tied1> = ADD64ri8 %RSP<tied0>, 8, %EFLAGS<imp-def,dead>
%RBX<def> = POP64r %RSP<imp-def>, %RSP<imp-use>
%RBP<def> = POP64r %RSP<imp-def>, %RSP<imp-use>
RET
JIT: Finished CodeGen of [0x7f7e4367b290] Function: func: 61 bytes of text, 2 relocations
JIT: Binary code:
JIT: 0: 2291377285 2511378083 136228176184 941601910 
JIT: 16: 1601902231 2552226126 24493137208 24324018572 
JIT: 32: 05350132 1917200 6710217616 00127126 
JIT: 48: 22213719249 13172209255 93918196 195
func 11
 runFunction exit
JIT: Map 'exit' to [0x8830a0]
0
1
2
3
4
5
6
7
8
9
10
